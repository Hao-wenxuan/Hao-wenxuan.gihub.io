<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[法语]词汇积累</title>
      <link href="/2022/07/05/Conjugaison-tous%20les%20jours/"/>
      <url>/2022/07/05/Conjugaison-tous%20les%20jours/</url>
      
        <content type="html"><![CDATA[<h1 id="变位-Conjugaison"><a href="#变位-Conjugaison" class="headerlink" title="变位-Conjugaison"></a>变位-Conjugaison</h1><h2 id="直陈式现在时Indicatif-Present"><a href="#直陈式现在时Indicatif-Present" class="headerlink" title="直陈式现在时Indicatif Présent"></a>直陈式现在时<br>Indicatif Présent</h2><table><thead><tr><th align="center">词汇<br>(现分)<br>(过分)</th><th align="center">第一人称单数</th><th align="center">第二人称单数</th><th align="center">第三人称单数</th><th align="center">第一人称复数</th><th align="center">第二人称复数</th><th align="center">第三人称复数</th></tr></thead><tbody><tr><td align="center"><strong>être</strong><br>(étant)<br>(été)</td><td align="center">je <strong>suis</strong></td><td align="center">tu <strong>es</strong></td><td align="center">il <strong>est</strong></td><td align="center">nous <strong>sommes</strong></td><td align="center">vous <strong>êtes</strong></td><td align="center">ils <strong>sont</strong></td></tr><tr><td align="center"><strong>avoir</strong><br>(ayant)<br>(eu)</td><td align="center">j’<strong>ai</strong></td><td align="center">tu <strong>as</strong></td><td align="center">il <strong>a</strong></td><td align="center">nous <strong>avons</strong></td><td align="center">vous <strong>avez</strong></td><td align="center">ils <strong>ont</strong></td></tr><tr><td align="center"><strong>faire</strong><br>(faisant)<br>(fait)</td><td align="center">je <strong>fais</strong></td><td align="center">tu <strong>fais</strong></td><td align="center">il <strong>fait</strong></td><td align="center">nous <strong>faisons</strong></td><td align="center">vous <strong>faites</strong></td><td align="center">ils <strong>font</strong></td></tr><tr><td align="center"><strong>prendre</strong><br>(prenant)<br>(pris)</td><td align="center">je <strong>prends</strong></td><td align="center">tu <strong>prends</strong></td><td align="center">il <strong>prend</strong></td><td align="center">nous <strong>prenons</strong></td><td align="center">vous <strong>prenez</strong></td><td align="center">ils <strong>prennent</strong></td></tr><tr><td align="center"><strong>venir</strong><br>(venant)<br>(venu)</td><td align="center">je <strong>viens</strong></td><td align="center">tu <strong>viens</strong></td><td align="center">il <strong>vient</strong></td><td align="center">nous <strong>venons</strong></td><td align="center">vous <strong>venez</strong></td><td align="center">ils <strong>viennent</strong></td></tr><tr><td align="center"><strong>écrire</strong>(écrivant)<br>(écrit)</td><td align="center">j’<strong>écris</strong></td><td align="center">tu <strong>écris</strong></td><td align="center">il <strong>écrit</strong></td><td align="center">nous <strong>écrivons</strong></td><td align="center">vous <strong>écrivez</strong></td><td align="center">ils <strong>écrivent</strong></td></tr><tr><td align="center"><strong>pouvoir</strong><br>(pourvoyant)<br>(pourvu)</td><td align="center">je <strong>peux&#x2F;puis</strong></td><td align="center">tu <strong>peux</strong></td><td align="center">il <strong>peut</strong></td><td align="center">nous <strong>pouvons</strong></td><td align="center">vous <strong>pouvez</strong></td><td align="center">ils <strong>peuvent</strong></td></tr><tr><td align="center"><strong>lire</strong><br>(lisant)<br>(lu)</td><td align="center">je <strong>lis</strong></td><td align="center">tu <strong>lis</strong></td><td align="center">il <strong>lit</strong></td><td align="center">nous <strong>lisons</strong></td><td align="center">vous <strong>lisez</strong></td><td align="center">ils <strong>lisent</strong></td></tr><tr><td align="center"><strong>vouloir</strong><br>(voulant)<br>(voulu)</td><td align="center">je <strong>veux</strong></td><td align="center">tu <strong>veux</strong></td><td align="center">il <strong>veut</strong></td><td align="center">nous <strong>voulons</strong></td><td align="center">vous <strong>voulez</strong></td><td align="center">ils <strong>veulent</strong></td></tr><tr><td align="center"><strong>partir</strong><br>(partant)<br>(parti)</td><td align="center">je <strong>pars</strong></td><td align="center">tu <strong>pars</strong></td><td align="center">il <strong>part</strong></td><td align="center">nous <strong>partons</strong></td><td align="center">vous <strong>partez</strong></td><td align="center">ils <strong>partent</strong></td></tr><tr><td align="center"><strong>devoir</strong><br>(devant)<br>(dû)</td><td align="center">je <strong>dois</strong></td><td align="center">tu <strong>dois</strong></td><td align="center">il <strong>doit</strong></td><td align="center">nous <strong>devons</strong></td><td align="center">vous <strong>devez</strong></td><td align="center">ils <strong>doivent</strong></td></tr><tr><td align="center"><strong>attendre</strong><br>(attendant)<br>(attendu)</td><td align="center">j’<strong>attends</strong></td><td align="center">tu <strong>attends</strong></td><td align="center">il <strong>attend</strong></td><td align="center">nous <strong>attendons</strong></td><td align="center">vous <strong>attendez</strong></td><td align="center">ils <strong>attendent</strong></td></tr><tr><td align="center"><strong>offrir</strong><br>(offrant)<br>(offert)</td><td align="center">j’<strong>offre</strong></td><td align="center">tu <strong>offres</strong></td><td align="center">il <strong>offre</strong> ｜ nous <strong>offrons</strong></td><td align="center">vous <strong>offrez</strong></td><td align="center">ils <strong>offrent</strong></td><td align="center"></td></tr><tr><td align="center"><strong>ouvrir</strong><br>(ouvrant)<br>(ouvert)</td><td align="center">j’<strong>ouvre</strong></td><td align="center">tu <strong>ouvres</strong></td><td align="center">il <strong>ouvre</strong></td><td align="center">nous <strong>ouvres</strong></td><td align="center">vous <strong>ouvrez</strong></td><td align="center">ils <strong>ouvrent</strong></td></tr><tr><td align="center"><strong>mettre</strong><br>(mettant)<br>(mis)</td><td align="center">je <strong>mets</strong></td><td align="center">tu <strong>mets</strong></td><td align="center">il <strong>met</strong></td><td align="center">nous <strong>mettons</strong></td><td align="center">vous <strong>mettez</strong></td><td align="center">ils <strong>mettent</strong></td></tr><tr><td align="center"><strong>répondre</strong><br>(répondant)<br>(répondu)</td><td align="center">je <strong>réponds</strong></td><td align="center">il <strong>répond</strong></td><td align="center">nous <strong>répondons</strong></td><td align="center">vous <strong>répondez</strong></td><td align="center">ils <strong>répondent</strong></td><td align="center"></td></tr><tr><td align="center"><strong>recevoir</strong><br>(recevant)<br>(reçu)</td><td align="center">je <strong>reçois</strong></td><td align="center">tu <strong>reçois</strong></td><td align="center">il <strong>reçoit</strong></td><td align="center">nous <strong>recevons</strong></td><td align="center">vous <strong>recevez</strong></td><td align="center">ils <strong>reçoivent</strong></td></tr><tr><td align="center"><strong>tenir</strong><br>(tenant)<br>(tenu)</td><td align="center">je <strong>tiens</strong></td><td align="center">tu <strong>tiens</strong></td><td align="center">il <strong>tient</strong></td><td align="center">nous <strong>tenons</strong></td><td align="center">vous <strong>tenez</strong></td><td align="center">ils <strong>tiennent</strong></td></tr><tr><td align="center"><strong>sortir</strong><br>(sortant)<br>(sorti)</td><td align="center">je <strong>sors</strong></td><td align="center">tu <strong>sors</strong></td><td align="center">il <strong>sort</strong></td><td align="center">nous <strong>sortons</strong></td><td align="center">vous <strong>sortez</strong></td><td align="center">ils <strong>sortent</strong></td></tr><tr><td align="center"><strong>boire</strong><br>(buvant)<br>(bu)</td><td align="center">je <strong>bois</strong></td><td align="center">tu <strong>bois</strong></td><td align="center">il <strong>boit</strong></td><td align="center">nous <strong>buvons</strong></td><td align="center">vous <strong>buvez</strong></td><td align="center">ils <strong>boivent</strong></td></tr><tr><td align="center"><strong>servir</strong><br>(servant)<br>(servi)</td><td align="center">je <strong>sers</strong></td><td align="center">tu <strong>sers</strong></td><td align="center">il <strong>sert</strong></td><td align="center">nous <strong>servons</strong></td><td align="center">vous <strong>servez</strong></td><td align="center">ils <strong>servent</strong></td></tr><tr><td align="center"><strong>courir</strong><br>(courant)<br>(couru)</td><td align="center">je <strong>cours</strong></td><td align="center">tu <strong>cours</strong></td><td align="center">il <strong>court</strong></td><td align="center">nous <strong>courons</strong></td><td align="center">vous <strong>courez</strong></td><td align="center">ils <strong>courent</strong></td></tr></tbody></table><h1 id="词汇-Vocabulaire"><a href="#词汇-Vocabulaire" class="headerlink" title="词汇-Vocabulaire"></a>词汇-Vocabulaire</h1><h2 id="日常-quotidien"><a href="#日常-quotidien" class="headerlink" title="日常-quotidien"></a>日常-quotidien</h2><h3 id="月份与星期-Mois-et-semaine"><a href="#月份与星期-Mois-et-semaine" class="headerlink" title="月份与星期-Mois et semaine"></a>月份与星期-Mois et semaine</h3><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">星期一</td><td align="center">lundi</td></tr><tr><td align="center">星期二</td><td align="center">mardi</td></tr><tr><td align="center">星期三</td><td align="center">mercredi</td></tr><tr><td align="center">星期四</td><td align="center">jeudi</td></tr><tr><td align="center">星期五</td><td align="center">vendredi</td></tr><tr><td align="center">星期六</td><td align="center">samedi</td></tr><tr><td align="center">星期日</td><td align="center">dimanche</td></tr></tbody></table><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">一月</td><td align="center">janvier</td></tr><tr><td align="center">二月</td><td align="center">févier</td></tr><tr><td align="center">三月</td><td align="center">mars</td></tr><tr><td align="center">四月</td><td align="center">avril</td></tr><tr><td align="center">五月</td><td align="center">mai</td></tr><tr><td align="center">六月</td><td align="center">juin</td></tr><tr><td align="center">七月</td><td align="center">juillet</td></tr><tr><td align="center">八月</td><td align="center">août</td></tr><tr><td align="center">九月</td><td align="center">septembre</td></tr><tr><td align="center">十月</td><td align="center">octobre</td></tr><tr><td align="center">十一月</td><td align="center">novembre</td></tr><tr><td align="center">十二月</td><td align="center">décembre</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 法语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[法语]语法笔记-Notes grammaticales</title>
      <link href="/2022/07/04/fran%C3%A7ais/"/>
      <url>/2022/07/04/fran%C3%A7ais/</url>
      
        <content type="html"><![CDATA[<h1 id="Les-Articles-冠词"><a href="#Les-Articles-冠词" class="headerlink" title="Les Articles 冠词"></a>Les Articles 冠词</h1><p><img src="/2022/07/04/fran%C3%A7ais/img.png" alt="Tableau des le articles"><br><strong>Note</strong>: <strong>l’</strong> est utilisé spécifiquement avant lès mots qui commencent par une voyelle ou un <strong>h factice</strong>.<br><strong>注意</strong>：<strong>l’</strong>专用在以元音字母或<strong>哑音h</strong>开头的单词前。</p><ul><li><p>Les <strong>articles définis</strong> désignent les noms qu’ils qualifient ou qui ont été mentionnés ci - dessus, tandis que les <strong>articles indéfinis</strong> désignent les noms qu’ils qualifient comme génériques.<br><strong>定冠词</strong>表示它所限定的名词是确指的或是上文中已提及过的，而<strong>不定冠词</strong>则表示其所限定的名词是泛指的。</p></li><li><p>Example:</p></li></ul><ol><li>Il y a <strong>un ordinateur</strong> sur la table. 桌上有一台电脑。<br><strong>L’ordinateur</strong> est à moi. 这台电脑是我的。</li><li>Il a acheté <strong>une voiture</strong>. 他买了一辆汽车。<br><strong>La voiture</strong> est rouge. 这辆汽车是红色的。</li><li>Ce sont <strong>des étudiants</strong>. 这是一群大学生。<br><strong>Les étudiants</strong> sont jeunes. 这群大学生很年轻。</li></ol><ul><li><p>Bien que l’utilisation d’articles indéfinis et d’articles définis soit définie par des références générales et précises, dans certaines expressions, leur utilisation va bien au - delà de ces dispositions.<br>尽管不定冠词和定冠词的使用是以泛指与确指为界定的，但在有些表达中，它们的用法远远地超越了这样的规定。</p></li><li><p>Example：</p></li></ul><ol><li>Il n’aime pas <strong>le soleil</strong>. 他不喜欢太阳。(众所周知的，唯一的)</li><li><strong>Le vélo</strong> est pratique. 自行车很方便。(指“自行车”这一类交通工具)</li><li><strong>L’homme</strong> est mortel. 人难免一死.(指所有人)</li></ol><ul><li><p>Dans certaines phrases spécifiques, les phrases qui n’utilisaient pas d’articles à l’origine ont été ajoutées avec des articles indéfinis pour exprimer des significations rhétoriques supplémentaires.<br>在某些特定的词组中，为了表达附加上的修辞意义，原先并不使用冠词的，反而要加上不定冠词。</p></li><li><p>Example:</p></li></ul><ol><li>La petite a <strong>une grande</strong> peur. 小女孩非常害怕。</li><li>Le garçon a <strong>une</strong> soif <strong>incroyable</strong>. 小男孩口干舌燥。</li><li>Nous avons <strong>une</strong> faim <strong>énorme</strong>. 我们饥渴难耐。</li></ol><ul><li><p>Dans l’utilisation quotidienne, l’article indéfini et l’article défini ne sont jamais opposés, ils sont souvent entrelacés pour exprimer la subordination entre les choses, la relation plus limitée ou d’autres relations logiques implicites.<br>而在日常的使用中，不定冠词和定冠词绝不是对立的，它们往往交织在一起，表达事物与事物之间的从属关系，更进一步的限定关系或是其他暗含的逻辑关系。</p></li><li><p>Example:</p></li></ul><ol><li>un manuel <strong>de</strong> français. 一本法语教材</li><li>le manuel de français  <strong>de</strong> ma sœur. 我姐姐的法语教材</li><li>Je veux <strong>une</strong> orange. 我想要一只橙子。</li><li>Je veux <strong>l’</strong> orange qui est là. 我想要放在那儿的橙子。</li></ol><ul><li><p>Omettre les articles avant les noms dirigés par des adverbes spécifiques ou des phrases représentant des quantités.<br>在一些由特定副词或表示数量的词组引导的名词前，省去冠词。</p></li><li><p>Example:</p></li></ul><ol><li>Nous avons <strong>beaucoup de</strong> vacances. 我们的假期很多。</li><li>Elle achète <strong>peu de</strong> cahiers. 她买了很少的本子。</li><li>Tu as <strong>trop de</strong> questions. 你的问题太多了。</li><li>Il a <strong>assez d’</strong> argent. 他有足够的钱。</li><li>L’enfant a<strong>un peu de</strong> monnaie. 这个孩子有一点儿钱。</li><li>J’achète <strong>deux bouteilles de</strong> vin. 我买了两瓶葡萄酒。</li></ol><ul><li><p><strong>Article condensé</strong>: désigne une nouvelle forme formée par la combinaison de la préposition à ou de et de l’article défini, qui est dérivée et différente de l’article défini.<br><strong>缩合冠词</strong>：是指介词à或de分别和定冠词组合之后形成的一种新形式，可谓是出之于定冠词，又与之有别。<br><img src="/2022/07/04/fran%C3%A7ais/img_1.png" alt="article condensé"></p></li><li><p>Example:</p></li></ul><ol><li>Elle va <strong>au</strong> cinéma. 她去看电影。(aller à)</li><li>Nathalie est <strong>à la</strong> piscine. 娜塔莉在游泳池。(être à)</li><li>Nous avons besoin <strong>des</strong> manuelsde français. 我们需要法语教材。(avoir besoin de)</li><li>Les touristes ont peur <strong>de la</strong> tempête. 旅游者都害怕暴风雨。(avoir peur de)</li><li>Mon frère s’intéresse <strong>aux</strong> mathématiques. 我哥哥对数学感兴趣。(s’intéresser à)</li></ol><ul><li><p>En français, conditions d’utilisation de certains articles :<br>Tout d’abord, l’utilisation d’articles partiels doit être un nom incommensurable ;<br>Deuxièmement, les verbes qui guident ce nom incommensurable doivent être des verbes qui peuvent exprimer le sens d’une « utilisation partielle ».<br>法语中，部分冠词使用的条件：<br>首先，使用部分冠词的必须是不可数名词；<br>其次，引导这一不可数名词的动词必须是可以表达“部分使用”之意的动词。</p></li><li><p>Example:</p></li></ul><ol><li>J’aime <strong>le</strong> café. 我喜欢咖啡。</li><li>Je veux <strong>du</strong> café． 我想喝些咖啡。</li><li>J‘aimerais <strong>du</strong> café． 我想喝些咖啡。</li></ol><h1 id="L’imperatif-命令式"><a href="#L’imperatif-命令式" class="headerlink" title="L’impératif 命令式"></a>L’impératif 命令式</h1><p>L’impératif est une forme de langage. Il existe deux formes de temps: Le présent et le passé. Ce chapitre se concentre sur le présent impératif.<br>命令式是一种语式。它有两种时态形式：现在时和过去时。本章主要研究命令式的现在时。</p><ul><li>Lorsque nous avons besoin d’exprimer des attitudes subjectives telles que la commande &#x2F; interdiction &#x2F; demande &#x2F; encouragement, nous pouvons utiliser l’impératif.<br>当我们需要表达命令&#x2F;禁止&#x2F;请求&#x2F;鼓励等主观态度时，可以使用命令式：</li></ul><ol><li><strong>Parlez</strong> fort! 说大声一点！(命令)</li><li>Ne <strong>fumez</strong> pas! 请勿吸烟！(请求)</li><li><strong>Donne</strong>-moi de l’eau, s’il te plaît! 请给我些水！(请求)</li><li><strong>Sois</strong> courageux! 勇敢些！(鼓励)</li></ol><ul><li><p>Le présent impératif de chaque verbe n’a que trois formes de conjugaison, à savoir le singulier de deuxième personne, le pluriel de première personne et le pluriel de deuxième personne. En général, la conjugaison de l’impératif n’utilisent que l’expression présente directe du verbe, mais les pronoms personnels doivent être supprimés.<br>每一个动词的命令式现在时都只有三种变位形式，即第二人称单数，第一人称复数，第二人称复数。通常情况下，命令式的变位只用动词的直陈式现在时，但必须删去人称代词。</p></li><li><p>Example:</p></li></ul><ol><li><strong>Prends</strong> du café! 你喝些咖啡吧！ (第二人称单数)</li><li><strong>Allons</strong> au cinéma! 我们去看电影吧！(第一人称复数)</li><li><strong>Restez</strong> tranquille! 你们安静些！(第二人称复数)</li></ol><ul><li>Il y a cependant des exceptions pour le premier groupe de verbes et pour les verbes qui se terminent en partie par <em><strong>-ir</strong></em> (par exemple, ouvrir, offrir, cueillir, souffrir, couvrir). Les formes singulières de la deuxième personne de ces verbes se terminent maintenant par - es et doivent être supprimées lorsqu’elles sont converties en formes impératives.<br>不过，对于第一组动词以及部分以 <em><strong>-ir</strong></em> 结尾的动词（例如ouvrir，offrir，cueillir，souffrir，couvrir）来说，情况有些例外。这些动词的单数第二人称直陈式现在时变为都是以-es结尾的，再转换成命令式时，必须删去词尾的s：</li></ul><ol><li>parler 👉 tu parles 👉 <strong>Parle</strong> !</li><li>ouvrir 👉 tu ouvres 👉 <strong>Ouvre</strong> !</li><li>offrir 👉 tu offres 👉 <strong>Offre</strong> !</li></ol><ul><li>Toutefois, si le verbe ci - dessus est suivi d’un sous - pronom en ou y dans l’ordre, la lettre finale s est conservée en raison de la prononciation.<br>但如果上述这些动词在命令式中后接副代词en或y的话，由于发音关系，词尾字母s则要继续保留：</li></ul><ol><li>tu y entres 👉 <strong>Entres-y</strong>!</li><li>tu en manges 👉 <strong>Manges-en</strong>!</li><li>tu em offres 👉 <strong>Offres-en</strong>!</li></ol><ul><li>Bien que le verbe aller ne fasse pas partie du premier groupe de verbes, mais se référer également aux règles correspondantes du premier groupe de verbes dans l’impératif<br>虽然动词aller不属于第一组动词，但也参照第一组动词在命令式中的相应规则：</li></ul><ol><li>tu vas 👉 <strong>Va</strong>!</li><li>tu y vas 👉 <strong>Vas-y</strong>!</li></ol><ul><li><p>Conjugaison de spécial à mémoriser.<br>需特殊记忆的变位形式:<br><img src="/2022/07/04/fran%C3%A7ais/img_2.png" alt="Conjugaison spécial"></p></li><li><p>Dans la pratique, il arrive que le négatif impératif prend la forme de non - finitions. La négation impérative ajoute également ne…pas après le verbe. Pas, c’est - à - dire que la négation impérative commence toujours par ne.<br>在实际使用中，有时命令式是以否定式的形式出现的。命令式否定式也是在动词的前后加上ne…pas，也就是说，命令式否定式总是以ne开头的：</p></li></ul><ol><li>Ne sors pas! 你别出去！</li><li>N’y va pas! 你别去那儿！</li><li>N’ayez pas peur! 您别怕！</li><li>Ne vendons pas notre appartement! 我们别卖房子！</li></ol><ul><li>Pour éviter la répétition, nous devons parfois utiliser des pronoms personnels.<br>Si vous avez besoin d’exprimer des commandes à une troisième personne, vous devez utiliser le virtuel。<br>为了避免重复，有时在命令式中我们需要使用一些人称代词。<br>如果需要对第三人称表达命令的话，我们需要使用虚拟式：</li></ul><ol><li>Qu’il parle! 让他说！(第三人称单数)</li><li>Qu’elles fassent vite leurs devoirs! 让她们快点做作业！(第三人称复数)</li></ol><ul><li>Express present &#x2F; simple future &#x2F; infinitive peut exprimer des commandes.<br>直陈式现在时&#x2F;简单将来时&#x2F;不定式都可以表达命令：</li></ul><ol><li>Vous finissez tout d’abord vos devoirs. 你们首先先做完作业。(直陈式现在时)</li><li>Tu achèteras du pain, s’il te plaît! 请你买些面包！(直陈式简单将来时)</li><li>Couper le jambon en morceaux. 把火腿切成小块。(动词不定式)</li></ol><h1 id="Les-verbes-pronominaux-代动词"><a href="#Les-verbes-pronominaux-代动词" class="headerlink" title="Les verbes pronominaux 代动词"></a>Les verbes pronominaux 代动词</h1><p>Les verbes pronominaux sont des verbes avec des pronoms personnels réflexifs, qui sont une sorte de verbes spéciaux.<br>代动词是指有自反人称代词的动词，是一类特殊的动词。<br>La conjugaison des verbes pronominaux implique deux parties, l’une est la modification de la partie réflexive du pronom personnel, l’autre est la conjugaison de la partie du verbe, les deux doivent faire des changements correspondants en fonction de la personne du sujet.<br>代动词的动词变位牵涉到两部分内容，一是自反人称代词部分的变化，二是动词部分的变位，两者都必须根据主语人称作出相应的变化。</p><ul><li><p>Dans l’infinitif du pronom, nous utilisons se pour exprimer le pronom personnel réflexif, tandis que dans la transposition concrète du verbe, nous changeons en fonction de la personne du sujet de différents sexes.<br>在代动词的不定式中，我们用se来表示自反人称代词，而在具体的动词变位中则根据不同性数的主语人称进行变化，即：<br><img src="/2022/07/04/fran%C3%A7ais/img_3.png" alt="conjugaison de pronomiaux"></p></li><li><p>Cependant, lorsque le verbe contemporain apparaît directement dans la phrase sous forme d’infinitif, le pronom réflexif se doit également correspondre aux différents sexes de la personne du sujet, tandis que la partie du verbe reste inchangée.<br>不过，当代动词以不定式的形式直接出现在句子中时，自反人称代词se也必须和主语人称进行性数配合，而动词部分则保持不变。</p></li><li><p>Example:</p></li></ul><ol><li>Je vais <strong>me reposer</strong>. 我马上要休息了。</li><li>Vous allez <strong>vous coucher</strong>. 你们马上要睡觉了。</li><li>Ils vont <strong>se lever</strong>. 他们马上要起床了。</li></ol><ul><li><p>Nous considérons toujours les pronoms personnels réflexifs et les verbes comme un tout. Par conséquent, dans la phrase négative, il est nécessaire de placer ne devant le pronom personnel réflexif et pas derrière le verbe.<br>我们始终将代动词中的自反人称代词和动词看成一个整体。因此，在否定句中，需要吧ne放在自反人称代词的前面，pas放在动词的后面。</p></li><li><p>Example:<br>Je me couche. 👉 Je <strong>ne</strong> me couche <strong>pas</strong>.</p></li><li><p>De même, dans la question de l’inversion du sujet et du prédicat, le pronom personnel réflexif est placé devant le verbe, c’est - à - dire que nous considérons le pronom personnel réflexif comme faisant partie du verbe, puis nous effectuons l’inversion du sujet et du prédicat sur cette base.<br>同样，在主谓倒置式的疑问句中，自反人称代词放在动词的前面，也就是说，我们将自反人称代词视为动词的一部分，然后再在此基础上进行主谓倒置。</p></li><li><p>Example:<br>Tu te laves. 你洗澡。 👉 Te laves-tu? 你洗澡吗？</p></li><li><p>Derrière le verbe, et le pronom personnel de la deuxième personne singulière te doit être réécrit dans sa forme de relecture toi. Dans la forme de l’ordre de négation, le pronom personnel réflexif est toujours placé devant le verbe, et il n’y a pas de changement de forme.<br>而在肯定命令式中，自反人称代词放在动词后面，单数第二人称的人称代词te则要改写成它的重读形式toi。再否定命令形式中，自反人称代词仍放在动词的前面，且没有任何形式上的变化。</p></li><li><p>Example:</p></li></ul><ol><li>Lève-<strong>toi</strong>! 你起床！</li><li>Ne <strong>te</strong> lève pas! 你别起床！</li></ol><ul><li>Les pronoms eux - mêmes peuvent être divisés en quatre catégories.<br>代动词本身又可以分为四类。</li></ul><ol><li>Les <strong>sens réflexif</strong> verbes pronominaux indique que l’action est appliquée à l’acteur lui - même, c’est - à - dire au sens réflexif du sujet. À ce stade, le pronom personnel réflexif dans le pronom peut être l’objet direct du verbe ou l’objet indirect du verbe.<br><strong>自反意义</strong>代动词表示动作施加于施动者本身，也就是自反于主语的意思。这时，代动词中的自反人称代词可以是动词的直接宾语，也可以是动词的间接宾语。</li></ol><ul><li>Example:<br>Je <strong>me</strong> couche. 我睡觉。(me为直接宾语)<br>Il <strong>se</strong> brosse les dents. 他刷牙。(se时间接宾语，le dents为动词brosser的直接宾语)<br>判断自反意义代动词中的直接宾语或间接宾语的关键是看动词后面有没有宾语，如果有，这个宾语就是直接宾语，自反人称代词则为间接宾语；倘若没有，自反人称代词则为直接宾语。</li></ul><ol start="2"><li>Les <strong>sens mutuel</strong> verbes pronominaux indique que l’action se produit entre les sujets. Nous pouvons donc juger que le sujet du verbe pronom de sens mutuel est pluriel, ou que le pronom personnel est le pronom on qui représente le concept pluriel. De même, les pronoms personnels réflexifs dans les pronoms de sens mutuel peuvent être soit des objets directs, soit des objets indirects.<br><strong>相互意义</strong>代动词表示动作发生在主语之间。我们由此可以判断出，相互意义代动词的主语复数的，或者是表示复数概念的人称代词on。同样，相互意义代动词中的自反人称代词既可以是直接宾语，也可以是间接宾语。</li></ol><ul><li>Example:<br>Vous <strong>vous</strong> regardez. 你们四目相对。(vous为直接宾语)<br>Ils <strong>s</strong>‘écrivent. 他们相互写信。(se是间接宾语)<br>判断相互意义代动词中的直接宾语或间接宾语的关键是看动词本身亦不敢改后接直接宾语还是间接宾语。在以上的两个例句中，动词regarder的搭配是regarder quelqu‘un，因此，剧中的vous为直接宾语。而动词écrire à  quelqu’un,所以，句子中的se为间接宾语。</li></ul><ol start="3"><li>Les <strong>sens passif</strong> verbes pronominaux indique que l’action est passive, ce qui équivaut à la voix passive.<br><strong>被动意义</strong>代动词表示动作是被动的，相当于被动语态。</li></ol><ul><li>Example:<br>La fenêtre <strong>se</strong> ferme. 窗关上了。</li></ul><ol start="4"><li>Les <strong>sens absolu</strong> verbes pronominaux personnels réflexifs dans les pronoms sont inhérents aux pronoms et n’expriment aucun sens grammatical.<br><strong>绝对意义</strong>代动词中的自反人称代词是代动词所固有的，不表达任何语法上的意义。</li></ol><ul><li>Example:<br>Il <strong>s</strong>‘en va. 他走了。</li></ul><h1 id="Le-passe-compose-直陈式复合过去时"><a href="#Le-passe-compose-直陈式复合过去时" class="headerlink" title="Le passé composé 直陈式复合过去时"></a>Le passé composé 直陈式复合过去时</h1><p>Le passé composé indique les actions qui se sont produites et qui ont été accomplies au cours d’une période définie dans le passé.<br>复合过去时表示过去起止时间明确的某一段时间内发生并完成的动作。<br>Composition : la forme expressive du verbe auxiliaire avoir ou celui - ci est maintenant + le participant passé du verbe.<br>构成：助动词avoir或être的直陈式现在时+动词的过去分词。</p><ul><li><p>La formation du participant passé<br>过去分词的构成：<br>(1). 第一组动词去掉词尾的-er加上-é:<br> regarder 👉 regardé<br>(2). 第二组动词去掉词尾的-ir加上-i:<br> finir 👉 fini<br>(3). 常用的不规则动词的过去分词<br></p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">avoir 👉 eu</td><td align="center">vouloir 👉 voulu</td><td align="center">voir 👉 vu</td></tr><tr><td align="center">être 👉 été</td><td align="center">prendre 👉 pris</td><td align="center">pouvoir 👉 pu</td></tr><tr><td align="center">faire 👉 fait</td><td align="center">boire 👉 bu</td><td align="center">pleuvoir 👉 plu</td></tr><tr><td align="center">dire 👉 dit</td><td align="center">lire 👉 lu</td><td align="center">recevoir 👉 reçu</td></tr><tr><td align="center">devoir 👉 dû</td><td align="center">tenir 👉 tenu</td><td align="center">offrir 👉 offert</td></tr><tr><td align="center">savoir 👉 su</td><td align="center">connaître 👉 connu</td><td align="center">ouvrir 👉 ouvert</td></tr></tbody></table></li><li><p>Verbes avec avoir comme auxiliaire.<br>以avoir为助动词的动词：<br>La plupart des verbes utilisent avoir comme auxiliaire.<br>大部分动词都使用avoir作为助动词。</p></li><li><p>Verbes avec être comme auxiliaire.<br>以être为助动词的动词：<br>(1). Verbe transitionnel représentant un déplacement de position ou un changement d’état.<br>表示位置移动或状态变化的及物动词：<br>aller, venir, entrer, sortir, monter, descendre, arriver, partir, passer, rester, tomber, mourir, naître, apparaître(包括他们的派生词：devenir, revenir, rentrer…)<br><strong>Note</strong>: certains de ces verbes peuvent également être utilisés comme verbes transitifs, suivis d’objets directs, et maintenant utiliser avoir comme verbes auxiliaires.<br><strong>注意</strong>：这些动词中有些也可以作及物动词，后跟直接宾语，此时用avoir作助动词：</p></li><li><p>Example:<br>Je suis montré en haut de la tour Eiffel. 我登上埃菲尔铁塔的高处。<br>Le garçon de l’hôtel amontre les valises dans la chambre. 旅馆的男侍将行李送到了房间。<br>Béatrice est passée chaz moi à 8 h. 贝亚特莉丝八点来过我家。<br>On a passé toute la matinée à l’hôpital. 我们在医院度过了整整一个上午。</p><p>(2). Tous les pronoms.所有的代动词：</p></li></ul><p>se laver, s’assoir, se souvenir…</p><ul><li>Example:<br><img src="/2022/07/04/fran%C3%A7ais/img_4.png" alt="examples de les verbes pronominaux"></li></ul><p><strong>Note</strong><br><strong>注意</strong>：</p><ul><li>La phrase négative est placée des deux côtés du verbe auxiliaire dans la phrase négative.<br>否定句中否定短语置于助动词两边：<br>Elle <strong>n’a pas réussi</strong> ses examens. 她没有顺利通过考试。<br>Je <strong>ne suis pas allé</strong> à l’université hier. 昨天我没有去上大学。<br>Je <strong>ne me suis pas réveillé</strong> à 7 heures ce matin. 今天早晨7点钟我还没有睡醒。</li><li>Verbes auxiliaires et inversion du sujet dans les phrases interrogatives.<br>疑问句中助动词与主语倒装：<br>As-tu trouvé test clés ? 你找到钥匙了吗？<br>À quelle heure êtes-vous arrivé ? 您几点钟到的？<br>Quand s’est-elle couchée ? 她什么时候上床休息的？</li></ul><h1 id="Pronoms-personnels-complements-d’objet-indirect-简介宾语人称代词"><a href="#Pronoms-personnels-complements-d’objet-indirect-简介宾语人称代词" class="headerlink" title="Pronoms personnels compléments d’objet indirect -, 简介宾语人称代词"></a>Pronoms personnels compléments d’objet indirect -, 简介宾语人称代词</h1><ol><li>间接宾语人称代词的形式<table><thead><tr><th align="center">人称</th><th align="center">单数形式</th><th align="center">复数形式</th></tr></thead><tbody><tr><td align="center">第一人称</td><td align="center">me(m‘)</td><td align="center">nous</td></tr><tr><td align="center">第二人称</td><td align="center">te(t’)</td><td align="center">vous</td></tr><tr><td align="center">第三人称</td><td align="center">lui</td><td align="center">leur</td></tr></tbody></table></li><li>主要用法<br>间接宾语热诚代词一般用来代替介词à及其引导的指人的间接宾语，一般置于相关<strong>动词之前</strong>。</li></ol><ul><li>Example:</li></ul><ol><li>Paul <strong>nous</strong> donne ses livres. (nous &#x3D; à nous) 保罗把他的书给了我们。 </li><li>Est-ce que tu peux <strong>m’</strong> apporter du thé, s’il te plaît? (m’ &#x3D; à moi) 你能给我带点茶来吗？</li></ol><p>注意：间接宾语人称代词不可以用来代替带此时动词的间接宾语，以及penser à等短语中的间接宾语：在以上情况中，须使用à+重读人称代词作为间接宾语。</p><ol><li>Li Ming a recentré des problèmes, donc il s’adresse à moi.</li><li><ul><li>À qui penses-tu? À tes parents ? 你在香水？你的父母吗？</li></ul></li></ol><ul><li>Oui, je pense à eux. 是的，我在想念他们。</li></ul><ol start="3"><li>命令式肯定句中的间接宾语人称代词<br>在<strong>命令式肯定句</strong>中，间接宾语人称代词置于<strong>动词之后</strong>，并使用连字符-引导；<strong>如果间接宾语人称代词为me或te，则应使用重读形式moi或toi</strong>。</li></ol><ul><li>Example:</li></ul><ol><li>Envoyez-lui cette le titre ! 把这封信寄给他.</li><li>Passe-moi le journal ! 把报纸递给我！</li></ol><h1 id="C’est…qui-x2F-C’est…que-强调句型"><a href="#C’est…qui-x2F-C’est…que-强调句型" class="headerlink" title="C’est…qui &#x2F; C’est…que - 强调句型"></a>C’est…qui &#x2F; C’est…que - 强调句型</h1><p>当需要突出强调句子中的某一成分时，可采用强调句型c’est…qui或c’est…que，以唤起对方的注意；需要注意的是，该句型不可强调谓语。</p><ol><li>强调主语用<strong>c’est…qui</strong>，句中动词需要与主语进行配合；在口语表达中，c‘est可以代替ce sont.</li></ol><ul><li>Example:<br>1）Olivia a donné des renseignements à Li Ming. 奥维莉雅给黎明提供了信息。<br>👉 <strong>C’est</strong> Olivia <strong>qui</strong> a donné des renseignements à Li Ming.<br>是奥维莉雅给李明提供了信息。<br>2）J’ai besoin d’ouvrir un compte bancaire. 我需要开一个银行账户。<br>👉 <strong>C’est</strong> moi <strong>qui</strong> ai besoin d’ouvrir un compte bancaire.<br>是我需要开银行账户。<br>3）Ces chemises me plaisent beaucoup. 我喜欢这些衬衣。<br>👉 <strong>Ce sont</strong> ces chemises <strong>qui</strong> me plaisent beaucoup.<br>我喜欢的正是这些衬衣。<br>注意：主语人称代词在C’est…qui结构中，应变为重读人称代词形式。</li></ul><ol start="2"><li>强调直接宾语、间接宾语、状语、表语用<strong>c’est…que</strong>。</li></ol><ul><li>Example:<br>1）Nous avons rencontré un célèbre médecin hier. 我们昨天遇见了一个著名的医生。<br>👉 <strong>C’est</strong> un célèbre médecin <strong>que</strong> nous avons rencontré hier.<br>我们昨天遇见的是一个著名的医生。<br>2）Elles sont partis en vacances avec leurs copines. 他们跟朋友出发去度假了。<br>👉 <strong>C’est</strong> avec leurs copines <strong>qu</strong>‘elles sont partis en vacances.<br>他们是跟朋友们出发去度假的。<br>3）Nous ne sommes pas venus, parce qu’il a plu.<br>我们没来，因为下雨了。<br>👉 <strong>C’est</strong> parce qu’il a plu <strong>que</strong> nous ne sommes pas venus.<br>是因为下雨了我们才没有来。<br>4）Pour ouvrir un compte bancaire, Li Ming s’adresse à Olivia. 为了开银行账户，李明求助于奥莉薇娅。<br>👉 Pour ouvrir un compte bancaire, <strong>C’est</strong> à Olivia <strong>que</strong> Li Ming s’adresse.<br>为了开银行账户，李明是奥莉薇娅求助的。</li></ul><h1 id="Pronoms-personnels-comportement-d’objet-direct-直接宾语人称代词"><a href="#Pronoms-personnels-comportement-d’objet-direct-直接宾语人称代词" class="headerlink" title="Pronoms personnels comportement d’objet direct - 直接宾语人称代词"></a>Pronoms personnels comportement d’objet direct - 直接宾语人称代词</h1><ol><li>直接宾语人称代词的形式<table><thead><tr><th align="center">人称</th><th align="center">单数形式</th><th align="center">复数形式</th></tr></thead><tbody><tr><td align="center">第一人称</td><td align="center">me(m‘)</td><td align="center">nous</td></tr><tr><td align="center">第二人称</td><td align="center">te(t’)</td><td align="center">vous</td></tr><tr><td align="center">第三人称</td><td align="center">le&#x2F;la(l’)</td><td align="center">les</td></tr></tbody></table></li><li>主要用法<br>直接宾语人称代词一般用来代替指人或事物的直接宾语。与间接宾语人称代词相同，直接宾语人称代词一般置于相关<strong>动词之前</strong>。</li></ol><ul><li>Example:<br>1）Je <strong>vous</strong> aime. 我爱你们。<br>2）Quelles belles fleurs! Je vais <strong>les</strong> donner à maman. 多美的花！我要把他们送给妈妈。<br>3）Hier, il <strong>m</strong>‘a rencontré dans la rue. 昨天，他在街上碰见了我。</li></ul><ol start="3"><li>命令式在肯定句中的直接宾语人称代词<br>在<strong>命令式肯定句</strong>中，直接宾语人称代词置于<strong>动词之后</strong>，并使用连字符“-”引导；<strong>如果直接宾语人称代词为me或te，则应使用其重读形式moi或toi</strong>。</li></ol><ul><li>Example:<br>1）Regarde-moi! 看着我！<br>2）Suivez-la! 跟着她！</li></ul><h1 id="imparfait-未完成过去时"><a href="#imparfait-未完成过去时" class="headerlink" title="imparfait 未完成过去时"></a>imparfait 未完成过去时</h1><ol><li>构成<br>动词直陈式现在时第一人称复数形式去掉此为-ons，再按人称je，tu，il&#x2F;elle，nous，vous，ils&#x2F;elles顺序加：-ais, -ais, -ait, -ions, -iez, -aient</li></ol><ul><li>Example:<br><img src="/2022/07/04/fran%C3%A7ais/img_5.png" alt="exmaples"><br>注意：1）être的未完成过去时为特殊形式<table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">j’étais</td><td align="center">nous étions</td></tr><tr><td align="center">tu étais</td><td align="center">vous étiez</td></tr><tr><td align="center">il&#x2F;elle était</td><td align="center">ils&#x2F;elles étaient</td></tr><tr><td align="center">2）下列动词未完成过去时的变化。</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center">:—–:</td><td align="center">:—–:</td></tr><tr><td align="center">commencer</td><td align="center">je commençais</td></tr><tr><td align="center">manger</td><td align="center">je mangeais</td></tr><tr><td align="center">étudier</td><td align="center">j’étudiais</td></tr></tbody></table></li></ul><ol start="2"><li>用法<br>1）表示过去的状态，描写过去事件的背景。<br>a. Hier, il faisait froid. Le ciel était gris. Il y avait peu de monde dans la rue.<br>昨天，天气很冷，天空阴沉，街上几乎没有人。<br>b. Avant, il habitait en ville.<br>以前，他住在城里。<br>2） 表示在过去一段时间里，习惯或重复性的动作。<br>a. Pendant les vacances, il se levait toujours à 8 heures du matin.<br>在假期中，他总是早上 8 点起床。<br>b. Avant, sa soeur travaillait à Paris. Il allait la voir deux fois par mois.<br>过去，他的姐姐在巴黎工作，他每月去看她两次。<br>c. Il sortait souvent avec ses copains quand il était au lycée.<br>他上高中时，经常与同伴出去玩。<br>3） 在复合句中，与复合过去时配合使用。未完成过去时表示在过去时间中持续进行的动作，而复合<br>过去时表示过去一次性发生并完成的动作。<br>a. Il est arrivé pendant que j’écoutais de la musique.<br>在我听音乐的时候，他来了。<br>b. Il pleuvait quand je me suis réveillé.<br>当我醒来的时候，正在下雨。</li></ol><h1 id="Accord-du-participe-passe-dans-le-temps-compose-复合时态中过去分词的配合1-以-avoir-为助动词的复合时态中，过去分词的配合"><a href="#Accord-du-participe-passe-dans-le-temps-compose-复合时态中过去分词的配合1-以-avoir-为助动词的复合时态中，过去分词的配合" class="headerlink" title="Accord du participe passé dans le temps composé 复合时态中过去分词的配合1. 以 avoir 为助动词的复合时态中，过去分词的配合"></a>Accord du participe passé dans le temps composé 复合时态中过去分词的配合1. 以 avoir 为助动词的复合时态中，过去分词的配合</h1><p>在以 avoir 为助动词的复合时态中，过去分词通常不变；但是当直接宾语位于 avoir 之前时，过去分词需要与前置的直接宾语进行性数配合。<br>1） Combien de livres as-tu lus ? 你读了几本书？<br>2） C’est la leçon 5 que nous avons apprise hier. 我们昨天学的是第五课。<br>3） Ces formulaires, je les ai déjà remplis. 这些表格，我已经填了。<br>2. 以 être 为助动词的复合时态中，过去分词的配合<br>   在以 être 为助动词的复合时态中，过去分词通常须与主语进行性数配合；但当代词式动词中的自反代词 se 是动词的间接宾语时，过去分词保持不变。<br>1） Elle s’est lavée en 20 minutes. 她洗澡用了 20 分钟。<br>   Elle s’est lavé les mains avant le repas. 她饭前洗了手。<br>2） Elles se sont rencontrés dans la rue, mais elles ne se sont pas dit bonjour.<br>   她们在街上相遇了，但没有打招呼。<br>3. 表示位置移动的动词，过去分词的配合有些表示位移的动词既可使用 avoir 做助动词，又可使用être 做助动词。当动词有直接宾语时，需要使用 avoir 做助动词，此时过去分词不与主语配合；当动词没有直接宾语时，需要使用être 做助动词，此时过去分词与主语配合。<br>1） Elle est montée au deuxième étage. 她上了三楼。<br>2） Elle a monté une chaise au deuxième étage. 她把一把椅子搬到了三楼。<br>3） Elle est sortie de bonne heure. 她一大早就出去了。<br>4） Elle a sorti les vêtements de bonne heure. 她一大早就把衣服拿出来了。</p>]]></content>
      
      
      <categories>
          
          <category> 法语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网络攻防先导实践]1.简单的DLL注入实践-干爆扫雷</title>
      <link href="/2022/07/01/NAD-DLL/"/>
      <url>/2022/07/01/NAD-DLL/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：DLL注入技术与网络安全"><a href="#相关叨叨：DLL注入技术与网络安全" class="headerlink" title="相关叨叨：DLL注入技术与网络安全"></a>相关叨叨：DLL注入技术与网络安全</h1><p>对于网络安全的课题，攻与防是同等地位的重要，可攻可受（？）是每一个学习网络安全的<del>冤种</del>技术人所应同时具备的能力。<br>而DLL注入技术，一般来讲是向一个正在运行的进程插入&#x2F;注入代码的过程，可以被正常软件用来添加&#x2F;扩展其他程序，调试或逆向工程的功能性；该技术也常被恶意软件以多种方式利用。这意味着从安全角度来说，了解DLL注入的工作原理是十分必要的。<br><img src="https://pic1.zhimg.com/80/v2-e7797fe6b55556041e4fc1154691b584_720w.jpg" alt="DLL注入原理与流程（图源网）"></p><h2 id="实验目标与内容"><a href="#实验目标与内容" class="headerlink" title="实验目标与内容"></a>实验目标与内容</h2><p>利用DLL注入，实现扫雷一件通关辅助：</p><ol><li>找到地雷数组所在内存位置；</li><li>数组中的各个值代表的含义；</li><li>实现辅助</li></ol><p>实验拟题来自于 <strong>中国海洋大学 网络攻防先导实践 lab03：简单的DLL注入实践</strong> <em>-by 曲海鹏 等</em></p><h1 id="实验依赖工具"><a href="#实验依赖工具" class="headerlink" title="实验依赖工具"></a>实验依赖工具</h1><h2 id="Windows-消息传递机制"><a href="#Windows-消息传递机制" class="headerlink" title="Windows 消息传递机制"></a>Windows 消息传递机制</h2><p>所谓的Windows消息传递机制就类似于生活中的物流公司。当寄件人（例如鼠标、键盘）将包裹（消息）交给物流公司（Windows系统）时，物流公司（Windows系统）会进行整理并且派发（整理及派发主要由消息循环完成），交给相应的快递员（窗口过程）来处理。快递员（窗口过程）拿到包裹（消息）后则有多种方式来处理，如立马交给收件人，等一天交给收件人，或转交给其他快递派发，这就需要在窗口过程中用switch&#x2F;case来区分。<br><img src="/2022/07/01/NAD-DLL/img.png" alt="Windows消息传递机制示意"><br><img src="/2022/07/01/NAD-DLL/img_1.png" alt="WIndows消息传递的回调与响应函数"><br>对于通过DLL进行的消息劫持与注入，则需要利用Windows消息传递机制来完成，下述为Windows消息事件的介绍及获取&#x2F;模拟：</p><h3 id="Windows消息来源相关知识部分应用"><a href="#Windows消息来源相关知识部分应用" class="headerlink" title="Windows消息来源相关知识部分应用"></a>Windows消息来源相关知识部分应用</h3><p>消息可以由系统或者应用程序产生。系统在发生输入事件时产生消息。举个例子, 当用户敲键, 移动鼠标或者单击控件。系统也产生消息以响应由应用程序带来的变化, 比如应用程序改变系统字体，改变窗体大小。应用程序可以产生消息使窗体执行任务，或者与其他应用程序中的窗口通讯。</p><ol><li><p>Windows中，消息使用统一的结构体（MSG）来存放信息，其中message表明消息的具体的类型，<br><br>而wParam，lParam是其最灵活的两个变量，为不同的消息类型时，存放数据的含义也不一样。<br>time表示产生消息的时间，pt表示产生消息时鼠标的位置。<br>Windows中消息MSG声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMsg</span><br><span class="line">&#123;</span><br><span class="line">HWND hwnd; // 接受该消息的窗口句柄，告诉操作系统，应该把消息发生给哪个应用 哪个窗口</span><br><span class="line">UINT message; // 消息常量标识符，也就是我们通常所说的消息号</span><br><span class="line">WPARAM wParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">LPARAM lParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">DWORD time; // 消息创建时的时间</span><br><span class="line">POINT pt; // 消息创建时的鼠标/光标在屏幕坐标系中的位置</span><br><span class="line">&#125;MSG;</span><br></pre></td></tr></table></figure></li><li><p>消息类型<br><img src="/2022/07/01/NAD-DLL/img_2.png" alt="消息类型"><br>(1) 窗口消息：即与窗口的内部运作有关的消息，如创建窗口，绘制窗口，销毁窗口等。<br>可以是一般的窗口，也可以是MainFrame,Dialog,控件等。<br>如：WM_CREATE, WM_PAINT, WM_MOUSEMOVE, WM_CTLCOLOR, WM_HSCROLL等.<br><br>(2) 当用户从菜单选中一个命令项目、按下一个快捷键或者点击工具栏上的一个按钮，都将发送WM_COMMAND命令消息。<br>LOWORD(wParam)表示菜单项，工具栏按钮或控件的ID；如果是控件, HIWORD(wParam)表示控件消息类型。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOWORD(l) ((WORD)(l))</span><br><span class="line">#define HIWORD(l) ((WORD)(((DWORD)(l) &gt;&gt; 16) &amp; 0xFFFF))</span><br></pre></td></tr></table></figure><p>(3) 随着控件的种类越来越多，越来越复杂（如列表控件、树控件等），仅仅将wParam，lParam将视为一个32位无符号整数，已经装不下太多信息了。<br>为了给父窗口发送更多的信息，微软定义了一个新的WM_NOTIFY消息来扩展WM_COMMAND消息。<br>WM_NOTIFY消息仍然使用MSG消息结构，只是此时wParam为控件ID，lParam为一个NMHDR指针，<br>不同的控件可以按照规则对NMHDR进行扩充，因此WM_NOTIFY消息传送的信息量可以相当的大。<br>注：Window 9x 版及以后的新控件通告消息不再通过WM_COMMAND 传送，而是通过WM_NOTIFY 传送，<br>但是老控件的通告消息， 比如CBN_SELCHANGE 还是通过WM_COMMAND 消息发送。<br><br>(4) windwos也允许程序员定义自己的消息，使用SendMessage或PostMessage来发送消息。<br></p></li><li><p>消息队列(Message Queues)<br>Windows中有两种类型的消息队列<br>(1) 系统消息队列(System Message Queue)<br>这是一个系统唯一的Queue，设备驱动(mouse, keyboard)会把操作输入转化成消息存在系统队列中，然后系统会把此消息放到目标窗口所在的线程的消息队列(thread-specific message queue)中等待处理.<br><br>(2) 线程消息队列(Thread-specific Message Queue)<br>每一个GUI线程都会维护这样一个线程消息队列。(这个队列只有在线程调用GDI函数时才会创建，默认不创建)。然后线程消息队列中的消息会被送到相应的窗口过程(WndProc)处理.<br>注意： 线程消息队列中WM_PAINT，WM_TIMER只有在Queue中没有其他消息的时候才会被处理，WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。<br></p></li><li><p>队列消息(Queued Messages)和非队列消息(Non-Queued Messages)<br>(1) 队列消息(Queued Messages)<br>消息会先保存在消息队列中，消息循环会从此队列中取出消息并分发到各窗口处理<br>如：WM_PAINT，WM_TIMER，WM_CREATE，WM_QUIT，以及鼠标，键盘消息等。<br>其中，WM_PAINT，WM_TIMER只有在队列中没有其他消息的时候才会被处理， WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。<br><br>(2) 非队列消息(NonQueued Messages)<br>消息会绕过系统消息队列和线程消息队列直接发送到窗口过程被处理 如： WM_ACTIVATE, WM_SETFOCUS, WM_SETCURSOR， WM_WINDOWPOSCHANGED<br>注意: postMessage发送的消息是队列消息，它会把消息Post到消息队列中； SendMessage发送的消息是非队列消息， 被直接送到窗口过程处理.<br></p></li><li><p>窗体函数（WindowProc）<br><img src="/2022/07/01/NAD-DLL/img_3.png" alt="应用程序消息循环（messager loop）"><br>Windows 应用程序创建的每个窗口都在系统核心注册一个相应的窗口函数，窗口函数程序代码形式上是一个巨大的switch 语句，用以处理由消息循环发送到该窗口的消息，窗口函数由Windows 采用消息驱动的形式直接调用，而不是由应用程序显示调用的，窗口函数处理完消息后又将控制权返回给Windows。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//而窗体负责响应消息的函数称为“窗体过程（Window Procedure）”，窗体过程是一个函数，每个窗体一个，它大致拥有以下的“模样”（C++代码）：</span><br><span class="line">LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line"> &#123;</span><br><span class="line">     //……</span><br><span class="line">     switch (uMsg) //依据消息标识符进行分类处理</span><br><span class="line">     &#123;</span><br><span class="line">     case WM_CREATE:</span><br><span class="line">         // 初始化窗体.</span><br><span class="line">         return 0;</span><br><span class="line">     case WM_PAINT:</span><br><span class="line">         // 绘制窗体</span><br><span class="line">         return 0;</span><br><span class="line">         //</span><br><span class="line">         //处理其他消息</span><br><span class="line">         //</span><br><span class="line">     default:</span><br><span class="line">         //如果窗体没有定义处理此种消息的代码，则转去调用系统默认的消息处理函数</span><br><span class="line">         return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> //可以看到，“窗体过程”不过就是一个多分支语句罢了，在这个语句中，窗体对不同类型的消息进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>以上内容来自<a href="https://blog.51cto.com/u_15080034/4353635"><strong>(整理)window 消息传递机制</strong></a><br><del>事实上，上述内容我也看的懵懂，大概当个了解</del></p><h2 id="Spy"><a href="#Spy" class="headerlink" title="Spy++"></a>Spy++</h2><p>Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。<br><img src="/2022/07/01/NAD-DLL/img_4.png" alt="介个就是spyxx.exe"><br><img src="https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/exp/w=500/sign=7ba3254179cb0a4685228b395b62f63e/64380cd7912397ddd6145fbf5b82b2b7d0a28718.jpg" alt="spyxx界面"></p><p>后续在本实验的应用上，我拿这个用来在创建模拟点击事件时的定位窗口坐标。</p><h2 id="Cheat-Engine"><a href="#Cheat-Engine" class="headerlink" title="Cheat Engine"></a>Cheat Engine</h2><p>Cheat Engine是一款专注于游戏的修改器。它可以用来扫描游戏中的内存，并允许修改它们。它还附带了调试器、反汇编器、汇编器、变速器、作弊器生成、Direct3D操作工具、系统检查工具等。<br><img src="/2022/07/01/NAD-DLL/img_5.png" alt="这个是Cheat Engine"><br><img src="/2022/07/01/NAD-DLL/img_6.png" alt="CE界面"></p><p>针对游戏的修改器&#x2F;辅助器&#x2F;或你叫它什么都好，总之要想达到作弊的效果，最重要的当然是要分析破译游戏内存数据所代表的含义，并能精准定位所要实现修改的内存存放地址，因此在后续的操作中，Cheat Engine扮演了十分重要的角色。</p><h2 id="Xenos"><a href="#Xenos" class="headerlink" title="Xenos"></a>Xenos</h2><p>《Xenos》是2007年池泽辰也执导的悬疑片，由海东键、一戸奈美、堀田ゆい夏等主演。<br><img src="/2022/07/01/NAD-DLL/img_7.png" alt="Xenos"><br><font size="3">…当然，不可能是这个”Xenos”</font></p><p>我们所要介绍的Xenos，是用来进行DLL注入的软件，长这样：<br><img src="/2022/07/01/NAD-DLL/img_8.png" alt="这个才是注入器Xenos"><br><img src="/2022/07/01/NAD-DLL/img_9.png" alt="Xenos界面"></p><p>这个工具，则是帮助我们将写好的DLL类型文件对程序进行注入。</p><p>以上，则是本次实验&#x2F;本类型任务的基本搭建环境和操作工具，接下来正式进入对本实验的分析与实践。</p><h1 id="实验分析：让俺看看扫雷背后都有啥"><a href="#实验分析：让俺看看扫雷背后都有啥" class="headerlink" title="实验分析：让俺看看扫雷背后都有啥"></a>实验分析：让俺看看扫雷背后都有啥</h1><p>摆烂了将近一个月终于开始继续</p><h2 id="WinMine-XP-exe-游戏规则分析"><a href="#WinMine-XP-exe-游戏规则分析" class="headerlink" title="WinMine_XP.exe 游戏规则分析"></a>WinMine_XP.exe 游戏规则分析</h2><p><img src="/2022/07/01/NAD-DLL/img_10.png" alt="扫雷游戏界面"></p><ol><li>坐上叫雷数（剩余旗🚩数）显示；</li><li>右上角计时器显示：初始点击雷区按钮触发计时，点击充值按钮触发计时器重置；</li><li>雷区按钮：</li></ol><ul><li>左击：① 显示该按钮下内容：数字（1、2…）：以该按钮坐标周围3*3个单位坐标按钮下存在雷的个数；② 雷（被引爆，游戏结束）；</li><li>右击：① 单机：插旗🚩（当且仅当在所有雷都进行插旗排雷后通关），占用旗数；② 双击：问好，不占用旗数，用于个人怀疑记录；</li></ul><ol start="4"><li>game设置选项：<br><img src="/2022/07/01/NAD-DLL/img_11.png" alt="Game设置界面"><br>可设置棋盘规格大小；其中Custom选项可进行自定义，且Height&lt;&#x3D;24，Width&lt;&#x3D;30.<br><strong>注：在开始扫雷时左击的第一个按钮，即使是雷也会由程序自动将该地址的雷转移到其他地址，保证玩家不会上来就挂.</strong></li></ol><h2 id="实现思路分析"><a href="#实现思路分析" class="headerlink" title="实现思路分析"></a>实现思路分析</h2><p>获取棋盘雷区数据存储地址，通过模拟点击事件对雷区所有按钮进行遍历点击，其中对内存存储数值含义为雷的进行模拟右击插旗，其他进行左击排查；通过计时器存储数值判断棋盘数据是否重置。</p><p>通过Spy++获取WinMine_XP.exe窗口句柄：<br><img src="/2022/07/01/NAD-DLL/img_12.png" alt="句柄"><br>其中<br>IpClassName: Minesweeper<br>IpWindowsName: Minesweeper</p><h2 id="通过Cheat-Engine获取窗口WinMine-XP-exe窗口内存数据，并查找到棋盘内存点进行数据分析："><a href="#通过Cheat-Engine获取窗口WinMine-XP-exe窗口内存数据，并查找到棋盘内存点进行数据分析：" class="headerlink" title="通过Cheat Engine获取窗口WinMine_XP.exe窗口内存数据，并查找到棋盘内存点进行数据分析："></a>通过Cheat Engine获取窗口WinMine_XP.exe窗口内存数据，并查找到棋盘内存点进行数据分析：</h2><p><img src="/2022/07/01/NAD-DLL/img_13.png"><br>分析棋盘数据（以9*9棋盘为例）</p><ul><li>棋盘规格数据：<br>· 宽度数据存储地址：Width&#x3D;0x0100553;<br>· 长度数据存储地址：Height&#x3D;0x0100553;<br><img src="/2022/07/01/NAD-DLL/img_15.png"></li><li>雷区起始点地址：0x01005361;</li><li>计时器数据存储地址：0x0100579C;</li><li>地雷布局的内存位置：0x0100534;<br><img src="/2022/07/01/NAD-DLL/img_14.png"></li><li>雷区按钮数据：<br> · 10：棋盘边界；<br> · 0F：无雷且未点击；<br> · 8F：有雷且未点击；<br> · 0E：无雷插旗；<br> · 8E：有雷插旗；<br> · CC：点击引爆；</li></ul><h2 id="通过spy-获取雷区按钮坐标相关信息"><a href="#通过spy-获取雷区按钮坐标相关信息" class="headerlink" title="通过spy++获取雷区按钮坐标相关信息"></a>通过spy++获取雷区按钮坐标相关信息</h2><p><img src="/2022/07/01/NAD-DLL/img_16.png"><br>按钮坐标（1，1）中心对应串钩坐标约为（20，63），且相邻两个按钮之间的窗口坐标差值约为16个单位长度。</p><h1 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    PBYTE t = (PBYTE)<span class="number">0x0100579C</span>;</span><br><span class="line">    <span class="comment">//char szChar[20];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对不同窗口信息传送进行对应操作指令</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//输入任意字符实现一键通关</span></span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*t == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//内存地址</span></span><br><span class="line">            PBYTE m = (PBYTE)<span class="number">0x01005361</span>;</span><br><span class="line">            PBYTE w = (PBYTE)<span class="number">0x01005334</span>;</span><br><span class="line">            PBYTE h = (PBYTE)<span class="number">0x01005338</span>;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">20</span>, y = <span class="number">63</span>, n = <span class="number">1</span>, q = <span class="number">1</span>;  <span class="comment">//坐标</span></span><br><span class="line">            <span class="comment">//雷区按钮遍历</span></span><br><span class="line">            <span class="keyword">while</span> (x &lt;= <span class="number">20</span> + *w * <span class="number">16</span> &amp;&amp; y &lt;= <span class="number">63</span> + (*h - <span class="number">1</span>) * <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt; *h)</span><br><span class="line">                    y = <span class="number">63</span>;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; *w)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = <span class="number">20</span>;</span><br><span class="line">                    y += <span class="number">16</span>;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                    m += <span class="number">32</span> - *w;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (*m != <span class="number">143</span>)  <span class="comment">//非雷则左击</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//雷则右击</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_RBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_RBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//完成该按钮操作后移动至下一按钮坐标处</span></span><br><span class="line">                x += <span class="number">16</span>;</span><br><span class="line">                n++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">            y = <span class="number">63</span>;</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>((WNDPROC)OPROC, hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数据地址定义：<br> · PBYTE t: 计时器数据存储地址；<br> · PBYTE m: 雷区按钮起始点地址；<br> · PBYTE w: 雷区宽度数据存储地址；<br> · PBYTE h: 雷区长度数据存储地址；</li><li>坐标定义：<br> · x,y: 窗口坐标；<br> · n,q: 按钮坐标；</li><li>Switch(uMsg): 对不同窗口信息传送进行对应操作指令（在此选择通过从键盘输入任意字符实现一键通关指令）</li><li>while(x &lt;&#x3D; 20 + w * 16 &amp;&amp; y &lt;&#x3D; 63 + (*h - 1) * 16): 对雷区按钮进行遍历；<br> · if 此按钮坐标（n,q）下数据m!&#x3D;143（8F）时，对该按钮坐标（x，y）模拟鼠标左击事件；<br> · else 对该按钮窗口坐标（x,y）模拟鼠标右击事件<br> · 完成该按钮操作后进行坐标移动</li><li>*t&#x3D;&#x3D;0时（棋盘重置）重复上述操作；</li></ol><p><strong>笔记：</strong></p><ul><li><strong>同列相邻行间地址差推算：address+32-width；</strong> </li><li><strong>棋盘重置可通过 * p的值作为条件，棋盘重置后需要将地址指针及坐标悉数重置；</strong></li><li><strong>若本次布雷，在（1，1）即为雷时，由于程序对内存数据的访问限制会使第一次的模拟点击跳过，需在遍历后补充一次对（1，1）按钮的左击。</strong></li></ul><h2 id="注入函数"><a href="#注入函数" class="headerlink" title="注入函数"></a>注入函数</h2><p>void injected()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">injected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">nullptr</span>, <span class="string">&quot;injected&quot;</span>, <span class="string">&quot;title&quot;</span>, MB_OK);</span><br><span class="line">    HWND OW = <span class="built_in">FindWindowA</span>(<span class="string">&quot;Minesweeper&quot;</span>, <span class="string">&quot;Minesweeper&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!OW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(<span class="literal">nullptr</span>, <span class="string">&quot;find window failed&quot;</span>, <span class="string">&quot;Failed&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OPROC = <span class="built_in">SetWindowLong</span>(OW, GWL_WNDPROC, (LONG)WindowProc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入口点函数"><a href="#入口点函数" class="headerlink" title="入口点函数"></a>入口点函数</h2><p>BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">injected</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><h2 id="注入测试"><a href="#注入测试" class="headerlink" title="注入测试"></a>注入测试</h2><p>通过Xenos注入：<br><img src="/2022/07/01/NAD-DLL/img_17.png"><br>接收到注入函数中设定的注入成功的MessageBox;</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=686304538&bvid=BV1SU4y1e733&cid=783764201&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><ol><li>模拟鼠标点击事件：<br>SendMessage()函数；<br>参考：<a href="https://wenku.baidu.com/view/b71d76a1ef3a87c24028915f804d2b160b4e8665.html"><strong>如何使用Sendmessage模拟某一按钮的点击事件</strong> - <em>百度文库</em></a></li><li>由于扫雷程序对第一次左击不触雷的设定，致使在测试中出现第一个按钮未被执行点击的情况：在遍历后补充对第一个按钮的无差别点击。</li></ol><h1 id="篇末BB"><a href="#篇末BB" class="headerlink" title="篇末BB"></a>篇末BB</h1><p>事实上这个外挂辅助的实现有许多不同中的思路，我不能确保自己选择的是最巧妙的但是我所唯一能操作实现的。<br>在大量辅助工具的帮助下对目标程序的内存分析十分简单且便捷。<br>个人认为本次实验的困难包括但不限于对内存数据的分析与利用，虽然能<del>照本宣科地</del>使用Spy++&#x2F;CE&#x2F;Xenos等，但我并未能利用好PeiD工具，或许因为人错过了更为便捷的信息获取与分析途径。<br>总而言之，虽然“独立”完成了扫雷外挂的编程实现是极具满足感的，但或以更多的是在对辅助工具的认识与使用上，于是更期待之后能够更熟练运用这些工具，做出更可拷&#x2F;可刑的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLL </tag>
            
            <tag> 外挂 </tag>
            
            <tag> 钩子 </tag>
            
            <tag> 回调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[人工智能先导实践]1.n-Queens的多种算法题解</title>
      <link href="/2022/06/26/AI-nQueens/"/>
      <url>/2022/06/26/AI-nQueens/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：8皇后问题与n皇后问题"><a href="#相关叨叨：8皇后问题与n皇后问题" class="headerlink" title="相关叨叨：8皇后问题与n皇后问题"></a>相关叨叨：8皇后问题与n皇后问题</h1><p>八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。<br>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<br>下图是八皇后问题的一个解，可以用向量表示为：[f, d, g, a, h, b, e, c]，分别表示每行的皇后位置（列号）。<br><img src="https://i.postimg.cc/PJnPNvxZ/image.png" alt="八皇后问题的一个解"></p><p>实验拟题来自于 <strong>中国海洋大学 人工智能先导实践 lab03：比特匠心&amp;模拟退火</strong> <em>-by 徐建良</em></p><h1 id="n-queens多种解题方法思路"><a href="#n-queens多种解题方法思路" class="headerlink" title="n-queens多种解题方法思路"></a>n-queens多种解题方法思路</h1><h2 id="回溯与8皇后"><a href="#回溯与8皇后" class="headerlink" title="回溯与8皇后"></a>回溯与8皇后</h2><p>“回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。“<br>就是说，回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。<br>而对于解决八皇后问题，以深度优先的回溯法作为最基础的思路，有如下应用：<br>step1. 尝试先放置第一枚皇后，被涂黑的地方是不能放皇后<br><img src="https://pic3.zhimg.com/80/v2-bde25f03b5a86cc6ca47ee03fd171c9e_720w.jpg"><br>step2. 第二行的皇后只能放在第三格或第四格，比方我们放第三格，则：<br><img src="https://pic2.zhimg.com/80/v2-40654679a56af2cd9282b9ae60d4c641_720w.jpg"><br>step3. 可以看到再难以放下第三个皇后，此时我们就要用到回溯算法了。我们把第二个皇后更改位置，此时我们能放下第三枚皇后了。<br><img src="https://pic1.zhimg.com/80/v2-b810b81e8843c11e30e62277ddde1b4c_720w.jpg"><br>step4. 虽然是能放置第三个皇后，但是第四个皇后又无路可走了。返回上层调用（3号皇后），而3号也别无可去，继续回溯上层调用（2号），2号已然无路可去，继续回溯上层（1号），于是1号皇后改变位置如下，继续回溯。<br><img src="https://pic2.zhimg.com/80/v2-a22c5c4152b4b8b488555be294837f39_720w.jpg"><br>以上内容引自 <a href="https://zhuanlan.zhihu.com/p/54275352"><strong>小白带你学—回溯算法（Back Tracking)</strong> <em>-知乎 @小白算法</em></a></p><p>下面我们就建立在这一最基础的算法思路上，运用不同的进阶算法解决N阶皇后问题，且不断优化。</p><h2 id="利用哈希表降维进行初探"><a href="#利用哈希表降维进行初探" class="headerlink" title="利用哈希表降维进行初探"></a>利用哈希表降维进行初探</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>这个题解仅仅是建立在对该问题的探索与思考上，并无“创新”抑或“优化”可言，基于最暴力且朴素的降维思路，不断尝试从中找出规律、再考虑优化。</p><h3 id="二维哈希表"><a href="#二维哈希表" class="headerlink" title="二维哈希表"></a>二维哈希表</h3><p>· 实现过程：</p><ol><li>建立二维数组，将棋盘布局通过数组模拟占位信息。其中另外通过开辟数组分别存储列冲突、左斜冲突、和右斜冲突的信息。</li><li>设置回溯函数，统计该行下空余且不冲突可放置皇后的位置；<br>-&gt;更新并计算位置占用情况；<br>-&gt;若有空余位置，则从右起对每一位置依次进行回溯试探；<br>-&gt;进入下一行的试探，深度优先搜索正确解，只要遇到无空位可放置，则逐层向上回溯，至存在空位的行；<br>-&gt;依次对该行存在的可放置空位进行遍历试探，并对试探失败的空位进行排除；<br>-&gt;记录可行解的个数。</li><li>回溯函数部分代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span>** hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; hash[rowp][i] == <span class="number">0</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>** temp = <span class="keyword">new</span> <span class="type">int</span>* [n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">temp[i][j] = hash[rowp + i + <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i])</span><br><span class="line">&#123;</span><br><span class="line">hash[rowp][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;down &lt; n;down++, l--, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= <span class="number">0</span>)</span><br><span class="line">hash[down][l] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n)</span><br><span class="line">hash[down][r] = <span class="number">0</span>;</span><br><span class="line">hash[down][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>][h] = temp[m][h];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>· 小结<br>对于n-queens问题探索可行解过程，若n取值较小时较为迅速，且内存情况还算勉强，但对于8皇后、16皇后、甚至100皇后问题的求解，会占用大量内存，不仅执行过程极其缓慢，且容易导致触发程序断点、或是溢出问题。因而引出如下逐渐降维的实现过程。</li></ol><h3 id="一维哈希表"><a href="#一维哈希表" class="headerlink" title="一维哈希表"></a>一维哈希表</h3><p>· 实现：</p><ol><li>为了减少内存压力，通过将二进制数的位运算与数组进行结合，用n个二进制数记录行中可放置位置，并将之存放在一维数组中；</li><li>思路与上大致相同，不再赘述。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span>* hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = hash[rowp] &amp; -hash[rowp];</span><br><span class="line"><span class="type">int</span> position = <span class="built_in">log</span>(p) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*int position = p == 1 ? 0 : pow(p, 0.5);*/</span></span><br><span class="line">hash[rowp] -= p;</span><br><span class="line"><span class="type">int</span>* temp = <span class="keyword">new</span> <span class="type">int</span>[n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">temp[i] = hash[rowp + i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">1</span>;down &lt; n;down++, l++, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n - position)</span><br><span class="line">left = left + p &lt;&lt; l;</span><br><span class="line"><span class="keyword">if</span> (r &lt;= position)</span><br><span class="line">right = right + p &gt;&gt; r;</span><br><span class="line">hash[down] = hash[down] &amp; ~(left | right | p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; rowp &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; bitset&lt;6&gt;(hash[i]) &lt;&lt; endl;*/</span></span><br><span class="line"><span class="built_in">dfs1</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>] = temp[m];</span><br><span class="line"><span class="keyword">delete</span>[]temp;</span><br><span class="line">&#125; <span class="keyword">while</span> (hash[rowp]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>· 小结：<br>相较起二维数组，效率仅仅提高了一点点，内存占用情况仍不够美观，遂考虑压缩至0维哈希，即仅使用一个二进制数来存储全部占位信息并进行回溯。</li></ol><h2 id="位运算解法（0维哈希表）"><a href="#位运算解法（0维哈希表）" class="headerlink" title="位运算解法（0维哈希表）"></a>位运算解法（0维哈希表）</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算与位运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;   <span class="comment">//60 = 0011 1100</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;   <span class="comment">//13 = 0000 1101</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a &amp; b;             <span class="comment">//12 = 0000 1100 按位与</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 1 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a | b;             <span class="comment">//61 = 0011 1101 按位或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 2 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a ^ b;             <span class="comment">//49 = 0011 0001 异或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 3 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = ~a;                <span class="comment">//-61 = 1100 0011 按位取反</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 4 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;            <span class="comment">//240 = 1111 0000 位左移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 5 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;            <span class="comment">//15 = 0000 1111 位右移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 6 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="n-queens与位运算"><a href="#n-queens与位运算" class="headerlink" title="n-queens与位运算"></a>n-queens与位运算</h3><ol><li>思路说明（以8皇后为例）<br>首先，我们的基本思路与传统一样，每一行只能放并且必须放一个皇后。每次放置一个皇后之后，它就会对后面所有行中，可能放置皇后的位置产生影响。如下图所示，我们已经放置了三个皇后 Q1，Q2，Q3。 接着在下面一行放置 Q4 时，用彩色标注出的区域都是不可行的方案，会与已经放置的三个皇后产生冲突。<br><img src="https://i.postimg.cc/2jKVq5cV/image.png" alt="表达有无冲突的二进制数图解（本图来源于网络）">这个冲突其实有三种不同的情况，我们用三个变量 A，B，C 分别表示这三种不同的冲突。这三个变量都是一个八位的二进制数，这八位中，为 1 的表示有冲突，为 0 则表示没有冲突。<br>(1)与已放置的皇后处于同一列中：<br>我们用 A 表示这种冲突。例如在图中，第四行会有三个位置因为列攻击而不能再放置皇后（图中大红色方块），因此 A &#x3D; 1000 1001。<br>(2)与已放置的皇后处于同一左斜(指向右下方)对角线中：<br>我们用 B 表示这种冲突。例如在图中，蓝色方块所表示的位置，分别是由于Q1和Q2的左斜对角线上的攻击而不能够放置新的皇后， 因此B &#x3D; 0001 0010。<br>(3)与已放置的皇后处于同一右斜(指向右上方)对角线中：<br>我们用 C 表示这种冲突。例如图中粉色方块，是由 Q2 的右斜对角线的攻击造成的。因此 C &#x3D; 0010 0000。<br>有了 A，B，C 三个变量，我们很容易求出当前行(第 4 行)中，有哪些位置是可以放置皇后的。这个变量我们用 D 来表示，我们可以写出 D &#x3D; ~(A|B|C)。D中为 1 的那些位置则是我们可以放置皇后的位置。上图中，D &#x3D; 0100 0100。<br>此时，我们有两个可能的放置皇后的位置，那么如何取出每个可能的位置呢？<br>这里有一个技巧。我们用 bit 表示可能的一个位置，使用 bit &#x3D; D &amp; (-D) 即可取出 D 中最右边的 1（LSB，Least Significant Bit）。例如 D &#x3D; 0100 0100，则-D &#x3D; 10111100（注意计算机中的数都是补码，-D &#x3D; ~D + 1）。而bit &#x3D; D &amp; (-D) &#x3D; 0000 0100 取出了最右边的那个 1，代表在第 4 行第 6 列放置一个皇后。那么在此基础上，如何确定第 5 行的 A、B、C 的值呢？其实也很简单，对于表示列冲突的变量 A 来说，只要使用 A|bit 即可表示下一行的列冲突情况，对于 B，采用(B|bit)&lt;&lt;1，对于 C，采用(C|bit)&gt;&gt;1 即可表示下一行中，对角线冲突的情况。<br>  上述算法的思路来自于 <a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><strong>Backtracking Algorithms in MCPL using Bit Patterns and Recursion</strong> <em>-by Martin Richards</em></a> (这个链接好像并不很稳定的样子，可以挂个梯子去看)</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> hash,<span class="type">int</span> B,<span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//B左斜冲突</span></span><br><span class="line">    <span class="comment">//C右斜冲突</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//由于同列冲突的条件限定，且棋盘行数与列数相等</span></span><br><span class="line">    <span class="comment">//若想在每一列都放置皇后，则皇后不可能在同列，同时满足每一列都有皇后</span></span><br><span class="line">    <span class="comment">//因而可通过判断是否满足每一列都有皇后的条件来判断是否达成最终效果</span></span><br><span class="line"><span class="comment">//hash记录列冲突</span></span><br><span class="line"><span class="comment">//当hash==n，即所有每一列都放置了皇后时，结束本轮试探并计数</span></span><br><span class="line"><span class="keyword">if</span> (hash==n)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置回溯记忆点rememtemp</span></span><br><span class="line"><span class="comment">//若rememtemp==0时，即该行无位置可供放置，结束试探并开始回溯</span></span><br><span class="line"><span class="type">int</span> rememtemp = n &amp; ~(B | C | hash);  <span class="comment">//初始继承上一行中的放置情况</span></span><br><span class="line"><span class="keyword">while</span> (rememtemp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义A表示同列冲突，且其列位置会直接被继承到该行后的各行中</span></span><br><span class="line"><span class="type">int</span> A = rememtemp &amp; -rememtemp;     <span class="comment">//取当前行中最右一个可放置皇后的位置</span></span><br><span class="line">rememtemp -= A;       <span class="comment">//在记忆点中将A位置设置为0</span></span><br><span class="line"><span class="comment">//左斜冲突与右斜冲突在继承上一行的冲突情况同时，分别通过对该A位置的左移与右移进行对下一行冲突的更新</span></span><br><span class="line"><span class="comment">//对hash更新列冲突情况</span></span><br><span class="line"><span class="built_in">dfs0</span>(hash | A, (B | A) &lt;&lt; <span class="number">1</span>, (C | A) &gt;&gt; <span class="number">1</span>);      <span class="comment">//进入下一行</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果输出：<img src="https://i.postimg.cc/ZRmDxZwN/image.png" alt="6-queens"> <img src="https://i.postimg.cc/y89PQtgy/image.png" alt="10-queens"> <img src="https://i.postimg.cc/W1262n5M/image.png" alt="14-queens"> <img src="https://i.postimg.cc/d0f8jKwB/image.png" alt="16-queens"></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>利用位运算对n-queens问题可行解的数量进行统计，其延续了上述通过哈希表的思路，但代码更为简洁、运行速度更快、占用空间更小。唯一比较困难的是对于单一的二进制变量来储存整个棋盘的空位更新信息，在向下试探过程中容易忽略对当前行的“存档”，而在回溯过程中又容易忘记“读档”，而导致信息混乱。这个问题的解决则是在每次递归之前设置一个存档变量，将当前的数据存储之后再进行向下的试探，因而保证了在每一层的回溯过程中会自动读取上次所记录的数据。<br>下图是1-27阶问题的所有可行解：<br><img src="/2022/06/26/AI-nQueens/image.png" alt="1~27阶可行解"><br>对于该图中的分布状态的总结与思考，又引出了下文新的算法——多项式时间算法。</p><h2 id="N皇后的多项式时间算法"><a href="#N皇后的多项式时间算法" class="headerlink" title="N皇后的多项式时间算法"></a>N皇后的多项式时间算法</h2><h3 id="算法说明-1"><a href="#算法说明-1" class="headerlink" title="算法说明"></a>算法说明</h3><p>本算法来自于<a href="https://dl.acm.org/doi/pdf/10.1145/101340.101343"><strong>A Polynomial Time Algorithm for the N-Queens Problem</strong> <em>-by Rok Sosic &amp; Jun Gu</em></a> (这个链接好像并不很稳定的样子，可以挂个梯子去看) 在 1990 年首先提出。其灵感来源于对n阶可行解数量的考察，可以得出：可行解数量众多且均匀分布于整个状态空间 (棋盘上皇后的所有可能的 n!个排列)中。<br>思路简述：<br>通过一维数组将行数与该行对应皇后的列位置建立映射；<br>-&gt;随机打乱并保证每行皇后不在同一列；<br>-&gt;遍历判断皇后i或皇后j是否存在对角线冲突；<br> -&gt;若冲突，则试探交换两行皇后的位置；<br>  -&gt;判断交换后，全局冲突(评估值)是否减少，若减少则确定交换并使操作数自增记录，否则不交换且不记录；<br> -&gt;若都不冲突则不操作；<br>-&gt;遍历，知道操作数为0；<br>-&gt;判断调整后全局是否存在冲突，若存在则打乱重来（重启）；<br>-&gt;输出该解。</p><p>如下图是原论文中关于算法思路的说明(部分):<br><img src="/2022/06/26/AI-nQueens/image%20(2).png" alt="A Fast Algorithm for the N-Queens Problem "></p><p>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下（虽然感觉我写的怪怪的）:</p><ol><li><p>评估函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评估函数，计算当前棋盘下的冲突数，作为评估值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单个皇后局部对角线冲突计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个皇后局部对角线冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Attacked</span><span class="params">(<span class="type">int</span> *Board,<span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Att = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=row+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(Board[i] - Board[row]))</span><br><span class="line">Att++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Att&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Att;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>取解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heuristic</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> swaps_performed = <span class="number">0</span>;  <span class="comment">//设定计步器</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span>[n];      <span class="comment">//设定当前棋盘</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span>[n];         <span class="comment">//设定试探棋盘</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">swaps_performed = <span class="number">0</span>;     <span class="comment">//重计</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Attacked</span>(Current, i) || <span class="built_in">Attacked</span>(Current, j))   <span class="comment">//if queeni is attacked or queenj is attacked</span></span><br><span class="line">&#123;</span><br><span class="line">Next[i] = Current[j];</span><br><span class="line">Next[j] = Current[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Next) &lt; <span class="built_in">Conflicts</span>(Current))     <span class="comment">//if swap(queeni,queenj) reduces collisions </span></span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Next[i];</span><br><span class="line">Current[j] = Next[j];</span><br><span class="line">swaps_performed++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;*/</span></span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Next[i] = Current[i];</span><br><span class="line">Next[j] = Current[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Current))      <span class="comment">//检查是否获得解，若未获得解则打乱重来</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Current[i];</span><br><span class="line">Current[i] = Current[j];</span><br><span class="line">Current[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">swaps_performed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (swaps_performed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = Current[i];</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多项式时间测试主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polyn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;         </span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">Heuristic</span>(Board);</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示(14皇后为例)：<br><img src="/2022/06/26/AI-nQueens/img.png" alt="14queens"></p></li></ol><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>在编写过程中，感觉有些熟悉，有点随机重启爬山的味道，怀疑是不是自己并没有很好地利用好原作者的多项式时间算法思路）因为在实现过程中会出现自动跳出局域最优解（而可能并未达到全局最优），因而出现错误的结果，遂在完全照搬论文中伪代码的内容同时，增添了随机重启的部分，来确保最终结果为全局最优而非仅仅的局部最优。<br>我在这里的处理似乎并不是一个最合适的弥补策略，可以说并未很好地遵照多项式时间算法的巧妙设计。后续（或许很有可能不会）再返回来好好参悟一下算法来源的论文。<br>而面对上述提到的局部最优解的跳出，下文将会由此展示一个巧妙解决局部困死问题&#x2F;提高效率的算法。</p><h2 id="模拟退火算法在N皇后问题的运用"><a href="#模拟退火算法在N皇后问题的运用" class="headerlink" title="模拟退火算法在N皇后问题的运用"></a>模拟退火算法在N皇后问题的运用</h2><p>模拟退火很好地解决了局部困死地问题，因为它在运行过程中会对微小变动进行一定程度上的接受，即使这个微小变动所得到的最终解并不是我们想要的解，正是这种设定提高了执行效率。<br>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="算法说明-2"><a href="#算法说明-2" class="headerlink" title="算法说明"></a>算法说明</h3><p>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合一定的概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。<br>这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。将温度T当作控制参数，目标函数值f视为内能E，而固体在某温度T时的一个状态对应一个解[公式]，然后算法试图随着控制参数T的降低，使目标函数f(内能E)也逐渐降低，直至趋于全局最小值（退火中低温时的最低能量状态），就像金属退火过程一样。<br><img src="https://pic4.zhimg.com/80/v2-e1529b1b1577eecd16fb8a5418d51533_720w.jpg" alt="模拟退火流程图"><br>其中有几个需要注意的点：<br>· 初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。<br>· 在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。<br>· 当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</p><p>以上内容来自 <a href="https://zhuanlan.zhihu.com/p/266874840"><strong>模拟退火算法详解</strong> <em>-知乎 @智能算法</em></a> </p><p>思路简述：<br>通过一维数组将行数与该行对应皇后的列位置建立映射；<br>-&gt;设定初始温度且足够大，设定最小温度且一定小，设定退火速率；<br>-&gt;以行为单位遍历调整皇后位置，并计算调整前后的冲突值的差；<br>-&gt;若能量差小于0，则证明修改后的评估值耕地，在一定概率下接收评估值降低的修改，且使这个概率不知逐渐减小；否则直接接受调整；<br>-&gt;逐渐降温确保在未获得最优解时跳出局部最低温；<br>-&gt;直至调整到获得全局最低温结束；<br>-&gt;输出该解。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下：</p><ol><li><p>评估函数（与多项式时间算法的全局冲突数函数一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退火调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">proper</span><span class="params">(<span class="type">int</span>* Board, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> T = <span class="number">100.0</span>;    <span class="comment">//设定初始温度且足够大</span></span><br><span class="line"><span class="type">double</span> Tmin = <span class="number">1.0</span>;        <span class="comment">//设定最小温度且一定小</span></span><br><span class="line"><span class="type">double</span> Rate = <span class="number">0.8</span>;           <span class="comment">//退火速率</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span> [n];         <span class="comment">//记录当前棋盘放置情况</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span> [n];           <span class="comment">//记录修改后棋盘放置情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (T &gt; Tmin)        <span class="comment">//开始退火</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>;p &lt; n;p++)        <span class="comment">//遍历修改</span></span><br><span class="line">&#123;</span><br><span class="line">Next[row] = p;</span><br><span class="line"><span class="type">double</span> dE = <span class="built_in">Conflicts</span>(Next) - <span class="built_in">Conflicts</span>(Current);       <span class="comment">//计算能量差</span></span><br><span class="line"><span class="comment">//若能量差小于0，则证明修改后的评估值更低</span></span><br><span class="line"><span class="comment">//在一定概率下接受评估值降低的修改，且使这个概率值逐渐减小</span></span><br><span class="line"><span class="keyword">if</span> (dE &lt;= <span class="number">0</span> || (<span class="built_in">exp</span>((<span class="number">-1</span>) * dE / T) &gt; <span class="built_in">rand</span>() % <span class="number">100</span> * <span class="number">1.0</span> / <span class="number">10</span>))</span><br><span class="line">Current[row] = Next[row];</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Current[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">T *= Rate;         <span class="comment">//降温</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line">Board[row] = Current[row];</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"><span class="keyword">return</span> Board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟退火测试主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Simul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Conflicts</span>(Board))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == n)         <span class="comment">//重置</span></span><br><span class="line">row = <span class="number">0</span>;</span><br><span class="line">Board = <span class="built_in">proper</span>(Board, row++);         <span class="comment">//修改第row行皇后放置位置</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; row;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果：<br>与上无差，不做赘述。</p></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>经过对N皇后问题的不断深入探索（主要依赖于牛批前辈们的不同算法的提出），模拟退火用于寻找并输出n阶任一可行解，较好地解决了暴力遍历算法所导致的内存占用过大的问题&#x2F;耗时过长效率低的问题，同时解决了多项式算法局部困死的问题，对该问题的不同算法探索到此为止（事实上是因为实验布置的内容要求到此为止）。</p><h1 id="篇末BB"><a href="#篇末BB" class="headerlink" title="篇末BB"></a>篇末BB</h1><p>N-Queens&#x2F;N皇后&#x2F;无论怎么称呼的这一人工智能问题，属实经典，且解法众多，包括但远不限于如上所展示的 位运算&#x2F;多项式时间算法&#x2F;模拟退火算法 的经典算法，甚至如用爬山算法也将是很好的解题思路。对于人工智能，算法优化是其最关键的部分，面对庞大计算量，能否使程序语句更加精炼&#x2F;占用内存尽可能少&#x2F;运行速度更快，决定了你的人工是否足够智能。</p><p><del>（反正对于这一灵活度极高的问题上，我搜索且浏览了很多资料和文献才逐步探索出最优的算法，一圈子下来只是觉得自己是一人工智障）</del></p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 模拟退火 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello/Bonjour/你好</title>
      <link href="/2022/06/26/Hello/"/>
      <url>/2022/06/26/Hello/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><p><font size="4">This blog belongs to a student of Ocean University of China. It is used to record and share his undergraduate leaning experience and some interesting technology in computer science major.</font></p><h2 id="Bonjour"><a href="#Bonjour" class="headerlink" title="Bonjour!"></a>Bonjour!</h2><p><font size="4">Ce blog appartient à un étudiant de l’université Océanique de Chine. Il est utilisé pour documenter et partager son expérience  de premier cycle en informatique et centaines technique interessantes.</font></p><h2 id="你好哇！"><a href="#你好哇！" class="headerlink" title="你好哇！"></a>你好哇！</h2><p><font size="4">这个博客是一个中国海洋大学的学生创设的，用来记录和分享一些他本科期间在计算机专业的一些学习经验和有趣的技术。对了，他的网名常用“小二上馄饨”，他喜欢被叫做“馄饨”。</font></p><hr>]]></content>
      
      
      <categories>
          
          <category> 题外话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ME </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
