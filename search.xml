<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[法语学习笔记]冠词-Les articles</title>
      <link href="/2022/07/04/fran%C3%A7ais/"/>
      <url>/2022/07/04/fran%C3%A7ais/</url>
      
        <content type="html"><![CDATA[<h1 id="Les-Articles"><a href="#Les-Articles" class="headerlink" title="Les Articles"></a>Les Articles</h1><p><img src="/2022/07/04/fran%C3%A7ais/img.png" alt="Tableau des le articles"><br><strong>attention</strong>: <strong>l’</strong> est utilisé spécifiquement avant lès mots qui commencent par une voyelle ou un <strong>h factice</strong>.<br><strong>注意</strong>：<strong>l’</strong>专用在以元音字母或<strong>哑音h</strong>开头的单词前。</p><p>Les <strong>articles définis</strong> désignent les noms qu’ils qualifient ou qui ont été mentionnés ci - dessus, tandis que les <strong>articles indéfinis</strong> désignent les noms qu’ils qualifient comme génériques.<br><strong>定冠词</strong>表示它所限定的名词是确指的或是上文中已提及过的，而<strong>不定冠词</strong>则表示其所限定的名词是泛指的。</p><p>Example:</p><ol><li>Il y a <strong>un ordinateur</strong> sur la table. 桌上有一台电脑。<br><strong>L’ordinateur</strong> est à moi. 这台电脑是我的。</li><li>Il a acheté <strong>une voiture</strong>. 他买了一辆汽车。<br><strong>La voiture</strong> est rouge. 这辆汽车是红色的。</li><li>Ce sont <strong>des étudiants</strong>. 这是一群大学生。<br><strong>Les étudiants</strong> sont jeunes. 这群大学生很年轻。</li></ol><p>Bien que l’utilisation d’articles indéfinis et d’articles définis soit définie par des références générales et précises, dans certaines expressions, leur utilisation va bien au - delà de ces dispositions.<br>尽管不定冠词和定冠词的使用是以泛指与确指为界定的，但在有些表达中，它们的用法远远地超越了这样的规定。</p><p>Example：</p><ol><li>Il n’aime pas <strong>le soleil</strong>. 他不喜欢太阳。(众所周知的，唯一的)</li><li><strong>Le vélo</strong> est pratique. 自行车很方便。(指“自行车”这一类交通工具)</li><li><strong>L’homme</strong> est mortel. 人难免一死.(指所有人)</li></ol><p>Dans certaines phrases spécifiques, les phrases qui n’utilisaient pas d’articles à l’origine ont été ajoutées avec des articles indéfinis pour exprimer des significations rhétoriques supplémentaires.<br>在某些特定的词组中，为了表达附加上的修辞意义，原先并不使用冠词的，反而要加上不定冠词。</p><p>Example:</p><ol><li>La petite a <strong>une grande</strong> peur. 小女孩非常害怕。</li><li>Le garçon a <strong>une</strong> soif <strong>incroyable</strong>. 小男孩口干舌燥。</li><li>Nous avons <strong>une</strong> faim <strong>énorme</strong>. 我们饥渴难耐。</li></ol><p>Dans l’utilisation quotidienne, l’article indéfini et l’article défini ne sont jamais opposés, ils sont souvent entrelacés pour exprimer la subordination entre les choses, la relation plus limitée ou d’autres relations logiques implicites.<br>而在日常的使用中，不定冠词和定冠词绝不是对立的，它们往往交织在一起，表达事物与事物之间的从属关系，更进一步的限定关系或是其他暗含的逻辑关系。</p><p>Example:</p><ol><li>un manuel <strong>de</strong> français. 一本法语教材</li><li>le manuel de français  <strong>de</strong> ma sœur. 我姐姐的法语教材</li><li>Je veux <strong>une</strong> orange. 我想要一只橙子。</li><li>Je veux <strong>l’</strong> orange qui est là. 我想要放在那儿的橙子。</li></ol><p>Omettre les articles avant les noms dirigés par des adverbes spécifiques ou des phrases représentant des quantités.<br>在一些由特定副词或表示数量的词组引导的名词前，省去冠词。</p><p>Example:</p><ol><li>Nous avons <strong>beaucoup de</strong> vacances. 我们的假期很多。</li><li>Elle achète <strong>peu de</strong> cahiers. 她买了很少的本子。</li><li>Tu as <strong>trop de</strong> questions. 你的问题太多了。</li><li>Il a <strong>assez d’</strong> argent. 他有足够的钱。</li><li>L’enfant a<strong>un peu de</strong> monnaie. 这个孩子有一点儿钱。</li><li>J’achète <strong>deux bouteilles de</strong> vin. 我买了两瓶葡萄酒。</li></ol><p><strong>Article condensé</strong>: désigne une nouvelle forme formée par la combinaison de la préposition à ou de et de l’article défini, qui est dérivée et différente de l’article défini.<br><strong>缩合冠词</strong>：是指介词à或de分别和定冠词组合之后形成的一种新形式，可谓是出之于定冠词，又与之有别。<br><img src="/2022/07/04/fran%C3%A7ais/img_1.png" alt="article condensé"></p><p>Example:</p><ol><li>Elle va <strong>au</strong> cinéma. 她去看电影。(aller à)</li><li>Nathalie est <strong>à la</strong> piscine. 娜塔莉在游泳池。(être à)</li><li>Nous avons besoin <strong>des</strong> manuelsde français. 我们需要法语教材。(avoir besoin de)</li><li>Les touristes ont peur <strong>de la</strong> tempête. 旅游者都害怕暴风雨。(avoir peur de)</li><li>Mon frère s’intéresse <strong>aux</strong> mathématiques. 我哥哥对数学感兴趣。(s’intéresser à)</li></ol><p>En français, conditions d’utilisation de certains articles :<br>Tout d’abord, l’utilisation d’articles partiels doit être un nom incommensurable ;<br>Deuxièmement, les verbes qui guident ce nom incommensurable doivent être des verbes qui peuvent exprimer le sens d’une « utilisation partielle ».<br>法语中，部分冠词使用的条件：<br>首先，使用部分冠词的必须是不可数名词；<br>其次，引导这一不可数名词的动词必须是可以表达“部分使用”之意的动词。</p><p>Example:</p><ol><li>J’aime <strong>le</strong> café. 我喜欢咖啡。</li><li>Je veux <strong>du</strong> café． 我想喝些咖啡。</li><li>J‘aimerais <strong>du</strong> café． 我想喝些咖啡。</li></ol><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下次一定扒题下来</p>]]></content>
      
      
      <categories>
          
          <category> 法语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网络攻防先导实践]1.简单的DLL注入实践-干爆扫雷</title>
      <link href="/2022/07/01/NAD-DLL/"/>
      <url>/2022/07/01/NAD-DLL/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：DLL注入技术与网络安全"><a href="#相关叨叨：DLL注入技术与网络安全" class="headerlink" title="相关叨叨：DLL注入技术与网络安全"></a>相关叨叨：DLL注入技术与网络安全</h1><p>对于网络安全的课题，攻与防是同等地位的重要，可攻可受（？）是每一个学习网络安全的<del>冤种</del>技术人所应同时具备的能力。<br>而DLL注入技术，一般来讲是向一个正在运行的进程插入&#x2F;注入代码的过程，可以被正常软件用来添加&#x2F;扩展其他程序，调试或逆向工程的功能性；该技术也常被恶意软件以多种方式利用。这意味着从安全角度来说，了解DLL注入的工作原理是十分必要的。<br><img src="https://pic1.zhimg.com/80/v2-e7797fe6b55556041e4fc1154691b584_720w.jpg" alt="DLL注入原理与流程（图源网）"></p><h2 id="实验目标与内容"><a href="#实验目标与内容" class="headerlink" title="实验目标与内容"></a>实验目标与内容</h2><p>利用DLL注入，实现扫雷一件通关辅助：</p><ol><li>找到地雷数组所在内存位置；</li><li>数组中的各个值代表的含义；</li><li>实现辅助</li></ol><p>实验拟题来自于 <strong>中国海洋大学 网络攻防先导实践 lab03：简单的DLL注入实践</strong> <em>-by 曲海鹏 等</em></p><h1 id="实验依赖工具"><a href="#实验依赖工具" class="headerlink" title="实验依赖工具"></a>实验依赖工具</h1><h2 id="Windows-消息传递机制"><a href="#Windows-消息传递机制" class="headerlink" title="Windows 消息传递机制"></a>Windows 消息传递机制</h2><p>所谓的Windows消息传递机制就类似于生活中的物流公司。当寄件人（例如鼠标、键盘）将包裹（消息）交给物流公司（Windows系统）时，物流公司（Windows系统）会进行整理并且派发（整理及派发主要由消息循环完成），交给相应的快递员（窗口过程）来处理。快递员（窗口过程）拿到包裹（消息）后则有多种方式来处理，如立马交给收件人，等一天交给收件人，或转交给其他快递派发，这就需要在窗口过程中用switch&#x2F;case来区分。<br><img src="/2022/07/01/NAD-DLL/img.png" alt="Windows消息传递机制示意"><br><img src="/2022/07/01/NAD-DLL/img_1.png" alt="WIndows消息传递的回调与响应函数"><br>对于通过DLL进行的消息劫持与注入，则需要利用Windows消息传递机制来完成，下述为Windows消息事件的介绍及获取&#x2F;模拟：</p><h3 id="Windows消息来源相关知识部分应用"><a href="#Windows消息来源相关知识部分应用" class="headerlink" title="Windows消息来源相关知识部分应用"></a>Windows消息来源相关知识部分应用</h3><p>消息可以由系统或者应用程序产生。系统在发生输入事件时产生消息。举个例子, 当用户敲键, 移动鼠标或者单击控件。系统也产生消息以响应由应用程序带来的变化, 比如应用程序改变系统字体，改变窗体大小。应用程序可以产生消息使窗体执行任务，或者与其他应用程序中的窗口通讯。</p><ol><li><p>Windows中，消息使用统一的结构体（MSG）来存放信息，其中message表明消息的具体的类型，<br><br>而wParam，lParam是其最灵活的两个变量，为不同的消息类型时，存放数据的含义也不一样。<br>time表示产生消息的时间，pt表示产生消息时鼠标的位置。<br>Windows中消息MSG声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMsg</span><br><span class="line">&#123;</span><br><span class="line">HWND hwnd; // 接受该消息的窗口句柄，告诉操作系统，应该把消息发生给哪个应用 哪个窗口</span><br><span class="line">UINT message; // 消息常量标识符，也就是我们通常所说的消息号</span><br><span class="line">WPARAM wParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">LPARAM lParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">DWORD time; // 消息创建时的时间</span><br><span class="line">POINT pt; // 消息创建时的鼠标/光标在屏幕坐标系中的位置</span><br><span class="line">&#125;MSG;</span><br></pre></td></tr></table></figure></li><li><p>消息类型<br><img src="/2022/07/01/NAD-DLL/img_2.png" alt="消息类型"><br>(1) 窗口消息：即与窗口的内部运作有关的消息，如创建窗口，绘制窗口，销毁窗口等。<br>可以是一般的窗口，也可以是MainFrame,Dialog,控件等。<br>如：WM_CREATE, WM_PAINT, WM_MOUSEMOVE, WM_CTLCOLOR, WM_HSCROLL等.<br><br>(2) 当用户从菜单选中一个命令项目、按下一个快捷键或者点击工具栏上的一个按钮，都将发送WM_COMMAND命令消息。<br>LOWORD(wParam)表示菜单项，工具栏按钮或控件的ID；如果是控件, HIWORD(wParam)表示控件消息类型。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOWORD(l) ((WORD)(l))</span><br><span class="line">#define HIWORD(l) ((WORD)(((DWORD)(l) &gt;&gt; 16) &amp; 0xFFFF))</span><br></pre></td></tr></table></figure><p>(3) 随着控件的种类越来越多，越来越复杂（如列表控件、树控件等），仅仅将wParam，lParam将视为一个32位无符号整数，已经装不下太多信息了。<br>为了给父窗口发送更多的信息，微软定义了一个新的WM_NOTIFY消息来扩展WM_COMMAND消息。<br>WM_NOTIFY消息仍然使用MSG消息结构，只是此时wParam为控件ID，lParam为一个NMHDR指针，<br>不同的控件可以按照规则对NMHDR进行扩充，因此WM_NOTIFY消息传送的信息量可以相当的大。<br>注：Window 9x 版及以后的新控件通告消息不再通过WM_COMMAND 传送，而是通过WM_NOTIFY 传送，<br>但是老控件的通告消息， 比如CBN_SELCHANGE 还是通过WM_COMMAND 消息发送。<br><br>(4) windwos也允许程序员定义自己的消息，使用SendMessage或PostMessage来发送消息。<br></p></li><li><p>消息队列(Message Queues)<br>Windows中有两种类型的消息队列<br>(1) 系统消息队列(System Message Queue)<br>这是一个系统唯一的Queue，设备驱动(mouse, keyboard)会把操作输入转化成消息存在系统队列中，然后系统会把此消息放到目标窗口所在的线程的消息队列(thread-specific message queue)中等待处理.<br><br>(2) 线程消息队列(Thread-specific Message Queue)<br>每一个GUI线程都会维护这样一个线程消息队列。(这个队列只有在线程调用GDI函数时才会创建，默认不创建)。然后线程消息队列中的消息会被送到相应的窗口过程(WndProc)处理.<br>注意： 线程消息队列中WM_PAINT，WM_TIMER只有在Queue中没有其他消息的时候才会被处理，WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。<br></p></li><li><p>队列消息(Queued Messages)和非队列消息(Non-Queued Messages)<br>(1) 队列消息(Queued Messages)<br>消息会先保存在消息队列中，消息循环会从此队列中取出消息并分发到各窗口处理<br>如：WM_PAINT，WM_TIMER，WM_CREATE，WM_QUIT，以及鼠标，键盘消息等。<br>其中，WM_PAINT，WM_TIMER只有在队列中没有其他消息的时候才会被处理， WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。<br><br>(2) 非队列消息(NonQueued Messages)<br>消息会绕过系统消息队列和线程消息队列直接发送到窗口过程被处理 如： WM_ACTIVATE, WM_SETFOCUS, WM_SETCURSOR， WM_WINDOWPOSCHANGED<br>注意: postMessage发送的消息是队列消息，它会把消息Post到消息队列中； SendMessage发送的消息是非队列消息， 被直接送到窗口过程处理.<br></p></li><li><p>窗体函数（WindowProc）<br><img src="/2022/07/01/NAD-DLL/img_3.png" alt="应用程序消息循环（messager loop）"><br>Windows 应用程序创建的每个窗口都在系统核心注册一个相应的窗口函数，窗口函数程序代码形式上是一个巨大的switch 语句，用以处理由消息循环发送到该窗口的消息，窗口函数由Windows 采用消息驱动的形式直接调用，而不是由应用程序显示调用的，窗口函数处理完消息后又将控制权返回给Windows。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//而窗体负责响应消息的函数称为“窗体过程（Window Procedure）”，窗体过程是一个函数，每个窗体一个，它大致拥有以下的“模样”（C++代码）：</span><br><span class="line">LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line"> &#123;</span><br><span class="line">     //……</span><br><span class="line">     switch (uMsg) //依据消息标识符进行分类处理</span><br><span class="line">     &#123;</span><br><span class="line">     case WM_CREATE:</span><br><span class="line">         // 初始化窗体.</span><br><span class="line">         return 0;</span><br><span class="line">     case WM_PAINT:</span><br><span class="line">         // 绘制窗体</span><br><span class="line">         return 0;</span><br><span class="line">         //</span><br><span class="line">         //处理其他消息</span><br><span class="line">         //</span><br><span class="line">     default:</span><br><span class="line">         //如果窗体没有定义处理此种消息的代码，则转去调用系统默认的消息处理函数</span><br><span class="line">         return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> //可以看到，“窗体过程”不过就是一个多分支语句罢了，在这个语句中，窗体对不同类型的消息进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>以上内容来自<a href="https://blog.51cto.com/u_15080034/4353635"><strong>(整理)window 消息传递机制</strong></a><br><del>事实上，上述内容我也看的懵懂，大概当个了解</del></p><h2 id="Spy"><a href="#Spy" class="headerlink" title="Spy++"></a>Spy++</h2><p>Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。<br><img src="/2022/07/01/NAD-DLL/img_4.png" alt="介个就是spyxx.exe"><br><img src="https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/exp/w=500/sign=7ba3254179cb0a4685228b395b62f63e/64380cd7912397ddd6145fbf5b82b2b7d0a28718.jpg" alt="spyxx界面"></p><p>后续在本实验的应用上，我拿这个用来在创建模拟点击事件时的定位窗口坐标。</p><h2 id="Cheat-Engine"><a href="#Cheat-Engine" class="headerlink" title="Cheat Engine"></a>Cheat Engine</h2><p>Cheat Engine是一款专注于游戏的修改器。它可以用来扫描游戏中的内存，并允许修改它们。它还附带了调试器、反汇编器、汇编器、变速器、作弊器生成、Direct3D操作工具、系统检查工具等。<br><img src="/2022/07/01/NAD-DLL/img_5.png" alt="这个是Cheat Engine"><br><img src="/2022/07/01/NAD-DLL/img_6.png" alt="CE界面"></p><p>针对游戏的修改器&#x2F;辅助器&#x2F;或你叫它什么都好，总之要想达到作弊的效果，最重要的当然是要分析破译游戏内存数据所代表的含义，并能精准定位所要实现修改的内存存放地址，因此在后续的操作中，Cheat Engine扮演了十分重要的角色。</p><h2 id="Xenos"><a href="#Xenos" class="headerlink" title="Xenos"></a>Xenos</h2><p>《Xenos》是2007年池泽辰也执导的悬疑片，由海东键、一戸奈美、堀田ゆい夏等主演。<br><img src="/2022/07/01/NAD-DLL/img_7.png" alt="Xenos"><br><font size="3">…当然，不可能是这个”Xenos”</font></p><p>我们所要介绍的Xenos，是用来进行DLL注入的软件，长这样：<br><img src="/2022/07/01/NAD-DLL/img_8.png" alt="这个才是注入器Xenos"><br><img src="/2022/07/01/NAD-DLL/img_9.png" alt="Xenos界面"></p><p>这个工具，则是帮助我们将写好的DLL类型文件对程序进行注入。</p><p>以上，则是本次实验&#x2F;本类型任务的基本搭建环境和操作工具，接下来正式进入对本实验的分析与实践。</p><h1 id="实验分析：让俺看看扫雷背后都有啥"><a href="#实验分析：让俺看看扫雷背后都有啥" class="headerlink" title="实验分析：让俺看看扫雷背后都有啥"></a>实验分析：让俺看看扫雷背后都有啥</h1><p>哎呀，这里的内容还没有写，hwx说他想摆摆烂！</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLL </tag>
            
            <tag> 外挂 </tag>
            
            <tag> 钩子 </tag>
            
            <tag> 回调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[人工智能先导实践]1.n-Queens的多种算法题解</title>
      <link href="/2022/06/26/AI-nQueens/"/>
      <url>/2022/06/26/AI-nQueens/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：8皇后问题与n皇后问题"><a href="#相关叨叨：8皇后问题与n皇后问题" class="headerlink" title="相关叨叨：8皇后问题与n皇后问题"></a>相关叨叨：8皇后问题与n皇后问题</h1><p>八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。<br>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<br>下图是八皇后问题的一个解，可以用向量表示为：[f, d, g, a, h, b, e, c]，分别表示每行的皇后位置（列号）。<br><img src="https://i.postimg.cc/PJnPNvxZ/image.png" alt="八皇后问题的一个解"></p><p>实验拟题来自于 <strong>中国海洋大学 人工智能先导实践 lab03：比特匠心&amp;模拟退火</strong> <em>-by 徐建良</em></p><h1 id="n-queens多种解题方法思路"><a href="#n-queens多种解题方法思路" class="headerlink" title="n-queens多种解题方法思路"></a>n-queens多种解题方法思路</h1><h2 id="回溯与8皇后"><a href="#回溯与8皇后" class="headerlink" title="回溯与8皇后"></a>回溯与8皇后</h2><p>“回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。“<br>就是说，回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。<br>而对于解决八皇后问题，以深度优先的回溯法作为最基础的思路，有如下应用：<br>step1. 尝试先放置第一枚皇后，被涂黑的地方是不能放皇后<br><img src="https://pic3.zhimg.com/80/v2-bde25f03b5a86cc6ca47ee03fd171c9e_720w.jpg"><br>step2. 第二行的皇后只能放在第三格或第四格，比方我们放第三格，则：<br><img src="https://pic2.zhimg.com/80/v2-40654679a56af2cd9282b9ae60d4c641_720w.jpg"><br>step3. 可以看到再难以放下第三个皇后，此时我们就要用到回溯算法了。我们把第二个皇后更改位置，此时我们能放下第三枚皇后了。<br><img src="https://pic1.zhimg.com/80/v2-b810b81e8843c11e30e62277ddde1b4c_720w.jpg"><br>step4. 虽然是能放置第三个皇后，但是第四个皇后又无路可走了。返回上层调用（3号皇后），而3号也别无可去，继续回溯上层调用（2号），2号已然无路可去，继续回溯上层（1号），于是1号皇后改变位置如下，继续回溯。<br><img src="https://pic2.zhimg.com/80/v2-a22c5c4152b4b8b488555be294837f39_720w.jpg"><br>以上内容引自 <a href="https://zhuanlan.zhihu.com/p/54275352"><strong>小白带你学—回溯算法（Back Tracking)</strong> <em>-知乎 @小白算法</em></a></p><p>下面我们就建立在这一最基础的算法思路上，运用不同的进阶算法解决N阶皇后问题，且不断优化。</p><h2 id="利用哈希表降维进行初探"><a href="#利用哈希表降维进行初探" class="headerlink" title="利用哈希表降维进行初探"></a>利用哈希表降维进行初探</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>这个题解仅仅是建立在对该问题的探索与思考上，并无“创新”抑或“优化”可言，基于最暴力且朴素的降维思路，不断尝试从中找出规律、再考虑优化。</p><h3 id="二维哈希表"><a href="#二维哈希表" class="headerlink" title="二维哈希表"></a>二维哈希表</h3><p>· 实现过程：</p><ol><li>建立二维数组，将棋盘布局通过数组模拟占位信息。其中另外通过开辟数组分别存储列冲突、左斜冲突、和右斜冲突的信息。</li><li>设置回溯函数，统计该行下空余且不冲突可放置皇后的位置；<br>-&gt;更新并计算位置占用情况；<br>-&gt;若有空余位置，则从右起对每一位置依次进行回溯试探；<br>-&gt;进入下一行的试探，深度优先搜索正确解，只要遇到无空位可放置，则逐层向上回溯，至存在空位的行；<br>-&gt;依次对该行存在的可放置空位进行遍历试探，并对试探失败的空位进行排除；<br>-&gt;记录可行解的个数。</li><li>回溯函数部分代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span>** hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; hash[rowp][i] == <span class="number">0</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>** temp = <span class="keyword">new</span> <span class="type">int</span>* [n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">temp[i][j] = hash[rowp + i + <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i])</span><br><span class="line">&#123;</span><br><span class="line">hash[rowp][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;down &lt; n;down++, l--, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= <span class="number">0</span>)</span><br><span class="line">hash[down][l] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n)</span><br><span class="line">hash[down][r] = <span class="number">0</span>;</span><br><span class="line">hash[down][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>][h] = temp[m][h];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>· 小结<br>对于n-queens问题探索可行解过程，若n取值较小时较为迅速，且内存情况还算勉强，但对于8皇后、16皇后、甚至100皇后问题的求解，会占用大量内存，不仅执行过程极其缓慢，且容易导致触发程序断点、或是溢出问题。因而引出如下逐渐降维的实现过程。</li></ol><h3 id="一维哈希表"><a href="#一维哈希表" class="headerlink" title="一维哈希表"></a>一维哈希表</h3><p>· 实现：</p><ol><li>为了减少内存压力，通过将二进制数的位运算与数组进行结合，用n个二进制数记录行中可放置位置，并将之存放在一维数组中；</li><li>思路与上大致相同，不再赘述。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span>* hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = hash[rowp] &amp; -hash[rowp];</span><br><span class="line"><span class="type">int</span> position = <span class="built_in">log</span>(p) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*int position = p == 1 ? 0 : pow(p, 0.5);*/</span></span><br><span class="line">hash[rowp] -= p;</span><br><span class="line"><span class="type">int</span>* temp = <span class="keyword">new</span> <span class="type">int</span>[n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">temp[i] = hash[rowp + i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">1</span>;down &lt; n;down++, l++, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n - position)</span><br><span class="line">left = left + p &lt;&lt; l;</span><br><span class="line"><span class="keyword">if</span> (r &lt;= position)</span><br><span class="line">right = right + p &gt;&gt; r;</span><br><span class="line">hash[down] = hash[down] &amp; ~(left | right | p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; rowp &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; bitset&lt;6&gt;(hash[i]) &lt;&lt; endl;*/</span></span><br><span class="line"><span class="built_in">dfs1</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>] = temp[m];</span><br><span class="line"><span class="keyword">delete</span>[]temp;</span><br><span class="line">&#125; <span class="keyword">while</span> (hash[rowp]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>· 小结：<br>相较起二维数组，效率仅仅提高了一点点，内存占用情况仍不够美观，遂考虑压缩至0维哈希，即仅使用一个二进制数来存储全部占位信息并进行回溯。</li></ol><h2 id="位运算解法（0维哈希表）"><a href="#位运算解法（0维哈希表）" class="headerlink" title="位运算解法（0维哈希表）"></a>位运算解法（0维哈希表）</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算与位运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;   <span class="comment">//60 = 0011 1100</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;   <span class="comment">//13 = 0000 1101</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a &amp; b;             <span class="comment">//12 = 0000 1100 按位与</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 1 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a | b;             <span class="comment">//61 = 0011 1101 按位或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 2 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a ^ b;             <span class="comment">//49 = 0011 0001 异或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 3 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = ~a;                <span class="comment">//-61 = 1100 0011 按位取反</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 4 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;            <span class="comment">//240 = 1111 0000 位左移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 5 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;            <span class="comment">//15 = 0000 1111 位右移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 6 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="n-queens与位运算"><a href="#n-queens与位运算" class="headerlink" title="n-queens与位运算"></a>n-queens与位运算</h3><ol><li>思路说明（以8皇后为例）<br>首先，我们的基本思路与传统一样，每一行只能放并且必须放一个皇后。每次放置一个皇后之后，它就会对后面所有行中，可能放置皇后的位置产生影响。如下图所示，我们已经放置了三个皇后 Q1，Q2，Q3。 接着在下面一行放置 Q4 时，用彩色标注出的区域都是不可行的方案，会与已经放置的三个皇后产生冲突。<br><img src="https://i.postimg.cc/2jKVq5cV/image.png" alt="表达有无冲突的二进制数图解（本图来源于网络）">这个冲突其实有三种不同的情况，我们用三个变量 A，B，C 分别表示这三种不同的冲突。这三个变量都是一个八位的二进制数，这八位中，为 1 的表示有冲突，为 0 则表示没有冲突。<br>(1)与已放置的皇后处于同一列中：<br>我们用 A 表示这种冲突。例如在图中，第四行会有三个位置因为列攻击而不能再放置皇后（图中大红色方块），因此 A &#x3D; 1000 1001。<br>(2)与已放置的皇后处于同一左斜(指向右下方)对角线中：<br>我们用 B 表示这种冲突。例如在图中，蓝色方块所表示的位置，分别是由于Q1和Q2的左斜对角线上的攻击而不能够放置新的皇后， 因此B &#x3D; 0001 0010。<br>(3)与已放置的皇后处于同一右斜(指向右上方)对角线中：<br>我们用 C 表示这种冲突。例如图中粉色方块，是由 Q2 的右斜对角线的攻击造成的。因此 C &#x3D; 0010 0000。<br>有了 A，B，C 三个变量，我们很容易求出当前行(第 4 行)中，有哪些位置是可以放置皇后的。这个变量我们用 D 来表示，我们可以写出 D &#x3D; ~(A|B|C)。D中为 1 的那些位置则是我们可以放置皇后的位置。上图中，D &#x3D; 0100 0100。<br>此时，我们有两个可能的放置皇后的位置，那么如何取出每个可能的位置呢？<br>这里有一个技巧。我们用 bit 表示可能的一个位置，使用 bit &#x3D; D &amp; (-D) 即可取出 D 中最右边的 1（LSB，Least Significant Bit）。例如 D &#x3D; 0100 0100，则-D &#x3D; 10111100（注意计算机中的数都是补码，-D &#x3D; ~D + 1）。而bit &#x3D; D &amp; (-D) &#x3D; 0000 0100 取出了最右边的那个 1，代表在第 4 行第 6 列放置一个皇后。那么在此基础上，如何确定第 5 行的 A、B、C 的值呢？其实也很简单，对于表示列冲突的变量 A 来说，只要使用 A|bit 即可表示下一行的列冲突情况，对于 B，采用(B|bit)&lt;&lt;1，对于 C，采用(C|bit)&gt;&gt;1 即可表示下一行中，对角线冲突的情况。<br>  上述算法的思路来自于 <a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><strong>Backtracking Algorithms in MCPL using Bit Patterns and Recursion</strong> <em>-by Martin Richards</em></a> (这个链接好像并不很稳定的样子，可以挂个梯子去看)</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> hash,<span class="type">int</span> B,<span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//B左斜冲突</span></span><br><span class="line">    <span class="comment">//C右斜冲突</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//由于同列冲突的条件限定，且棋盘行数与列数相等</span></span><br><span class="line">    <span class="comment">//若想在每一列都放置皇后，则皇后不可能在同列，同时满足每一列都有皇后</span></span><br><span class="line">    <span class="comment">//因而可通过判断是否满足每一列都有皇后的条件来判断是否达成最终效果</span></span><br><span class="line"><span class="comment">//hash记录列冲突</span></span><br><span class="line"><span class="comment">//当hash==n，即所有每一列都放置了皇后时，结束本轮试探并计数</span></span><br><span class="line"><span class="keyword">if</span> (hash==n)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置回溯记忆点rememtemp</span></span><br><span class="line"><span class="comment">//若rememtemp==0时，即该行无位置可供放置，结束试探并开始回溯</span></span><br><span class="line"><span class="type">int</span> rememtemp = n &amp; ~(B | C | hash);  <span class="comment">//初始继承上一行中的放置情况</span></span><br><span class="line"><span class="keyword">while</span> (rememtemp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义A表示同列冲突，且其列位置会直接被继承到该行后的各行中</span></span><br><span class="line"><span class="type">int</span> A = rememtemp &amp; -rememtemp;     <span class="comment">//取当前行中最右一个可放置皇后的位置</span></span><br><span class="line">rememtemp -= A;       <span class="comment">//在记忆点中将A位置设置为0</span></span><br><span class="line"><span class="comment">//左斜冲突与右斜冲突在继承上一行的冲突情况同时，分别通过对该A位置的左移与右移进行对下一行冲突的更新</span></span><br><span class="line"><span class="comment">//对hash更新列冲突情况</span></span><br><span class="line"><span class="built_in">dfs0</span>(hash | A, (B | A) &lt;&lt; <span class="number">1</span>, (C | A) &gt;&gt; <span class="number">1</span>);      <span class="comment">//进入下一行</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果输出：<img src="https://i.postimg.cc/ZRmDxZwN/image.png" alt="6-queens"> <img src="https://i.postimg.cc/y89PQtgy/image.png" alt="10-queens"> <img src="https://i.postimg.cc/W1262n5M/image.png" alt="14-queens"> <img src="https://i.postimg.cc/d0f8jKwB/image.png" alt="16-queens"></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>利用位运算对n-queens问题可行解的数量进行统计，其延续了上述通过哈希表的思路，但代码更为简洁、运行速度更快、占用空间更小。唯一比较困难的是对于单一的二进制变量来储存整个棋盘的空位更新信息，在向下试探过程中容易忽略对当前行的“存档”，而在回溯过程中又容易忘记“读档”，而导致信息混乱。这个问题的解决则是在每次递归之前设置一个存档变量，将当前的数据存储之后再进行向下的试探，因而保证了在每一层的回溯过程中会自动读取上次所记录的数据。<br>下图是1-27阶问题的所有可行解：<br><img src="/2022/06/26/AI-nQueens/image.png" alt="1~27阶可行解"><br>对于该图中的分布状态的总结与思考，又引出了下文新的算法——多项式时间算法。</p><h2 id="N皇后的多项式时间算法"><a href="#N皇后的多项式时间算法" class="headerlink" title="N皇后的多项式时间算法"></a>N皇后的多项式时间算法</h2><h3 id="算法说明-1"><a href="#算法说明-1" class="headerlink" title="算法说明"></a>算法说明</h3><p>本算法来自于<a href="https://dl.acm.org/doi/pdf/10.1145/101340.101343"><strong>A Polynomial Time Algorithm for the N-Queens Problem</strong> <em>-by Rok Sosic &amp; Jun Gu</em></a> (这个链接好像并不很稳定的样子，可以挂个梯子去看) 在 1990 年首先提出。其灵感来源于对n阶可行解数量的考察，可以得出：可行解数量众多且均匀分布于整个状态空间 (棋盘上皇后的所有可能的 n!个排列)中。<br>思路简述：<br>通过一维数组将行数与该行对应皇后的列位置建立映射；<br>-&gt;随机打乱并保证每行皇后不在同一列；<br>-&gt;遍历判断皇后i或皇后j是否存在对角线冲突；<br> -&gt;若冲突，则试探交换两行皇后的位置；<br>  -&gt;判断交换后，全局冲突(评估值)是否减少，若减少则确定交换并使操作数自增记录，否则不交换且不记录；<br> -&gt;若都不冲突则不操作；<br>-&gt;遍历，知道操作数为0；<br>-&gt;判断调整后全局是否存在冲突，若存在则打乱重来（重启）；<br>-&gt;输出该解。</p><p>如下图是原论文中关于算法思路的说明(部分):<br><img src="/2022/06/26/AI-nQueens/image%20(2).png" alt="A Fast Algorithm for the N-Queens Problem "></p><p>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下（虽然感觉我写的怪怪的）:</p><ol><li><p>评估函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评估函数，计算当前棋盘下的冲突数，作为评估值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单个皇后局部对角线冲突计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个皇后局部对角线冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Attacked</span><span class="params">(<span class="type">int</span> *Board,<span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Att = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=row+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(Board[i] - Board[row]))</span><br><span class="line">Att++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Att&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Att;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>取解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heuristic</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> swaps_performed = <span class="number">0</span>;  <span class="comment">//设定计步器</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span>[n];      <span class="comment">//设定当前棋盘</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span>[n];         <span class="comment">//设定试探棋盘</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">swaps_performed = <span class="number">0</span>;     <span class="comment">//重计</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Attacked</span>(Current, i) || <span class="built_in">Attacked</span>(Current, j))   <span class="comment">//if queeni is attacked or queenj is attacked</span></span><br><span class="line">&#123;</span><br><span class="line">Next[i] = Current[j];</span><br><span class="line">Next[j] = Current[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Next) &lt; <span class="built_in">Conflicts</span>(Current))     <span class="comment">//if swap(queeni,queenj) reduces collisions </span></span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Next[i];</span><br><span class="line">Current[j] = Next[j];</span><br><span class="line">swaps_performed++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;*/</span></span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Next[i] = Current[i];</span><br><span class="line">Next[j] = Current[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Current))      <span class="comment">//检查是否获得解，若未获得解则打乱重来</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Current[i];</span><br><span class="line">Current[i] = Current[j];</span><br><span class="line">Current[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">swaps_performed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (swaps_performed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = Current[i];</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多项式时间测试主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polyn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;         </span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">Heuristic</span>(Board);</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示(14皇后为例)：<br><img src="/2022/06/26/AI-nQueens/img.png" alt="14queens"></p></li></ol><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>在编写过程中，感觉有些熟悉，有点随机重启爬山的味道，怀疑是不是自己并没有很好地利用好原作者的多项式时间算法思路）因为在实现过程中会出现自动跳出局域最优解（而可能并未达到全局最优），因而出现错误的结果，遂在完全照搬论文中伪代码的内容同时，增添了随机重启的部分，来确保最终结果为全局最优而非仅仅的局部最优。<br>我在这里的处理似乎并不是一个最合适的弥补策略，可以说并未很好地遵照多项式时间算法的巧妙设计。后续（或许很有可能不会）再返回来好好参悟一下算法来源的论文。<br>而面对上述提到的局部最优解的跳出，下文将会由此展示一个巧妙解决局部困死问题&#x2F;提高效率的算法。</p><h2 id="模拟退火算法在N皇后问题的运用"><a href="#模拟退火算法在N皇后问题的运用" class="headerlink" title="模拟退火算法在N皇后问题的运用"></a>模拟退火算法在N皇后问题的运用</h2><p>模拟退火很好地解决了局部困死地问题，因为它在运行过程中会对微小变动进行一定程度上的接受，即使这个微小变动所得到的最终解并不是我们想要的解，正是这种设定提高了执行效率。<br>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="算法说明-2"><a href="#算法说明-2" class="headerlink" title="算法说明"></a>算法说明</h3><p>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合一定的概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。<br>这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。将温度T当作控制参数，目标函数值f视为内能E，而固体在某温度T时的一个状态对应一个解[公式]，然后算法试图随着控制参数T的降低，使目标函数f(内能E)也逐渐降低，直至趋于全局最小值（退火中低温时的最低能量状态），就像金属退火过程一样。<br><img src="https://pic4.zhimg.com/80/v2-e1529b1b1577eecd16fb8a5418d51533_720w.jpg" alt="模拟退火流程图"><br>其中有几个需要注意的点：<br>· 初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。<br>· 在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。<br>· 当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</p><p>以上内容来自 <a href="https://zhuanlan.zhihu.com/p/266874840"><strong>模拟退火算法详解</strong> <em>-知乎 @智能算法</em></a> </p><p>思路简述：<br>通过一维数组将行数与该行对应皇后的列位置建立映射；<br>-&gt;设定初始温度且足够大，设定最小温度且一定小，设定退火速率；<br>-&gt;以行为单位遍历调整皇后位置，并计算调整前后的冲突值的差；<br>-&gt;若能量差小于0，则证明修改后的评估值耕地，在一定概率下接收评估值降低的修改，且使这个概率不知逐渐减小；否则直接接受调整；<br>-&gt;逐渐降温确保在未获得最优解时跳出局部最低温；<br>-&gt;直至调整到获得全局最低温结束；<br>-&gt;输出该解。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下：</p><ol><li><p>评估函数（与多项式时间算法的全局冲突数函数一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退火调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">proper</span><span class="params">(<span class="type">int</span>* Board, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> T = <span class="number">100.0</span>;    <span class="comment">//设定初始温度且足够大</span></span><br><span class="line"><span class="type">double</span> Tmin = <span class="number">1.0</span>;        <span class="comment">//设定最小温度且一定小</span></span><br><span class="line"><span class="type">double</span> Rate = <span class="number">0.8</span>;           <span class="comment">//退火速率</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span> [n];         <span class="comment">//记录当前棋盘放置情况</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span> [n];           <span class="comment">//记录修改后棋盘放置情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (T &gt; Tmin)        <span class="comment">//开始退火</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>;p &lt; n;p++)        <span class="comment">//遍历修改</span></span><br><span class="line">&#123;</span><br><span class="line">Next[row] = p;</span><br><span class="line"><span class="type">double</span> dE = <span class="built_in">Conflicts</span>(Next) - <span class="built_in">Conflicts</span>(Current);       <span class="comment">//计算能量差</span></span><br><span class="line"><span class="comment">//若能量差小于0，则证明修改后的评估值更低</span></span><br><span class="line"><span class="comment">//在一定概率下接受评估值降低的修改，且使这个概率值逐渐减小</span></span><br><span class="line"><span class="keyword">if</span> (dE &lt;= <span class="number">0</span> || (<span class="built_in">exp</span>((<span class="number">-1</span>) * dE / T) &gt; <span class="built_in">rand</span>() % <span class="number">100</span> * <span class="number">1.0</span> / <span class="number">10</span>))</span><br><span class="line">Current[row] = Next[row];</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Current[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">T *= Rate;         <span class="comment">//降温</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line">Board[row] = Current[row];</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"><span class="keyword">return</span> Board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟退火测试主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Simul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Conflicts</span>(Board))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == n)         <span class="comment">//重置</span></span><br><span class="line">row = <span class="number">0</span>;</span><br><span class="line">Board = <span class="built_in">proper</span>(Board, row++);         <span class="comment">//修改第row行皇后放置位置</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; row;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果：<br>与上无差，不做赘述。</p></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>经过对N皇后问题的不断深入探索（主要依赖于牛批前辈们的不同算法的提出），模拟退火用于寻找并输出n阶任一可行解，较好地解决了暴力遍历算法所导致的内存占用过大的问题&#x2F;耗时过长效率低的问题，同时解决了多项式算法局部困死的问题，对该问题的不同算法探索到此为止（事实上是因为实验布置的内容要求到此为止）。</p><h1 id="篇末BB"><a href="#篇末BB" class="headerlink" title="篇末BB"></a>篇末BB</h1><p>N-Queens&#x2F;N皇后&#x2F;无论怎么称呼的这一人工智能问题，属实经典，且解法众多，包括但远不限于如上所展示的 位运算&#x2F;多项式时间算法&#x2F;模拟退火算法 的经典算法，甚至如用爬山算法也将是很好的解题思路。对于人工智能，算法优化是其最关键的部分，面对庞大计算量，能否使程序语句更加精炼&#x2F;占用内存尽可能少&#x2F;运行速度更快，决定了你的人工是否足够智能。</p><p><del>（反正对于这一灵活度极高的问题上，我搜索且浏览了很多资料和文献才逐步探索出最优的算法，一圈子下来只是觉得自己是一人工智障）</del></p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 模拟退火 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello/Bonjour/你好</title>
      <link href="/2022/06/26/Hello/"/>
      <url>/2022/06/26/Hello/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><p><font size="4">This blog belongs to a student of Ocean University of China. It is used to record and share his undergraduate leaning experience and some interesting technology in computer science major.</font></p><h2 id="Bonjour"><a href="#Bonjour" class="headerlink" title="Bonjour!"></a>Bonjour!</h2><p><font size="4">Ce blog appartient à un étudiant de l’université Océanique de Chine. Il est utilisé pour documenter et partager son expérience  de premier cycle en informatique et centaines technique interessantes.</font></p><h2 id="你好哇！"><a href="#你好哇！" class="headerlink" title="你好哇！"></a>你好哇！</h2><p><font size="4">这个博客是一个中国海洋大学的学生创设的，用来记录和分享一些他本科期间在计算机专业的一些学习经验和有趣的技术。对了，他的网名常用“小二上馄饨”，他喜欢被叫做“馄饨”。</font></p><hr>]]></content>
      
      
      <categories>
          
          <category> 题外话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ME </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
