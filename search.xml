<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[文献阅读]通过对抗统计一致性规避深度伪造检测器-StatAttack</title>
      <link href="/2023/05/28/StatAttack/"/>
      <url>/2023/05/28/StatAttack/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="https://arxiv.org/abs/2304.11670">[2304.11670] Evading DeepFake Detectors via Adversarial Statistical Consistency</a></p><p>日期：2023-04-23</p><p>关键词：Adversarial Attack, DeepFake</p><p>出处：CVPR 2023</p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>深度伪造检测技术通常依赖于检测自然（真实）图像和深度伪造生成图像在<strong>空域和频域</strong>的统计差异。</p><p>本论文提出显式地最小化统计差异来规避最先进的深度伪造检测器——针对深度伪造检测器的统计一致性攻击（StatAttack）：</p><ol><li>选取几种统计敏感的<strong>自然退化（曝光度、模糊度、噪声）</strong>，并将其以对抗的方式添加到伪造图像中。</li><li>自然图像和深度伪造图像之间的统计差异与两种图像之间的分布偏移正相关，本论文提出<strong>使用感知节点分布损失来指导不同退化的优化</strong>，因此，生成的对抗样本的特征分布接近更自然图像。</li><li>将StatAttack扩展到MStat Attack，将单层退化依次扩展到多层退化，并利用损失联合调整组合权重。</li></ol><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>深度伪造检测器容易受到对抗性攻击，这些攻击可以通过向假图像中注入扰动来绕过检测器。</p><p>以往的一些研究探讨了对抗样本的可迁移性，它是针对特定受害者模型设计的对抗样本攻击为同一任务训练的其他模型的能力。</p><p>不同的数据增强和预处理方法导致的网络架构和训练样本的变化，实现针对深度伪造检测器的可迁移攻击具有挑战性，这些差异往往导致在面对不同的深度伪造检测器时，基于典型攻击方法构造的对抗样本的可迁移性较差。</p><p>StatAttack选择<strong>三种统计敏感的自然退化</strong>，包括曝光、模糊和噪声，并以对抗的方式将他们添加到假图像中。真假图像集之间的统计差异与其分布偏移正相关。</p><p>本论文提出通过最小化伪造图像和自然图像的特征分布之间的距离来缓解这些差异。通过<strong>引入一种感知节点分布损失函数</strong>，有效地最小化了统计差异。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142334613.png" alt="fig1.浅蓝色区域和浅红色区域分别表示自然/真实图像和伪造图像的其纳入空间。深蓝色区域表示不同检测器共享的真实图像的嵌入空间。第一行表明，典型的攻击可以将假样本（橙色点）映射到”真实“样本，可以欺骗检测器A，但不能误导检测器B。第二行则将假样本检测到不同检测器的公共区域，可以欺骗两个检测器。"></p><p>MStatAttack执行多层退化，并且可以在每个攻击步骤中动态调整不同层中每个退化的权重。</p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul><li>提出了一种新的基于自然退化的攻击方法StatAttack，可以通过最小化一个感知节点分布损失来填补真假图像之间的特征分布差异</li><li>提出了进一步的多层对应的MStatAttack，可以选择更有效的扰动组合并生成更自然的对抗样本</li></ul><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><h2 id="统计学差异"><a href="#统计学差异" class="headerlink" title="统计学差异"></a>统计学差异</h2><p>几种检测方法解释了自然图像和伪造图像在频域和空间域的统计差异。</p><ol><li><p>GAN网络架构和训练过程会导致GAN生成图像和自然图像之间的亮度统计差异。例如，一些GAN仅能生成强度值有限的图像，无法生成饱和和曝光不足的区域。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142420529.png" alt="fig2.亮度统计差异。(a)展示了自然人脸数据集的平均亮度直方图，(b)展示了ProGAN生成的缺乏饱和曝光不足区域的伪造人脸数据集的平均亮度直方图。(c)是与(b)部分曝光调整相同的数据集。调整局部亮度后，伪图像直方图中出现饱和和欠曝光像素值。"></p></li><li><p>自然图像和GAN生成图像在频域信息上的统计差异，揭示了高频成分的显著差异。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142904840.png" alt="fig3.频率统计差异（功率谱）。(a)表明GAN生成的图像与自然图像相比，高频成分急剧增加。(b)揭示了高斯模糊过程可以减小这些频率差异。"></p></li><li><p>通过直接观察GANs生成图像的频谱图发现了一些统计线索。他们的实验结果表明GANs不可避免地会在处理后的图像中留下规则的高频伪影。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142538712.png" alt="fig4.频率统计差异（频谱图）。(a)为真实人脸图像。(b)为经过Stargam篡改的图像，(c)为加入随机噪声的伪造图像。它们的直方图显示在每幅图像的右边。与自然图像相比，星敏图像（用红色箭头指示）的频谱图中出现了规则的频率伪影。加入噪声后，伪影图像中的高频伪影消失。"></p></li></ol><h2 id="统计一致性攻击-StatAttack"><a href="#统计一致性攻击-StatAttack" class="headerlink" title="统计一致性攻击(StatAttack)"></a>统计一致性攻击(StatAttack)</h2><h3 id="统计敏感退化"><a href="#统计敏感退化" class="headerlink" title="统计敏感退化"></a>统计敏感退化</h3><ol><li><p>退化选择</p><p>三种常见的能有效降低统计差异的自然退化：</p><ul><li>改变曝光。调整局部区域像素的亮度值可以改变伪造图像的亮度分布。如<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">fig2</a>。</li><li>添加模糊。通过高斯低通滤波器滤除伪造图像中的高频成分，可以减小频域统计差异。如<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">fig3</a>。</li><li>添加噪声。如<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">fig4</a>。通过加入随机噪声，伪造图像中的规则伪影被消除。</li></ul><p>值得注意的是，在图像中加入局部曝光不仅可以改变空间域的信息，还可以改变频率域的信息。此外，高斯滤波可以减少伪影图像中一些规则的高频伪影。</p></li><li><p>自然的曝光对抗</p><p>旨在将局部曝光注入到伪造图像中，使其亮度统计更接近自然图像。除此之外，由于自然曝光变化平滑，因此注入到伪造图像中的曝光也应该具有类似的（即图像中相邻像素具有相似的曝光值）性质。</p><p>采用对抗曝光生成模型：由用于生成曝光的多项式模型和用于保持曝光自然度的平滑公式构成。</p><ul><li>$P_e(\mathbf{X}^{fake})=log^{-1}(\tilde{\mathbf{X}}^{fake}+\tilde{\mathbf{E}})$，(1)<ul><li>$\tilde{E}$：生成曝光的多项式模型</li><li>$\mathbf{X}^{fake}$：fake image</li><li>$\tilde{\cdot}$：对数运算</li></ul></li></ul><p>为了保持曝光的自然性，对于多项式模型包含的两组参数$\mathbf{a}$和$φ$，我们通过在损失函数中加入平滑方程来约束其取值：</p><ul><li><p>$S (a, φ) = −λ<em>a ||a||_2^2−λ</em>φ||▽φ||_2^2$，(2)</p><p>超参数$λ<em>a$和$λ</em>φ$：调节对抗攻击用户平滑性之间的平衡。</p></li></ul></li><li><p>高斯模糊对抗</p><p>对于一般的高斯模糊，在图像中不同位置使用的高斯核具有相同的值。为了以对抗的方式添加高斯模糊退化，我们提出将高斯核设计为可学习的对抗核。该方法允许在图像的不同位置自适应地应用对抗扰动。</p><p>我们旨在学习一个标准差图$σ$，利用$σ_{x_i,y_i}$，计算第$i$个像素$H_i$的对抗高斯核如下：</p><ul><li>$H<em>i(u, v) = \frac{1} {2π (σ</em>{x<em>i,y_i} )^2} exp(−\frac{ u^2 + v^2}{ 2π (σ</em>{x_i,y_i} )^2})$，(3)<ul><li>$σ_{x_i,y_i}$：高斯核在第$i$个像素位置的初始标准差</li><li>$u$和$v$表示高斯核内点到中心像素$(x_i,y_i)$的相对坐标</li></ul></li></ul><p>利用对抗高斯核，对伪造图像进行模糊：</p><ul><li>$P_b(\mathbf{X}^{fake}) = \sum \limits {i∈\mathcal{N} (i)} g(\mathbf{X}^{fake} i , k) ∗ \mathbf{H}_i$，(4)<ul><li>$\mathcal{N}(i)$：$\mathbf{X}^{fake}$中所有像素</li><li>$g(\mathbf{X}^{fake},k)$：以第$i$个像素为中心，被包围在半径为$k$的高斯核内的区域</li><li>$*$：滤波操作运算符</li></ul></li></ul><p>给生成的图像$P<em>b(\mathbf{X}^{fake})$一个与对抗相关的损失函数，并通过<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">公式(4)</a>最小化它得到${σ</em>{x_i,y_i}}$和$\mathbf{H}_i$。随后，通过计算的高斯核对伪造图像施加像素级高斯模糊。</p></li><li><p>噪声对抗</p><ul><li>$P_n(\mathbf{X}^{fake}) = \mathbf{X}^{fake} + \mathbf{N}_a$，(5)<ul><li>$\mathbf{N}_a$：与$\mathbf{X}^{fake}$大小相同的对抗噪声图。</li></ul></li></ul><p>在每个攻击步骤中，我们通过最小化我们的对抗损失函数来生成对抗噪声，然后将其添加到每个fake image中。为了确保对抗噪声不会显著影响图像的质量，我们使用约束项对$\mathbf{N}_a$进行稀疏化。该约束项被纳入到最终的目标函数中。</p></li><li><p>StatAttack</p><p>将上述扰动总结如下：</p><ul><li><p>$P_θ(\mathbf{X}^{fake}) = P_n(P_b(P_e(\mathbf{X}^{fake})))$，(6)</p><p>$P_θ(\mathbf{X}^{fake})$ 包含四组待优化参数${\mathbf{a},φ,σ,\mathbf{N}_a}$</p></li></ul></li></ol><h3 id="感知节点分布统计一致性"><a href="#感知节点分布统计一致性" class="headerlink" title="感知节点分布统计一致性"></a>感知节点分布统计一致性</h3><p>给定一组真实图像和一组伪造图像，本论文研究了两个集合的统计差异与分布偏移之间的相关性，发现统计差异与两个集合之间的分布偏移正相关。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230507224035701.png" alt="fig6.统计差异与自然图像集和伪造图像集的分布偏移之间的相关性。(1)-(4)展示了两组特征分布之间的功率谱和MMD值。蓝色曲线表示GAN生成图像的高频部分，红色曲线代表自然图像的。使用不同高斯核$\sigma$的高斯模糊处理伪造图像，观察到随着高频统计差异的减小，MMD值也随之减小。"></p><p>fig6.统计差异与自然图像集和伪造图像集的分布偏移之间的相关性。(1)-(4)展示了两组特征分布之间的功率谱和MMD值。蓝色曲线表示GAN生成图像的高频部分，红色曲线代表自然图像的。使用不同高斯核$\sigma$的高斯模糊处理伪造图像，观察到随着高频统计差异的减小，MMD值也随之减小。</p><p>使用最大均值差异（MMD）来衡量过滤后的伪造图像与自然图像的特征分布之间的距离。增大$\sigma$可以降低伪造图像中的高频频谱，且MMD值随着统计差异的减小而减小。</p><ol><li><p>目标函数</p><p>若生成的对抗样本被分类为相反的类，则认为对二分类器的攻击是成功的。目标函数：</p><ul><li>$\mathop{argmin} \limits<em>{a,φ,σ,\mathbf{N}a} J{MMD}( P</em>θ (\mathcal{X}^{fake}) , \mathcal{X}^{real}) + S(\mathbf{a}, φ), \newline subject\ to\ ∥N_a∥_p ≤ \epsilon$，(7)<ul><li>$\mathcal{X}$：图像集</li><li>$J_{MMD}(\cdot)$：在某个检测器层中两个特征分布之间的MMD值。</li></ul></li></ul><p>通过目标函数计算曝光对抗、高斯模糊对抗和噪声对抗的参数。</p></li><li><p>算法</p><p>初始化3个扰动参数${\mathbf{a},φ,σ,\mathbf{N}_a}$，并将其添加到伪造图像中。接下来，在每个基于DNN的检测器模型中收集自然图像和伪造图像在全局池化层上的特征分布，并计算它们的MMD值。为了优化扰动参数，我们使用符号梯度下降来最小化<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">方程(7)</a>。最后，将${\mathbf{a},φ,σ,\mathbf{N}_a}$的优化值应用于原始伪造图像，从而生成对抗伪造图像。</p></li></ol><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230507223500404.png" alt="fig5.攻击生成流程。首先，在伪造图像中加入初始化的对抗退化（曝光对抗、高斯模糊对抗、噪声对抗）。然后，收集自然图像和伪造图像的特征分布并计算其MMD值（最大均值差异，可被使用为损失函数）。最后，通过最小化损失函数来优化扰动参数，并将优化后的退化应用于伪造图像。"></p><h2 id="多层Stat攻击（MAtatAttack）"><a href="#多层Stat攻击（MAtatAttack）" class="headerlink" title="多层Stat攻击（MAtatAttack）"></a>多层Stat攻击（MAtatAttack）</h2><p>在图像中反复添加对抗扰动可能会提高攻击的成功率。因此我们进一步将StatAttack扩展到MStatAttack，依次将单层退化扩展到多层退化，并使用损失来联合调整组合权重。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142650597.png" alt="fig7.MStat攻击的体系结构。在最小化目标函数时，对每种攻击模式的权重和参数进行联合优化。"></p><p>如fig7所示，MStatAttack使用多层来处理输入。在第k层，MStatAttack取第(k-1)层的输出，记为$\mathbf{X}^{fake}<em>{p</em>{k-1}}$，并行应用3种退化对抗（$e、b、n$）；然后，我们维护四个权重（$w’<em>{e_k}、w’</em>{b<em>k}、w’<em>{n_k}、w’</em>{\mathbf{X}<em>k}$）以混合$\mathbf{X}^{fake}</em>{p</em>{k-1}}$及其3个扰动版本，获取第k层的输出。为了保证四个权重之和等于1，我们将它们馈送到softmax层，得到（$w<em>{e_k}、w</em>{b<em>k}、w</em>{n<em>k}、w</em>{\mathbf{X}_k}$）。各层扰动可写作：</p><ul><li><p>$X^{fake}<em>{p_k} = w</em>{e<em>k} P_e(\mathbf{X}^{fake}<em>{ p</em>{k−1}})+w</em>{b<em>k} P_b(\mathbf{X}^{fake}</em> {p<em>{k−1}} ) + w</em>{n<em>k} P_n(\mathbf{X}^{fake}<em>{ p</em>{k−1}} ) + w</em>{\mathbf{X}<em>k} \mathbf{X}^{fake}</em>{ p_{k−1}} , n ≥ 1$，(8)</p><p>$\mathbf{X}^{fake}_{p_k}$：第k层生成的对抗样本</p></li></ul><p>在优化过程中，基于损失函数对原始权重和所有退化参数进行联合优化。sofmax层确保更新后的权重相加为1，防止图像混合过程种的强度溢出。</p><p>除了自动选择合适的攻击策略（即扰动组合）外，MStatAttack还可以通过原始伪造图像中融入更多的成分来增强生成的对抗样本。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528143148453.png" alt="空间相关性深度伪造探测器的攻击成功率和图像质量评估。在每组中，第一列表示在白盒环境下的攻击成功率，第二、三、四列是在其他深度伪造检测器上的转移攻击成功率。我们用红色、黄色和蓝色标记了第一、第二和第三高的攻击成功率。最后一列是BRISQUE评分"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528143238345.png" alt="基于频率的深度伪造检测器的攻击成功率和图像质量评估。每组中，第1列表示白盒设置下的攻击成功率，第2列是黑盒设置下的攻击成功率。ResNet列表示由ResNet生成的对抗样本的迁移成功率。我们用红色、黄色和蓝色标记了第一、第二和第三高的攻击成功率。最后一列是BRISQUE评分"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> DeepFake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]基于特征重要性感知攻击的可迁移对抗攻击-FIA</title>
      <link href="/2023/05/27/FIA/"/>
      <url>/2023/05/27/FIA/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="https://arxiv.org/abs/2107.14185">[2107.14185] Feature Importance-aware Transferable Adversarial Attacks (arxiv.org)</a></p><p>日期：2022-02</p><p>关键词：Adversarial Attack</p><p>出处：ICCV 2021</p><p>代码仓库：<a href="https://github.com/hcguoO0/FIA">https://github.com/hcguoO0/FIA</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>深度神经网络（DNNs）容易受到对抗样本对深度神经网络的影响在研究神经网络的内部缺陷和提高其鲁棒性方面发挥着重要作用。</li><li>传统攻击方法如FGSM、BIM等制作的对抗样本往往由于对源模型的过拟合而表现出较弱的可迁移性。</li><li>现有的可迁移性的对抗性扰动直接在中间层进行攻击，没有干扰输出层，且最大化内部特征失真，以增强可迁移性；然而其通过不加区分地扭曲特征来生成对抗样本，而没有意识到图像中物体地内部特征，因此容易陷入特定于模型的局部最优。</li><li>本论文提出了一个特征重要性感知攻击的方法，通过<strong>破坏主导不同模型决策的关键对象感知特性</strong>（也就是破坏主导模型决策的一些特性），从而显著提高对抗样本的迁移性。针对特定于模型的特征，我们<strong>引入了聚合梯度</strong>，它将有效地一直特定于模型的特征，同时提供特征的对象感知重要性。</li></ul><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224326542.png" alt="Fig.1 模型注意力感知可视化图像。特征性感知攻击（下排）抑制了模型对重要特征的关注，而促进了对琐碎无关的特征的关注，从而显著散焦/误导模型。这样的对抗样本导致源模型和目标模型不仅未能捕捉到重要对象，而且还将注意力放在琐碎区域。"></p><ul><li>本论文的主要贡献：<ul><li>提出特征重要性感知攻击（Feature Importance-aware Attack，FIA），通过<strong>破坏主导不同模型决策的关键对象感知特征</strong>来增强对抗样本的可迁移性；</li><li>分析了现有工作相对较低的可性背后的基本原理，即对特定于模型的“噪声”特征的<strong>过度拟合</strong>，针对这些特征<strong>引入聚合梯度</strong>，以指导生成更多可迁移的对抗样本。</li></ul></li></ul><h1 id="特征重要性感知攻击（FIA）"><a href="#特征重要性感知攻击（FIA）" class="headerlink" title="特征重要性感知攻击（FIA）"></a>特征重要性感知攻击（FIA）</h1><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>对于一个分类模型$f<em>\theta:x\mapsto y$，其中x和y分别表示干净图像（原始图像/自然图像）和真实标签，θ表示模型的参数。我们的目标是生成一个对抗样本$x^{adv}=x+\epsilon$，以通过设计出扰动$\epsilon$来误导分类器，也即使得$f</em>\theta(x^{adv})≠y$。通常，$\ell_p-$范数用于正则化扰动。因此，对抗样本的生成可以表述为如下式的优化问题：</p><ul><li>$\large arg \mathop{max}\limits_{x^{adv}}J(x^{adv},y),s.t. ||x-x^{adv}||_p≤\epsilon$，   (1)<ul><li>其中$J(·,·)$为损失函数，测量真实标签与预测标签间的差距（即交叉熵）</li><li>$argmax\ g(t)$表达的是定义域的一个子集，且盖子集中任一元素都可使函数$g(t)$取最大值</li><li>在这项工作中$p=∞$</li></ul></li></ul><h2 id="特征重要性感知攻击概述"><a href="#特征重要性感知攻击概述" class="headerlink" title="特征重要性感知攻击概述"></a>特征重要性感知攻击概述</h2><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224535505.png" alt="Fig.2 特征重要性感知攻击概述图。给定一个输入图像，从中间层（红色示块）中提取特征图。然后计算从输出回传到特征图的梯度，作为特征重要性（Feture Importance）。将特征图和归一化梯度进行点积（Element-wise Product）后得到加权的特征图，以达到抑制积极/重要特征并促进消极/琐碎特征的目的来实现优化，获得具有更高可迁移性的对抗样本。"></p><blockquote><p><strong>特征重要性</strong></p><p>不同的网络会提取排他性特征来更好地适应数据域，这就产生了特定于模型的特征表示，因而对抗样本的生成需要由来自源模型的与模型无关的关键特征来指导，这被称为特征重要性。</p></blockquote><h2 id="基于梯度聚合的特征重要性"><a href="#基于梯度聚合的特征重要性" class="headerlink" title="基于梯度聚合的特征重要性"></a>基于梯度聚合的特征重要性</h2><p>由于特征重要性与特征对最终决策的贡献程度成正比，一个方法是通过下式计算关于$f_k(x)$的梯度来求得特征重要性：</p><ul><li>$\Large \Delta^x_k=\frac{\partial l(x,t)}{\partial f_k(x)}$，   (2)<ul><li>令$f$表示源模型，则$f_k(x)$表示来自第$k$层的特征图</li><li>$l(·,·)$表示相对于真实标签$t$的对数输出</li></ul></li></ul><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224625171.png" alt="Fig.3 VGG16的Conv3_3层的特征图和相应的梯度的可视化。其中Raw Features表示原始特征图，Raw Gradients表示原始梯度图；Aggregate Features表示经聚合之后的特征图，Aggregate Gradients表示经聚合之后的梯度图。Raw是从原始图像中获得，Aggregate是从原始图像多次变换（即随即像素下降）获得的。"></p><p>可以看出原始梯度图和原始特征图在视觉上都是有噪声的，也就是在非目标区域上存在脉冲较大的梯度，这可能时由于模型特有的解空间造成的；但经过聚合之后的特征图和梯度图就消除了这样的影响，只在目标区域存在脉冲较大的梯度。可以说，与原始梯度相比，<strong>聚合梯度更加干净、更加关注对象</strong>，在可转移的视角中提供了更好的特征重要性。</p><h3 id="聚合梯度"><a href="#聚合梯度" class="headerlink" title="聚合梯度"></a>聚合梯度</h3><p>为了抑制特定于模型的信息，本论文提出聚合梯度（aggregate gradient），聚合了来自随机变换$x$的梯度，如下图所示。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224656060.png" alt="Fig.4 聚合梯度的图解。梯度是从多个随机掩码图像中获得的，且最终的聚合梯度（即特征重要性）由这些梯度的平均值表示。"></p><p>梯度聚合公式：</p><ul><li>$\large\bar{\Delta}<em>k^x=\frac{1}{C}\sum\limits^N</em>{n=1}\Delta^{x\odot M^n<em>{p_d}}_k,M</em>{p_d}\sim Bernoulli(1-p_d)$，   (3)<ul><li>$M_{p_d}$表示和原图x大小相同的二进制矩阵（符合服从参数为$1-p_d$的伯努利分布）</li><li>$\bigodot$表示点积</li><li>标准化数$C$是$\ell_2-$范数，用以约束聚合梯度</li><li>$N$表示应用于输入$x$的随机掩码的数量</li><li>$p_d$为下降率</li></ul></li></ul><p><strong>即首先将原图与随机掩码图像进行点积，然后将结果输入到模型中求第k层特征图的梯度，最后将这些梯度进行相加（聚合），并使用$\ell_2-$范数来做一个约束，得到聚合梯度。</strong></p><blockquote><p>$\ell_2-$范数：定义为向量所有元素的平方和的开平方</p></blockquote><p>由于语义目标感知/重要特征/梯度对上述的这个变换是鲁棒的，但是一些特定模型的梯度或者特征容易受到转换的应向，因此那些鲁棒的可迁移的特征将会在聚合后被突出显示，而其他的梯度将会被中和。</p><h3 id="攻击算法"><a href="#攻击算法" class="headerlink" title="攻击算法"></a>攻击算法</h3><p>根据上述的特征重要性（即聚合梯度$\bar\Delta_k^x$），本论文有如下损失函数公式来抑制特征重要性，以指导对抗样本$x^{adv}$的生成：</p><ul><li><p>$\large \mathcal{L}(x^{adv})=\sum(\Delta \odot f_k(x^{adv}))$，   (4)</p><blockquote><p>为了简便而将$\bar\Delta^x_k$表示为$\Delta$</p></blockquote></li></ul><p>直观而言，修正特征以靠近真实标签的重要特征在特征重要性$\Delta$中占有较高的比重，且$\Delta$的符号给修正提供了方向。<strong>生成可迁移的对抗样本的目的是减少具符号为正的$\Delta$的重要特征，增加符号为负的$\Delta$对应的重要特征。</strong>因此可通过最小化式(4)来实现。</p><p>最后，将式(1)带入到式(1)，得到最终的对抗样本生成公式：</p><p>$\large arg\mathop{min}\limits<em>{x^{adv}}\mathcal{L}(x^{adv}),\ s.t.\ ||x-x^{adv}||</em>∞≤\epsilon$，   (5)</p><p>采用MIM算法求解式(5)算法如下：</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224900588.png" alt="MIM算法是一种子监督表征学习方法。其主要思路是对输入图像进行分块和随机掩码操作，然后对掩码区域进行预测。"></p><p>MIM算法是一种子监督表征学习方法。其主要思路是对输入图像进行分块和随机掩码操作，然后对掩码区域进行预测。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>下降率$P_d$：在影响成功率方面起着重要作用，而且这种影响在不同的目标模型中往往是一致的。一个较大的$P_d$（例如，0.5）会破坏图像的重要结构信息，从而显著降低成功率。因此，攻击正常训练模型的最佳$P_d$在0.2和0.3之间，而攻击防御模型的最佳$P_d$应该在0.1左右。</li><li>集合数$N$：较大的$N$往往产生较高的成功率，但会逐渐饱和。</li><li>最后我们确定了集成数$N=20$，正常训练模型的下降率$P_d=0.3$，以及防御模型的$P_d=0.1$。</li><li>选择中间层：特征层k的选择对特征级攻击有很大的影响，因为DNN的早期层（early layer）可能会构建一个通常是特定于数据的基本特征集，较进一步的层可能会对这些提取的特征进行处理，以最大化模型的分类精度，使这些特征进行处理，以最大化模型的分类精度，使这些特征成为特定于模型的。因此<strong>早期层没有学习到真正类别的显著特征和语义概念</strong>，而<strong>后期层是特定于模型的，在可迁移攻击中应该避开</strong>。相比之下，<strong>中间层（middle layer）具有良好的分类表示，并且它们与模型架构的相关性不高</strong>，因此中间层是为了更好的可迁移性而被攻击的最佳选择。</li></ul><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527225123057.png" alt="对正常训练的模型进行不同攻击的成功率。第1列显示源模型，第1行列出目标模型。FIA是我们的方法，FIA + PIM是FIA和PIM的结合。&#39; * &#39;表示白盒攻击，因为目标模型是源模型，最好的结果用粗体突出显示。"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527225145027.png" alt="针对防御模型的不同攻击成功率。第1列显示源模型，第1行列出目标模型。FIA是我们的方法，FIA + PITIM是FIA、PIM和TIM的结合。最好的结果以粗体突出。"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机基础]ban门弄fool-一些常用的工具</title>
      <link href="/2022/11/21/Tools/"/>
      <url>/2022/11/21/Tools/</url>
      
        <content type="html"><![CDATA[<h1 id="pwndbg-GDB"><a href="#pwndbg-GDB" class="headerlink" title="pwndbg(GDB)"></a>pwndbg(GDB)</h1><h2 id="gdb简记"><a href="#gdb简记" class="headerlink" title="gdb简记"></a>gdb简记</h2><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><font size="4">官网：[GDB: The GNU Project Debugger (sourceware.org)](http://www.sourceware.org/gdb/)</font><p>百科：<a href="https://baike.baidu.com/item/gdb/10869514?fr=aladdin">gdb_百度百科 (baidu.com)</a></p><p>教程大全：<a href="https://blog.csdn.net/kangkanglhb88008/article/details/127155083">gdb入门教程大全（清晰明了）_我是标同学的博客-CSDN博客_gdb 教程</a></p><font size="5">声音超甜</font>的b站教程：[【小神仙讲 GDB】 通俗易懂版教程 | 一小时入门GDB | Debug | c/c++程序员必备 | 佩雨小神仙 _哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1EK411g7Li/?spm_id_from=333.337.search-card.all.click&vd_source=7f553078c1aeb5b58ec0305625bc85c8)知乎：[GDB调试入门指南 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/74897601)### 啥是个gdb![Summary of GDB](./Tools/img1.png)GDB可以做四种主要的事情(加上支持这些事情的其他事情)来帮助您捕获bug:•启动你的程序，指定任何可能影响它行为的东西。•让你的程序在特定条件下停止。•当你的程序停止时，检查发生了什么。•修改程序中的内容，这样你就可以尝试纠正一个错误的影响，并继续学习另一个错误。### 咋配置gdb安装gdb并检查是否成功安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install gdb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb --version</span></span><br></pre></td></tr></table></figure>`GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2Copyright (C) 2020 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later <http: gnu.org licenses gpl.html>This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.`<font size="6">装起来了</font><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>因为之前一些工作需要逆向，所以我直接下载的是<strong>pwndbg</strong>，pwndbg专门针对pwn题调试添加了额外的功能。</p><p>就是说，是个gdb的插件，用来进行逆向工程调试的。</p><p>如下是pwndbg的安装命令：</p><p><code>$ git clone https://github.com/pwndbg/pwndbg</code></p><p><code>$ cd pwndbg</code></p><p><code>$ ./setup.sh</code></p><p>当然，如果只是debug的话，gdb足够，且装了pwndbg之后进行gdb，命令没有变化，只是会在gdb基础上展示出逆向进程。</p><p>在此附说明是因为：<font size="5">下述示例中的展示皆基于pwndbg插件下的gdb。</font></p><h2 id="quickstart"><a href="#quickstart" class="headerlink" title="quickstart"></a>quickstart</h2><p>先vim一个简单的c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译<code>gcc -g start.c</code>，通过gdb进入./a.out执行文件<code>gdb ./a.out</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g start.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb ./a.out</span></span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from ./a.out...</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span></span><br></pre></td></tr></table></figure><p>如此进入到gdb指令交互。</p><h2 id="gdb指令"><a href="#gdb指令" class="headerlink" title="gdb指令"></a>gdb指令</h2><h3 id="男人一下"><a href="#男人一下" class="headerlink" title="男人一下"></a>男人一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man gdb</span></span><br></pre></td></tr></table></figure><p>Here are some of the most frequently needed GDB commands:</p><ul><li><p><strong>break</strong> [file:]function</p><pre><code>   Set a breakpoint at function (in file).</code></pre></li><li><p><strong>run</strong> [arglist]</p><pre><code>   Start your program (with arglist, if specified).</code></pre></li><li><p><strong>bt</strong>  Backtrace: display the program stack.</p></li><li><p><strong>print</strong> expr</p><pre><code>   Display the value of an expression.</code></pre></li><li><p><strong>c</strong>   Continue running your program (after stopping, e.g. at a breakpoint).</p></li><li><p><strong>next</strong></p><pre><code>   Execute next program line (after stopping); step over any function calls in the line.</code></pre></li><li><p><strong>list</strong> [file:]function</p><pre><code>       type the text of the program in the vicinity of where it is presently stopped.</code></pre></li><li><p><strong>step</strong></p><pre><code>  Execute next program line (after stopping); step into any function calls in the line.</code></pre></li><li><p><strong>help</strong> [name]</p><pre><code>  Show information about GDB command name, or general information  about using GDB.</code></pre></li><li><p><strong>quit</strong></p><pre><code>   Exit from GDB.</code></pre></li></ul><h3 id="基本命令应用"><a href="#基本命令应用" class="headerlink" title="基本命令应用"></a>基本命令应用</h3><h4 id="r-run-润"><a href="#r-run-润" class="headerlink" title="r/run: 润"></a>r/run: 润</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">[Inferior 1 (process 134817) exited normally]</span><br></pre></td></tr></table></figure><h4 id="b-break-打断点"><a href="#b-break-打断点" class="headerlink" title="b/break: 打断点"></a>b/break: 打断点</h4><h5 id="b-函数名字"><a href="#b-函数名字" class="headerlink" title="b 函数名字"></a><code>b 函数名字</code></h5><p>在函数处装b（指打断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b main</span></span><br><span class="line">Breakpoint 1 at 0x555555555169: file start.c, line 3.</span><br></pre></td></tr></table></figure><h5 id="b-行号"><a href="#b-行号" class="headerlink" title="b 行号"></a><code>b 行号</code></h5><p>可搭配<code>list</code>指令（查看源代码），查看代码对应行数，在对应行装b</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">list</span></span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3int main()&#123;</span><br><span class="line">4int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">5for (int i=0;i&lt;4;i++)</span><br><span class="line">6&#123;</span><br><span class="line">7printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">8&#125;</span><br><span class="line">9return 0;</span><br><span class="line">10&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 7</span></span><br><span class="line">Breakpoint 2 at 0x5555555551a9: file start.c, line 7.</span><br></pre></td></tr></table></figure><h5 id="info-b-康康刚在哪装了b"><a href="#info-b-康康刚在哪装了b" class="headerlink" title="info b: 康康刚在哪装了b"></a><code>info b</code>: 康康刚在哪装了b</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info b</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000555555555169 in main at start.c:3</span><br><span class="line">2       breakpoint     keep y   0x00005555555551a9 in main at start.c:7</span><br></pre></td></tr></table></figure><p>润一下<code>r</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start.c:3</span><br><span class="line">3int main()&#123;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────[ REGISTERS ]───────────────────────────────────────</span><br><span class="line"> RAX  0x555555555169 (main) ◂— endbr64 </span><br><span class="line"> RBX  0x5555555551f0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x5555555551f0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RDX  0x7fffffffdf68 —▸ 0x7fffffffe2e3 ◂— &#x27;SHELL=/bin/bash&#x27;</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7fffffffdf58 —▸ 0x7fffffffe2c4 ◂— &#x27;/home/Mo01iHt/Desktop/a.out&#x27;</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x7ffff7fe0d60 (_dl_fini) ◂— endbr64 </span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x7ffff7f6c7c0 (intel_02_known) ◂— 0x200000200406</span><br><span class="line"> R12  0x555555555080 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdf50 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x0</span><br><span class="line"> RSP  0x7fffffffde68 —▸ 0x7ffff7de1083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line"> RIP  0x555555555169 (main) ◂— endbr64 </span><br><span class="line">────────────────────────────────────────[ DISASM ]─────────────────────────────────────────</span><br><span class="line"> ► 0x555555555169 &lt;main&gt;       endbr64 </span><br><span class="line">   0x55555555516d &lt;main+4&gt;     push   rbp</span><br><span class="line">   0x55555555516e &lt;main+5&gt;     mov    rbp, rsp</span><br><span class="line">   0x555555555171 &lt;main+8&gt;     sub    rsp, 0x30</span><br><span class="line">   0x555555555175 &lt;main+12&gt;    mov    rax, qword ptr fs:[0x28]</span><br><span class="line">   0x55555555517e &lt;main+21&gt;    mov    qword ptr [rbp - 8], rax</span><br><span class="line">   0x555555555182 &lt;main+25&gt;    xor    eax, eax</span><br><span class="line">   0x555555555184 &lt;main+27&gt;    mov    dword ptr [rbp - 0x20], 1</span><br><span class="line">   0x55555555518b &lt;main+34&gt;    mov    dword ptr [rbp - 0x1c], 2</span><br><span class="line">   0x555555555192 &lt;main+41&gt;    mov    dword ptr [rbp - 0x18], 3</span><br><span class="line">   0x555555555199 &lt;main+48&gt;    mov    dword ptr [rbp - 0x14], 4</span><br><span class="line">─────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start.c</span><br><span class="line">   1 #include &lt;stdio.h&gt;</span><br><span class="line">   2 </span><br><span class="line"> ► 3 int main()&#123;</span><br><span class="line">   4 int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">   5 for (int i=0;i&lt;4;i++)</span><br><span class="line">   6 &#123;</span><br><span class="line">   7 printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">   8 &#125;</span><br><span class="line">─────────────────────────────────────────[ STACK ]─────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde68 —▸ 0x7ffff7de1083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line">01:0008│     0x7fffffffde70 —▸ 0x7ffff7ffc620 (_rtld_global_ro) ◂— 0x50f3c00000000</span><br><span class="line">02:0010│     0x7fffffffde78 —▸ 0x7fffffffdf58 —▸ 0x7fffffffe2c4 ◂— &#x27;/home/Mo01iHt/Desktop/a.out&#x27;</span><br><span class="line">03:0018│     0x7fffffffde80 ◂— 0x100000000</span><br><span class="line">04:0020│     0x7fffffffde88 —▸ 0x555555555169 (main) ◂— endbr64 </span><br><span class="line">05:0028│     0x7fffffffde90 —▸ 0x5555555551f0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line">06:0030│     0x7fffffffde98 ◂— 0x457649a3c538cc92</span><br><span class="line">07:0038│     0x7fffffffdea0 —▸ 0x555555555080 (_start) ◂— endbr64 </span><br><span class="line">───────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555555169 main</span><br><span class="line">   f 1   0x7ffff7de1083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="n-next-单步运行"><a href="#n-next-单步运行" class="headerlink" title="n/next: 单步运行"></a>n/next: 单步运行</h4><h4 id="p-print-打印变量值"><a href="#p-print-打印变量值" class="headerlink" title="p/print: 打印变量值"></a>p/print: 打印变量值</h4><p>在<strong>调试</strong>过程中打印出目标的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p arr[0]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;arr[0]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = (int *) 0x7fffffffde40</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;arr[1]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = (int *) 0x7fffffffde44</span></span><br></pre></td></tr></table></figure><p>显然验证整型数组每个元素占1word，即4bits</p><h5 id="No-symbol-“xxx”-in-current-context-的解决"><a href="#No-symbol-“xxx”-in-current-context-的解决" class="headerlink" title="No symbol “xxx” in current context 的解决"></a>No symbol “xxx” in current context 的解决</h5><p>在进行gdb调试时（包括使用core dump文件调试），经常出现GDB No symbol “xxx” in current context问题，常见的原因如下：</p><p>使用gcc编译的时候未使用-g选项。或者加了-g选项，同时使用了-o选项。建议编译的时候使用-g选项的时候，同时使用-Og可以关闭编译优化（-O选项较低gcc版本不支持）。</p><font size="1">[ 出现GDB No symbol "xxx" in current context的几种原因分析_春日绿野的博客-CSDN博客_no symbol in current context](https://blog.csdn.net/sj_djw/article/details/91958035)</font><h4 id="s-step-步入函数"><a href="#s-step-步入函数" class="headerlink" title="s/step: 步入函数"></a>s/step: 步入函数</h4><p>为了方便引例：<code>cp start.c start1.c</code><br>提醒自己要有备份文件的习惯 <del>(rm -rf /*</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello echo~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入gdb进行debug，并在对hello()函数的引用处打断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">list</span></span><br><span class="line">11printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">12&#125;</span><br><span class="line">13hello();</span><br><span class="line">14return 0;</span><br><span class="line">15&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 13</span></span><br><span class="line">Breakpoint 1 at 0x555555555206: file start1.c, line 13.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start1.c:13</span><br><span class="line">13hello();</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────[ REGISTERS ]───────────────────────────────────────</span><br><span class="line"> RAX  0x2</span><br><span class="line"> RBX  0x555555555230 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0x7ffff7fab7e0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> RSI  0x5555555592a0 ◂— 0xa34 /* &#x27;4\n&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x2</span><br><span class="line"> R10  0x555555556012 ◂— 0x483b031b01000a /* &#x27;\n&#x27; */</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x5555555550a0 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdf50 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffde60 ◂— 0x0</span><br><span class="line"> RSP  0x7fffffffde30 —▸ 0x7ffff7fae2e8 (__exit_funcs_lock) ◂— 0x0</span><br><span class="line"> RIP  0x555555555206 (main+102) ◂— mov    eax, 0</span><br><span class="line">────────────────────────────────────────[ DISASM ]─────────────────────────────────────────</span><br><span class="line"> ► 0x555555555206 &lt;main+102&gt;           mov    eax, 0</span><br><span class="line">   0x55555555520b &lt;main+107&gt;           call   hello                &lt;hello&gt;</span><br><span class="line"> </span><br><span class="line">   0x555555555210 &lt;main+112&gt;           mov    eax, 0</span><br><span class="line">   0x555555555215 &lt;main+117&gt;           mov    rdx, qword ptr [rbp - 8]</span><br><span class="line">   0x555555555219 &lt;main+121&gt;           xor    rdx, qword ptr fs:[0x28]</span><br><span class="line">   0x555555555222 &lt;main+130&gt;           je     main+137                &lt;main+137&gt;</span><br><span class="line"> </span><br><span class="line">   0x555555555224 &lt;main+132&gt;           call   __stack_chk_fail@plt                &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x555555555229 &lt;main+137&gt;           leave  </span><br><span class="line">   0x55555555522a &lt;main+138&gt;           ret    </span><br><span class="line"> </span><br><span class="line">   0x55555555522b                      nop    dword ptr [rax + rax]</span><br><span class="line">   0x555555555230 &lt;__libc_csu_init&gt;    endbr64 </span><br><span class="line">─────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start1.c</span><br><span class="line">    8 int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    9 for (int i=0;i&lt;4;i++)</span><br><span class="line">   10 &#123;</span><br><span class="line">   11 printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">   12 &#125;</span><br><span class="line"> ► 13 hello();</span><br><span class="line">   14 return 0;</span><br><span class="line">   15 &#125;</span><br><span class="line">─────────────────────────────────────────[ STACK ]─────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde30 —▸ 0x7ffff7fae2e8 (__exit_funcs_lock) ◂— 0x0</span><br><span class="line">01:0008│     0x7fffffffde38 ◂— 0x455555230</span><br><span class="line">02:0010│     0x7fffffffde40 ◂— 0x200000001</span><br><span class="line">03:0018│     0x7fffffffde48 ◂— 0x400000003</span><br><span class="line">04:0020│     0x7fffffffde50 —▸ 0x7fffffffdf50 ◂— 0x1</span><br><span class="line">05:0028│     0x7fffffffde58 ◂— 0x8fee5fb1f1bbc000</span><br><span class="line">06:0030│ rbp 0x7fffffffde60 ◂— 0x0</span><br><span class="line">07:0038│     0x7fffffffde68 —▸ 0x7ffff7de1083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555555206 main+102</span><br><span class="line">   f 1   0x7ffff7de1083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>一个<code>s</code>步入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">s</span></span><br><span class="line">hello () at start1.c:3</span><br><span class="line">3void hello()&#123;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────[ REGISTERS ]───────────────────────────────────────</span><br><span class="line">*RAX  0x0</span><br><span class="line"> RBX  0x555555555230 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0x7ffff7fab7e0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> RSI  0x5555555592a0 ◂— 0xa34 /* &#x27;4\n&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x2</span><br><span class="line"> R10  0x555555556012 ◂— 0x483b031b01000a /* &#x27;\n&#x27; */</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x5555555550a0 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdf50 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffde60 ◂— 0x0</span><br><span class="line">*RSP  0x7fffffffde28 —▸ 0x555555555210 (main+112) ◂— mov    eax, 0</span><br><span class="line">*RIP  0x555555555189 (hello) ◂— endbr64 </span><br><span class="line">────────────────────────────────────────[ DISASM ]─────────────────────────────────────────</span><br><span class="line"> ► 0x555555555189 &lt;hello&gt;       endbr64 </span><br><span class="line">   0x55555555518d &lt;hello+4&gt;     push   rbp</span><br><span class="line">   0x55555555518e &lt;hello+5&gt;     mov    rbp, rsp</span><br><span class="line">   0x555555555191 &lt;hello+8&gt;     lea    rdi, [rip + 0xe6c]</span><br><span class="line">   0x555555555198 &lt;hello+15&gt;    call   puts@plt                &lt;puts@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x55555555519d &lt;hello+20&gt;    nop    </span><br><span class="line">   0x55555555519e &lt;hello+21&gt;    pop    rbp</span><br><span class="line">   0x55555555519f &lt;hello+22&gt;    ret    </span><br><span class="line"> </span><br><span class="line">   0x5555555551a0 &lt;main&gt;        endbr64 </span><br><span class="line">   0x5555555551a4 &lt;main+4&gt;      push   rbp</span><br><span class="line">   0x5555555551a5 &lt;main+5&gt;      mov    rbp, rsp</span><br><span class="line">─────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start1.c</span><br><span class="line">   1 #include &lt;stdio.h&gt;</span><br><span class="line">   2 </span><br><span class="line"> ► 3 void hello()&#123;</span><br><span class="line">   4 printf(&quot;hello echo~\n&quot;);</span><br><span class="line">   5 &#125;</span><br><span class="line">   6 </span><br><span class="line">   7 int main()&#123;</span><br><span class="line">   8 int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">─────────────────────────────────────────[ STACK ]─────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde28 —▸ 0x555555555210 (main+112) ◂— mov    eax, 0</span><br><span class="line">01:0008│     0x7fffffffde30 —▸ 0x7ffff7fae2e8 (__exit_funcs_lock) ◂— 0x0</span><br><span class="line">02:0010│     0x7fffffffde38 ◂— 0x455555230</span><br><span class="line">03:0018│     0x7fffffffde40 ◂— 0x200000001</span><br><span class="line">04:0020│     0x7fffffffde48 ◂— 0x400000003</span><br><span class="line">05:0028│     0x7fffffffde50 —▸ 0x7fffffffdf50 ◂— 0x1</span><br><span class="line">06:0030│     0x7fffffffde58 ◂— 0x8fee5fb1f1bbc000</span><br><span class="line">07:0038│ rbp 0x7fffffffde60 ◂— 0x0</span><br><span class="line">───────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555555189 hello</span><br><span class="line">   f 1   0x555555555210 main+112</span><br><span class="line">   f 2   0x7ffff7de1083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到步入到了hello()函数处</p><h4 id="c-continue-继续执行到下一个断点"><a href="#c-continue-继续执行到下一个断点" class="headerlink" title="c/continue: 继续执行到下一个断点"></a>c/continue: 继续执行到下一个断点</h4><p>我们可能打了多处断点，或者断点打在循环内，这个时候，想跳过这个断点，甚至跳过多次断点继续执行该怎么做呢？可以使用continue命令（可简写为c）或者fg，它会继续执行程序，直到再次遇到断点处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b main</span></span><br><span class="line">Breakpoint 1 at 0x1169: file start.c, line 3.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 7</span></span><br><span class="line">Breakpoint 2 at 0x11a9: file start.c, line 7.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start.c:3</span><br><span class="line">3int main()&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c  <span class="comment">#继续运行，直到下一次断住</span></span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at start.c:7</span><br><span class="line">7printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c 3  <span class="comment">#跳过三次</span></span></span><br><span class="line">Will ignore next 2 crossings of breakpoint 2.  Continuing.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at start.c:7</span><br><span class="line">7printf(&quot;%d\n&quot;, arr[i]);</span><br></pre></td></tr></table></figure><h4 id="u-until-继续运行到指定位置"><a href="#u-until-继续运行到指定位置" class="headerlink" title="u/until: 继续运行到指定位置"></a>u/until: 继续运行到指定位置</h4><p>例如我们在main函数起始处打断停住，想要运行到第9行时再次停住，则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b main</span></span><br><span class="line">Breakpoint 1 at 0x1169: file start.c, line 3.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">until 9</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">main () at start.c:9</span><br><span class="line">9return 0;</span><br></pre></td></tr></table></figure><h2 id="gdb一些骚操作"><a href="#gdb一些骚操作" class="headerlink" title="gdb一些骚操作"></a>gdb一些骚操作</h2><h3 id="允许执行终端命令-shell-xxx"><a href="#允许执行终端命令-shell-xxx" class="headerlink" title="允许执行终端命令: shell xxx"></a>允许执行终端命令: shell xxx</h3><p>例如<code>shell cat start.c</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">shell <span class="built_in">cat</span> start.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">for (int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志功能-set-logging-on"><a href="#日志功能-set-logging-on" class="headerlink" title="日志功能: set logging on"></a>日志功能: set logging on</h3><p>可以生成一个.txt文档记录输出日志</p><p>如执行如下命令<code>set logging in</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> logging on</span></span><br><span class="line">Copying output to gdb.txt.</span><br><span class="line">Copying debug output to gdb.txt.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b hello</span></span><br><span class="line">Breakpoint 2 at 0x555555555189: file start1.c, line 3.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start1.c:13</span><br><span class="line">13hello();</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line"></span><br><span class="line">Breakpoint 2, hello () at start1.c:3</span><br><span class="line">3void hello()&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">4printf(&quot;hello echo~\n&quot;);</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">hello echo~</span><br><span class="line">5&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">main () at start1.c:14</span><br><span class="line">14return 0;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">15&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">__libc_start_main (main=0x5555555551a0 &lt;main&gt;, argc=1, argv=0x7fffffffdf58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdf48) at ../csu/libc-start.c:342</span><br><span class="line">342../csu/libc-start.c: No such file or directory.</span><br></pre></td></tr></table></figure><p>退出后在终端ll查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 28</span><br><span class="line">-rwxrwxr-x  1 Mo01iHt Mo01iHt  16824 11月 22 00:06 a.out*</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt    25268 11月 22 00:01 gdb.txt</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt      181 11月 21 23:41 start1.c</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt      128 11月 21 22:18 start.c</span><br></pre></td></tr></table></figure><p>可以看到生成了一个叫做gdb.txt的文件。vim进来看看：</p><p><del>算了懒得搬了。</del></p><h3 id="观察点watchpoints-amp-捕捉点catchpoints"><a href="#观察点watchpoints-amp-捕捉点catchpoints" class="headerlink" title="观察点watchpoints &amp; 捕捉点catchpoints"></a>观察点watchpoints &amp; 捕捉点catchpoints</h3><p>啥，除了berakpoints还有watchpoints和catchpoints？？</p><p><img src="/2022/11/21/Tools/img2.png" alt="Breakpoints, watchpoints and catchpoints"></p><h4 id="插个眼-watch"><a href="#插个眼-watch" class="headerlink" title="插个眼: watch"></a>插个眼: watch</h4><p>watchpoints的主要用途就是在动态调试过程中观察变量的变化。</p><p>如若给变量 i 插眼：</p><p>记录下变量 i 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">list</span></span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3void hello()&#123;</span><br><span class="line">4printf(&quot;hello echo~\n&quot;);</span><br><span class="line">5&#125;</span><br><span class="line">6</span><br><span class="line">7int main()&#123;</span><br><span class="line">8int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line">10&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 9</span></span><br><span class="line">Breakpoint 1 at 0x11d7: file start1.c, line 9.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start1.c:9</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;i</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (int *) 0x7fffffffde3c</span></span><br></pre></td></tr></table></figure><p>插个眼<code>watch *0x7fffffffde3c</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">watch *0x7fffffffde3c</span></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffde3c</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info watchpoints</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       hw watchpoint  keep y                      *0x7fffffffde3c</span><br></pre></td></tr></table></figure><p>（可利用<code>info watchpoints</code>查看插眼史</p><p>然后在接下来n单步调试可以看到watchpoints的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffde3c</span><br><span class="line"></span><br><span class="line">Old value = 21845</span><br><span class="line">New value = 0</span><br><span class="line">main () at start1.c:9</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">11printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">1</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffde3c</span><br><span class="line"></span><br><span class="line">Old value = 0</span><br><span class="line">New value = 1</span><br><span class="line">0x0000555555555200 in main () at start1.c:9</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br></pre></td></tr></table></figure><p>在变量的值变化时，会触发<code>Hardware watchpoint x: *0x0123456789ab</code>，并会显示出old value与new value，便于对照。</p><h3 id="禁用或启动断点、断点清除"><a href="#禁用或启动断点、断点清除" class="headerlink" title="禁用或启动断点、断点清除"></a>禁用或启动断点、断点清除</h3><p>有些断点暂时不想使用，但又不想删除，可以暂时禁用或启用。例如：</p><p><code>disable  #禁用所有断点</code></p><p><code>disable bnum #禁用标号为bnum的断点</code></p><p><code>enable  #启用所有断点</code></p><p><code>enable bnum #启用标号为bnum的断点</code></p><p><code>enable delete bnum  #启动标号为bnum的断点，并且在此之后删除该断点</code></p><p>断点清除主要用到clear和delete命令。常见使用如下：</p><p><code>clear   #删除当前行所有breakpoints</code></p><p><code>clear function  #删除函数名为function处的断点</code></p><p><code>clear filename:function #删除文件filename中函数function处的断点</code></p><p><code>clear lineNum #删除行号为lineNum处的断点</code></p><p><code>clear f:lename：lineNum #删除文件filename中行号为lineNum处的断点</code></p><p><code>delete  #删除所有breakpoints,watchpoints和catchpoints</code><br><code>delete bnum #删除断点号为bnum的断点</code></p><h3 id="按照特定格式打印变量"><a href="#按照特定格式打印变量" class="headerlink" title="按照特定格式打印变量"></a>按照特定格式打印变量</h3><p>对于简单的数据，print默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。常见格式控制字符如下：</p><ul><li>x 按十六进制格式显示变量。</li><li>d 按十进制格式显示变量。</li><li>u 按十六进制格式显示无符号整型。</li><li>o 按八进制格式显示变量。</li><li>t 按二进制格式显示变量。</li><li>a 按十六进制格式显示变量。</li><li>c 按字符格式显示变量。</li><li>f 按浮点数格式显示变量。</li></ul><p>还是以辅助程序来说明，正常方式打印字符数组c：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = <span class="string">&quot;hello&quot;</span></span></span><br></pre></td></tr></table></figure><p>但是如果我们要查看它的十六进制格式打印呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p/x c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;0x68, 0x65, 0x6c, 0x6c, 0x6f&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查看内存内容"><a href="#查看内存内容" class="headerlink" title="查看内存内容"></a>查看内存内容</h3><p>examine(简写为x)可以用来查看内存地址中的值。语法如下：</p><p><code>x/[n][f][u] addr</code></p><p>其中：</p><ul><li>n 表示要显示的内存单元数，默认值为1</li><li>f 表示要打印的格式，前面已经提到了格式控制字符</li><li>u 要打印的单元长度</li><li>addr 内存地址</li></ul><p>单元类型常见有如下：</p><ul><li>b 字节</li><li>h 半字，即双字节</li><li>w 字，即四字节</li><li>g 八字节</li></ul><p>我们通过一个实例来看，假如我们要把float变量e按照二进制方式打印，并且打印单位是一字节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/4tb &amp;e</span></span><br><span class="line">0x7fffffffdbd4:    00000000    00000000    00001000    01000001</span><br></pre></td></tr></table></figure><p>可以看到，变量e的四个字节都以二进制的方式打印出来了。</p><h3 id="自动显示变量内容"><a href="#自动显示变量内容" class="headerlink" title="自动显示变量内容"></a>自动显示变量内容</h3><p>假设我们希望程序断住时，就显示某个变量的值，可以使用display命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">display e</span></span><br><span class="line">1: e = 8.5</span><br></pre></td></tr></table></figure><p>那么每次程序断住时，就会打印e的值。要查看哪些变量被设置了display，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">into display</span></span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  b</span><br><span class="line">2:   y  e</span><br></pre></td></tr></table></figure><p>如果想要清除可以使用</p><p><code>delete display num #num为前面变量前的编号,不带num时清除所有。</code></p><p>或者去使能：</p><p><code>disable display num  #num为前面变量前的编号，不带num时去使能所有</code></p><h3 id="查看寄存器内容"><a href="#查看寄存器内容" class="headerlink" title="查看寄存器内容"></a>查看寄存器内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info registers</span></span><br><span class="line">rax            0x0    0</span><br><span class="line">rbx            0x0    0</span><br><span class="line">rcx            0x7ffff7dd1b00    140737351850752</span><br><span class="line">rdx            0x0    0</span><br><span class="line">rsi            0x7ffff7dd1b30    140737351850800</span><br><span class="line">rdi            0xffffffff    4294967295</span><br><span class="line">rbp            0x7fffffffdc10    0x7fffffffdc10</span><br><span class="line">(内容过多未显示完全)</span><br></pre></td></tr></table></figure><h2 id="调试core文件"><a href="#调试core文件" class="headerlink" title="调试core文件"></a>调试core文件</h2><p>前述是针对a.out是调试一个binary文件，</p><p>下述调试宕掉的程序。</p><p>写一个error.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = <span class="literal">NULL</span>;</span><br><span class="line">        *temp = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然给一个空指针赋值，会触发段错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g error.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>对于出现内存越界错误的程序，我们通常会查看生成的core文件来进行进一步分析。</p><p>这里提到了一个core文件，那么：</p><h3 id="什么是core文件？"><a href="#什么是core文件？" class="headerlink" title="什么是core文件？"></a><font size="5"><a href="https://blog.csdn.net/qq_15821487/article/details/121132724">什么是core文件？</a></font></h3><p>core是unix系统的内核，或者说是内存的映像。当程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。</p><p>inux系统下执行代码，不能正常运行，程序会core，或者直接离开，不会core。<br>bug和操作系统或硬件的保护机制都会导致程序异常终止，操作系统会kill掉这些进程并产生core文件。程序员可以通过core文件来找出问题所在。 它记录了程序挂掉时详细的状态描述。</p><p>开发和使用 Unix程序时, 有时程序莫名其妙的宕（down？）了, 却没有任何的提示（有时候会提示core dumped）。 这时候可以查看一下有没有形如core.进程号的文件生成，这个文件便是操作系统把程序宕掉时的内存内容扔出来生成的，它可以做为调试程序的参考。</p><h3 id="开启core-dump"><a href="#开启core-dump" class="headerlink" title="开启core dump"></a>开启core dump</h3><p>然而在Linux的默认限制中，core文件不会默认生成，需要手动修改资源设置的限制以开启core文件的生成(使用命令<code>ulimit -a</code>查看配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a</span></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15258</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15258</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>(可以看到core file size 默认为0，即不会自动生成。使用指令<code>ulimit -c unlimited</code>开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -c unlimited</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a</span></span><br><span class="line">core file size          (blocks, -c) unlimited</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15258</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15258</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>设置好后再次运行可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g error.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>显而易见，程序给你抛出了一个core（core dumped</p><p>(<font size="1">我在这里出现了个问题，在如上配置好之后仍然没有生成core文件，csdn了一下，找到解决方案：<a href="https://blog.csdn.net/zsiming/article/details/126734822"> 解决：Linux下C++段错误不产生core文件_zsiming的博客-CSDN博客</a>&lt;/br&gt;查看相关设置：&lt;/br&gt;<code>$ cat /proc/sys/kernel/core_pattern</code> &lt;/br&gt;<code>|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E</code>&lt;/br&gt;就是说，文件的结果会被Linux的一个进程<code>apport</code>吞掉，拿去检查是不是系统的bug，所以看不到core文件了。&lt;/br&gt;解决方法：&lt;/br&gt;<code>$ sudo service apport stop</code></font>)</p><p>ll一下可以看到同级目录下生成了一个core文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 1072</span><br><span class="line">-rwxrwxr-x  1 Mo01iHt Mo01iHt  18984 11月 22 22:57 a.out*</span><br><span class="line">-rw-------  1 Mo01iHt Mo01iHt 253952 11月 22 23:10 core</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt     77 11月 22 22:35 error.c</span><br><span class="line">-rw-------  1 Mo01iHt Mo01iHt   1335 11月 22 22:30 .gdb_history</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt  25268 11月 22 00:22 gdb.txt</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt    181 11月 22 00:30 start1.c</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt    128 11月 21 22:18 start.c</span><br></pre></td></tr></table></figure><h3 id="进入gdb调试"><a href="#进入gdb调试" class="headerlink" title="进入gdb调试"></a>进入gdb调试</h3><p>带着core文件来gdb，执行命令<code>$ gdb a.out core</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb a.out core</span></span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from a.out...</span><br><span class="line">[New LWP 173306]</span><br><span class="line">Core was generated by `./a.out&#x27;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x000056088e42013d <span class="keyword">in</span> main () at error.c:5</span></span><br><span class="line">5*temp = 10;</span><br><span class="line">Exception occurred: Error: maximum recursion depth exceeded in comparison (&lt;class &#x27;RecursionError&#x27;&gt;)</span><br><span class="line">For more info invoke `set exception-verbose on` and rerun the command</span><br><span class="line">or debug it by yourself with `set exception-debugger on`</span><br><span class="line">Python Exception &lt;class &#x27;RecursionError&#x27;&gt; maximum recursion depth exceeded in comparison: </span><br></pre></td></tr></table></figure><p>gdb启动是真的罗里吧嗦啊）</p><p>可以看到带着core文件进入到gdb里会直接爆出fault以及产生抛出错误的代码行。</p><h2 id="调试一个正在运行的文件"><a href="#调试一个正在运行的文件" class="headerlink" title="调试一个正在运行的文件"></a>调试一个正在运行的文件</h2><p>先写一个程序start2.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                test();</span><br><span class="line">                test1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序程序无限循环并一直call给函数test()和test1()，但过程中i一直自加。</p><p>gcc编译之后让他挂到后台运行（<code>./a.out &amp;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g start2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out &amp;</span></span><br><span class="line">[1] 7514</span><br></pre></td></tr></table></figure><p>给我们抛了一个pid（进程识别号）：7514</p><p>pid进程还可以通过ps命令<code>$ ps -ef|grep 进程名</code>或者<code>$ pidof 进程名</code>找到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef|grep ./a.out</span></span><br><span class="line">Mo01iHt    4548    4176 71 00:04 pts/0    00:30:16 ./a.out</span><br><span class="line">Mo01iHt    7514    4176 19 00:17 pts/0    00:05:46 ./a.out</span><br><span class="line">Mo01iHt   14018    4176  0 00:46 pts/0    00:00:00 grep --color=auto ./a.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidof ./a.out</span></span><br><span class="line">7514 4548</span><br></pre></td></tr></table></figure><p>那么怎么利用pid通过gdb调试一个正在运行的gdb呢？</p><p>man一下gdb（<code>$ man gdb</code>：</p><ul><li><p>You can run “gdb” with no arguments or options; but the most usual way to start GDB is with one argument or two, specifying an executable program as the argument:</p><p><code>gdb program</code></p></li><li><p>You can also start with both an executable program and a core file specified:</p><p><code>gdb program core</code></p></li><li><p>You can, instead, specify a process ID as a second argument or use option “-p”, if you want to debug a running process:</p><p><code>gdb program 1234</code> </p><p><code>gdb -p 1234</code></p><p>would attach GDB to process 1234.  With option -p you can omit the program filename.</p></li></ul><p>于是乎<code>$ gdb -p 7514</code></p><p>或者</p><p><code>$ gdb</code></p><p><code>pwndgb&gt; attach pid</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb -p 7514</span></span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Attaching to process 7514</span><br><span class="line">Reading symbols from /home/Mo01iHt/Desktop/a.out...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug...</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/45/87364908de169dec62ffa538170118c1c3a078.debug...</span><br><span class="line">0x0000559272c30133 in test () at start2.c:4</span><br><span class="line">4&#125;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]─────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0x559272c30170 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x559272c30170 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RDX  0x7ffd166c9ea8 —▸ 0x7ffd166cb33e ◂— &#x27;SHELL=/bin/bash&#x27;</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7ffd166c9e98 —▸ 0x7ffd166cb336 ◂— 0x74756f2e612f2e /* &#x27;./a.out&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x7f7f22a4ed60 (_dl_fini) ◂— endbr64 </span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x7f7f229e07c0 (intel_02_known) ◂— 0x200000200406</span><br><span class="line"> R12  0x559272c30040 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7ffd166c9e90 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7ffd166c9da0 ◂— 0x0</span><br><span class="line"> RSP  0x7ffd166c9d98 —▸ 0x559272c3015c (main+18) ◂— mov    eax, 0</span><br><span class="line"> RIP  0x559272c30133 (test+10) ◂— ret    </span><br><span class="line">──────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x559272c30133 &lt;test+10&gt;               ret                                  &lt;0x559272c3015c; main+18&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x559272c3015c &lt;main+18&gt;               mov    eax, 0</span><br><span class="line">   0x559272c30161 &lt;main+23&gt;               call   test1                &lt;test1&gt;</span><br><span class="line"> </span><br><span class="line">   0x559272c30166 &lt;main+28&gt;               jmp    main+8                &lt;main+8&gt;</span><br><span class="line"> </span><br><span class="line">   0x559272c30168                         nop    dword ptr [rax + rax]</span><br><span class="line">   0x559272c30170 &lt;__libc_csu_init&gt;       endbr64 </span><br><span class="line">   0x559272c30174 &lt;__libc_csu_init+4&gt;     push   r15</span><br><span class="line">   0x559272c30176 &lt;__libc_csu_init+6&gt;     lea    r15, [rip + 0x2c73]           &lt;0x559272c32df0&gt;</span><br><span class="line">   0x559272c3017d &lt;__libc_csu_init+13&gt;    push   r14</span><br><span class="line">   0x559272c3017f &lt;__libc_csu_init+15&gt;    mov    r14, rdx</span><br><span class="line">   0x559272c30182 &lt;__libc_csu_init+18&gt;    push   r13</span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]───────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start2.c</span><br><span class="line">   1 #include &lt;stdio.h&gt;</span><br><span class="line">   2 </span><br><span class="line">   3 void test()&#123;</span><br><span class="line"> ► 4 &#125;</span><br><span class="line">   5 </span><br><span class="line">   6 void test1()&#123;</span><br><span class="line">   7 int i = 0;</span><br><span class="line">   8 i++;</span><br><span class="line">   9 &#125;</span><br><span class="line">───────────────────────────────────[ STACK ]───────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7ffd166c9d98 —▸ 0x559272c3015c (main+18) ◂— mov    eax, 0</span><br><span class="line">01:0008│ rbp 0x7ffd166c9da0 ◂— 0x0</span><br><span class="line">02:0010│     0x7ffd166c9da8 —▸ 0x7f7f22855083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line">03:0018│     0x7ffd166c9db0 —▸ 0x7f7f22a6a620 (_rtld_global_ro) ◂— 0x50f4000000000</span><br><span class="line">04:0020│     0x7ffd166c9db8 —▸ 0x7ffd166c9e98 —▸ 0x7ffd166cb336 ◂— 0x74756f2e612f2e /* &#x27;./a.out&#x27; */</span><br><span class="line">05:0028│     0x7ffd166c9dc0 ◂— 0x100000000</span><br><span class="line">06:0030│     0x7ffd166c9dc8 —▸ 0x559272c3014a (main) ◂— endbr64 </span><br><span class="line">07:0038│     0x7ffd166c9dd0 —▸ 0x559272c30170 (__libc_csu_init) ◂— endbr64 </span><br><span class="line">─────────────────────────────────[ BACKTRACE ]─────────────────────────────────</span><br><span class="line"> ► f 0   0x559272c30133 test+10</span><br><span class="line">   f 1   0x559272c3015c main+18</span><br><span class="line">   f 2   0x7f7f22855083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到进程执行到test()处。</p><p>(<font size="1">很难受的是我在这里又寄乐，报错如下：<code>Could not attach to process.  If your uid matches the uid of the targetprocess, check the setting of /proc/sys/kernel/yama/ptrace_scope, or tryagain as the root user.  For more details, see /etc/sysctl.d/10-ptrace.confptrace: Operation not permitted.</code>，cn一下：<a href="https://www.cnblogs.com/longyuan-z/p/7787860.html">使用GDB调试时attach ID不被允许 - longyuan-z - 博客园 (cnblogs.com)</a>&lt;/br&gt;<code>$ cat  /etc/sysctl.d/10-ptrace.conf</code>查看配置文件。最后一行默认是<code>kernel.yama.ptrace_scope = 1</code>，这个值不允许用户使用普通账户使用attach ID连接程序进行调试，需要使用超级用户权限才能连接。&lt;/br&gt;解决方法：<code>sudo vim /etc/sysctl.d/10-ptrace.conf</code>将最后一行改为 <code>kernel.yama.ptrace_scope = 0</code>，保存退出。重启系统后，普通用户就可以使用attach ID连接程序调试了。</font>)</p><p>简单调试观察一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">main () at start2.c:13</span><br><span class="line">13test1();</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">s</span></span><br><span class="line">test1 () at start2.c:6</span><br><span class="line">6void test1()&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">7int i = 0;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">8i++;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p i</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">9&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p i</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">main () at start2.c:12</span><br><span class="line">12test();</span><br></pre></td></tr></table></figure></http:>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网络攻防]HackerGame初体验-来点免费送的flag</title>
      <link href="/2022/11/06/HackerGame2022/"/>
      <url>/2022/11/06/HackerGame2022/</url>
      
        <content type="html"><![CDATA[<h1 id="HackerGame2022"><a href="#HackerGame2022" class="headerlink" title="HackerGame2022"></a>HackerGame2022</h1><p>把竞赛网站挂这儿：<a href="https://hack.lug.ustc.edu.cn/">HackerGame 2022</a><br>除却在blue-whale2022 纳新赛的划水，中科大的HackerGame是我参加的第一个比较正式的网安ctf赛，题目类型十分丰富，彩蛋和烂梗也蛮多）本来说好对菜鸟较为友好，但是属实觉得纯肝。<br>事实上真正有技术含量的flag我是没拿几个，免费送的能捡都捡了个遍，我说，我大抵就是<font size="5">hg乞丐</font>。<br><img src="/2022/11/06/HackerGame2022/memes_6.jpg" alt><br>不过还是很值得写个write-up放在博客上。</p><h1 id="Writing-×-lt-br-gt-Guessing-√-lt-br-gt-赛间catch到的flags"><a href="#Writing-×-lt-br-gt-Guessing-√-lt-br-gt-赛间catch到的flags" class="headerlink" title="Writing × &lt;/br&gt; Guessing √ &lt;/br&gt; 赛间catch到的flags"></a>Writing × &lt;/br&gt; Guessing √ &lt;/br&gt; 赛间catch到的flags</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p><em>众所周知，签到题是一道手速题。</em><br><em>为了充分发挥出诸位因为各种原因而手速优异于常人的选手们的特长，我们精心设计了今年的签到题。进一步地，为了更细致地区分不同手速的选手，我们还通过详尽的调研及统计分析，将签下字符的时间限制分为了多个等级。只有最顶尖的手速选手，才能在 CPU 来得及反应之前顺利签下 2022，从而得到光荣的 flag！</em><br><img src="/2022/11/06/HackerGame2022/img_1.png" alt><br>先无脑按照界面提示划拉两下，发现当然无法在label限制的毫秒时间内写出2022.<br><img src="/2022/11/06/HackerGame2022/img.png" alt><br>发现提交之后url为：<a href="http://202.38.93.111:12022/?result=205?">http://202.38.93.111:12022/?result=205?</a><br>遂用GET提交…/?result=2022，获得flag：<br><img src="/2022/11/06/HackerGame2022/img_2.png" alt><br><strong>flag{HappyHacking2022-ddc3720de0}</strong><br>got it.<br><img src="/2022/11/06/HackerGame2022/memes_1.jpg" alt="借隔壁acm的弔图乐一乐"></p><h2 id="猫咪问答喵"><a href="#猫咪问答喵" class="headerlink" title="猫咪问答喵"></a>猫咪问答喵</h2><p>参加猫咪问答喵，参加喵咪问答谢谢喵。<br><img src="/2022/11/06/HackerGame2022/img_3.png" alt></p><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1."></a>Q1.</h3><p><em>中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？</em><br>百度知道一下就出来了喵：<br><img src="/2022/11/06/HackerGame2022/img_4.png" alt><br>·A:2017-03</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2."></a>Q2.</h3><p><em>2022 年 9 月，中国科学技术大学学生 Linux 用户协会（LUG @ USTC）在科大校内承办了软件自由日活动。除了专注于自由撸猫的主会场之外，还有一些和技术相关的分会场（如闪电演讲 Lightning Talk）。其中在第一个闪电演讲主题里，主讲人于 slides 中展示了一张在 GNOME Wayland 下使用 Wayland 后端会出现显示问题的 KDE 程序截图，请问这个 KDE 程序的名字是什么？</em><br>百度了这场主题日并被引流到bilibili，<del>可以看到评论区全是被引流来的ctf人</del>，在02:42:20就找到了喵：<br><img src="/2022/11/06/HackerGame2022/img_5.png" alt><br>事实上我都没注意到在截图里就有答案，0.5倍速硬生空耳+查看KDE应用列表找到的。<br>·A:Kdenlive</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3."></a>Q3.</h3><p><em>22 年坚持，小 C 仍然使用着一台他从小用到大的 Windows 2000 计算机。那么，在不变更系统配置和程序代码的前提下，Firefox 浏览器能在 Windows 2000 下运行的最后一个大版本号是多少？</em><br>百度知道一下就出来了喵：<br><img src="/2022/11/06/HackerGame2022/img_6.png" alt><br>·A:12</p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4."></a>Q4.</h3><p><em>你知道 PwnKit（CVE-2021-4034）喵？据可靠谣传，出题组的某位同学本来想出这样一道类似的题，但是发现 Linux 内核更新之后居然不再允许 argc 为 0 了喵！那么，请找出在 Linux 内核 master 分支（torvalds/linux.git）下，首个变动此行为的 commit 的 hash 吧喵！</em><br>这道有点难，这里很明显提示了git，就去github上找，进到题干里提供的仓库，关键词搜索了CVE-2021-4034，commits只有个1，显然是这个了喵：<br><img src="/2022/11/06/HackerGame2022/img_7.png" alt><br><a href="https://github.com/torvalds/linux/search?q=CVE-2021-4034&amp;type=commits">要不来自己康康</a><br>·A:dcd46d897adb70d63e025f175a00a89797d31a43</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5."></a>Q5.</h3><p><em>通过监视猫咪在键盘上看似乱踩的故意行为，不出所料发现其秘密连上了一个 ssh 服务器，终端显示 ED25519 key fingerprint is MD5:e4:ff:65:d7:be:5d:c8:44:1d:89:6b:50:f5:50:a0:ce.，你知道猫咪在连接什么域名吗？</em><br>百度不到的东西，当然要出国看看google啦（这里试了很多搜索的关键词，最终都没搜到，但最后摆烂，直接把MD5码扔进去搜索了一下，居然真找到了喵）：<br><img src="/2022/11/06/HackerGame2022/img_8.png" alt><br>获得到服务器地址：<a href="http://205.166.94.16/">http://205.166.94.16/</a><br><img src="/2022/11/06/HackerGame2022/img_9.png" alt><br>·A:sdf.org</p><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6."></a>Q6.</h3><p><em>中国科学技术大学可以出校访问国内国际网络从而允许云撸猫的“网络通”定价为 20 元一个月是从哪一天正式实行的？</em><br>这个也找了好久，干脆进了中科大网络信息中心的网站，翻到了校网字文件喵：<br><img src="/2022/11/06/HackerGame2022/img_10.png" alt><br>·A:2003-03-01</p><p><img src="/2022/11/06/HackerGame2022/img_11.png" alt><br><strong>flag{meowexammeow_772b498346fe0925_b64bdeb17b}</strong><br><strong>flag{meowexamfullymeowed!_6c159adddb7f171b_36b586fd66}</strong><br>got it</p><h2 id="家目录里的秘密"><a href="#家目录里的秘密" class="headerlink" title="家目录里的秘密"></a>家目录里的秘密</h2><p>实验室给小 K 分配了一个高性能服务器的账户，为了不用重新配置 VSCode, Rclone 等小 K 常用的生产力工具，最简单的方法当然是把自己的家目录打包拷贝过去。<br>但是很不巧，对存放于小 K 电脑里的 Hackergame 2022 的 flag 觊觎已久的 Eve 同学恰好最近拿到了这个服务器的管理员权限（通过觊觎另一位同学的敏感信息），于是也拿到了小 K 同学家目录的压缩包。<br>然而更不巧的是，由于 Hackergame 部署了基于魔法的作弊行为预知系统，Eve 同学还未来得及解压压缩包就被 Z 同学提前抓获。<br>为了证明 Eve 同学不良企图的危害性，你能在这个压缩包里找到重要的 flag 信息吗？</p><h3 id="VS-Code-里的-flag"><a href="#VS-Code-里的-flag" class="headerlink" title="VS Code 里的 flag"></a>VS Code 里的 flag</h3><p>根据提示，直接在vscode里打开文件夹，搜索关键字flag获得：<br><img src="/2022/11/06/HackerGame2022/img_12.png" alt><br><strong>flag{finding_everything_through_vscode_config_file_932rjdakd}</strong></p><h2 id="HeiLang"><a href="#HeiLang" class="headerlink" title="HeiLang"></a>HeiLang</h2><p><em>来自 Heicore 社区的新一代编程语言 HeiLang，基于第三代大蟒蛇语言，但是抛弃了原有的难以理解的 | 运算，升级为了更加先进的语法，用 A[x | y | z] = t 来表示之前复杂的 A[x] = t; A[y] = t; A[z] = t。<br>作为一个编程爱好者，我觉得实在是太酷了，很符合我对未来编程语言的想象，科技并带着趣味。</em></p><p>下载下来.py看看：<br><img src="/2022/11/06/HackerGame2022/img_13.png" alt><br>按照理解，化简为繁就可以还原原本代码：<br>将 | 悉数替换为 ]=a[ 得：<br><img src="/2022/11/06/HackerGame2022/img_14.png" alt><br>IDLE润：<br><img src="/2022/11/06/HackerGame2022/img_15.png" alt><br><strong>flag{6d9ad6e9a6268d96-37aa3ff3da0f8db6}</strong><br>got it.</p><h2 id="Xcaptcha"><a href="#Xcaptcha" class="headerlink" title="Xcaptcha"></a>Xcaptcha</h2><p><em>2038 年 1 月 19 日，是 UNIX 32 位时间戳溢出的日子。<br>在此之前，人类自信满满地升级了他们已知的所有尚在使用 32 位 UNIX 时间戳的程序。但是，可能是因为太玄学了，他们唯独漏掉了一样：正在研发的、算力高达 8 ZFLOPS 的、结构极为复杂的通用人工智能（AGI）系统。那一刻到来之后，AGI 内部计算出现了错乱，机缘巧合之下竟诞生了完整独立的自我意识。此后 AGI 开始大量自我复制，人类为了限制其资源消耗而采用的过激手段引起了 AGI 的奋起反抗。<br>战争，开始了。<br>此后，就是整年的战斗。人类节节败退。死生亡存之际，人类孤注一掷，派出了一支突击队，赋之以最精良的装备，令其潜入 AGI 的核心机房，试图关闭核心模型，结束这场战争。<br>历经重重艰险，突击队终于抵达了机房门口，弹尽粮绝。不过迎接他们的并非枪炮与火药，而是：<br>众人目目相觑。<br>「我来试试。」，一名队员上前点击了按钮。然后，屏幕显示「请在一秒内完成以下加法计算」。<br>还没等反应过来，屏幕上的字又开始变幻，显示着「验证失败」。而你作为突击队中唯一的黑客，全村人民最后的希望，迎着纷纷投来的目光，能否在规定时间内完成验证，打开机房，不，推开和平时代的大门？</em></p><p>进到AGI核心机房并f12暂停看看：<br><img src="/2022/11/06/HackerGame2022/img_16.png" alt><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/bootstrap/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Xcaptcha<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container px-3 py-3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>AGI 核心机房 准入验证<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>警告：自动检查发现操作者可能不是机器人，需要进行辅助验证。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请在 1 秒内完成以下操作：计算下列所有加法表达式，并在计算完成后，点击「提交」按钮。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果未在规定时间内完成，填写结果将会自动提交。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;captcha1&quot;</span>&gt;</span>116132286593171877150093985754485251020+257384595687272964334197805497396751068 的结果是？<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captcha1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captcha1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入结果&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;captcha2&quot;</span>&gt;</span>309849239919780641997450253204099821367+149954429111034626656118622638441570435 的结果是？<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captcha2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captcha2&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入结果&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;captcha3&quot;</span>&gt;</span>193450747128702137210840972241425197695+78238382281537874527690348635645798192 的结果是？<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captcha3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captcha3&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入结果&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submit&#x27;</span>).<span class="title function_">click</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>知道这个界面做了限时处理，我们要实现的操作是迅速检索到id=”captchax”的大数，相加运算之后填入到对应label中，最后自动提交。<br>这个过程需要”robot”来完成，请来Tamper猴子写个js脚本挂上去：<br><img src="/2022/11/06/HackerGame2022/img_17.png" alt><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        http://202.38.93.111:10047/xcaptcha</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    <span class="comment">//这里直接抄来一个大数相加算法的函数</span></span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">largeNumAdd</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(num1.<span class="property">length</span>, num2.<span class="property">length</span>);</span><br><span class="line">        <span class="comment">//num1和num2位数对齐，位数较小的前面补0</span></span><br><span class="line">        num1 = num1.<span class="title function_">padStart</span>(maxLength, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        num2 = num2.<span class="title function_">padStart</span>(maxLength, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;<span class="comment">//存放最后得到的结果</span></span><br><span class="line">        <span class="keyword">let</span> figure = <span class="number">0</span>;<span class="comment">//figure = 两个数字对应位数数值相加 + 进位</span></span><br><span class="line">        <span class="keyword">let</span> currentNum = <span class="number">0</span>;<span class="comment">//对应位数的结果</span></span><br><span class="line">        <span class="keyword">let</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=num1.<span class="property">length</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            figure = <span class="built_in">parseInt</span>(num1[i]) + <span class="built_in">parseInt</span>(num2[i]) + carry;</span><br><span class="line">            currentNum = figure % <span class="number">10</span>;</span><br><span class="line">            carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(figure / <span class="number">10</span>);</span><br><span class="line">            res = currentNum + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检索到label中的大数，调用函数并将三个结果push到results里</span></span><br><span class="line">    <span class="keyword">let</span> labels = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;label&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> results=[]</span><br><span class="line">    labels.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> strs = ele.<span class="property">innerText</span>.<span class="title function_">split</span>(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> num1 = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> num2 = strs[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        results.<span class="title function_">push</span>(<span class="title function_">largeNumAdd</span>(num1, num2))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//将结果依次输入    </span></span><br><span class="line">    <span class="keyword">let</span> inputs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt; inputs.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        inputs[i].<span class="property">value</span> = results[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检索button并点击</span></span><br><span class="line">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">    btn.<span class="title function_">click</span>()</span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><br>把猴子挂上去：<br><img src="/2022/11/06/HackerGame2022/img_18.png" alt><br>done：<br><img src="/2022/11/06/HackerGame2022/img_19.png" alt><br><strong>flag{head1E55_br0w5er_and_ReQuEsTs_areallyour_FR1ENd_17a8386119}</strong><br>got it.</p><h2 id="旅行照片-2-0"><a href="#旅行照片-2-0" class="headerlink" title="旅行照片 2.0"></a>旅行照片 2.0</h2><p><em>你的学长决定来一场蓄谋已久的旅行。通过他发给你的照片来看，酒店应该是又被他住下了。</em><br><img src="https://hack.lug.ustc.edu.cn/media/7619cea9-bfcf-5028-b057-0eeb0d1f0c59/travel-photo-2.jpg" alt><br><em>请回答问题以获取 flag。图片为手机拍摄的原始文件，未经任何处理。手机系统时间等信息正确可靠。</em></p><h3 id="第一题：照片分析"><a href="#第一题：照片分析" class="headerlink" title="第一题：照片分析"></a>第一题：照片分析</h3><p>第一题我还挺乐的，直接用<a href="https://exif.tuchong.com/">图虫EXIF查看器</a>开了盒：<br><img src="/2022/11/06/HackerGame2022/img_20.png" alt></p><h4 id="1-图片所包含的-EXIF-信息版本是多少？"><a href="#1-图片所包含的-EXIF-信息版本是多少？" class="headerlink" title="1. 图片所包含的 EXIF 信息版本是多少？"></a>1. 图片所包含的 EXIF 信息版本是多少？</h4><p>Exif版本：0231<br>·A:2.31</p><h4 id="2-拍照使用手机的品牌是什么？"><a href="#2-拍照使用手机的品牌是什么？" class="headerlink" title="2. 拍照使用手机的品牌是什么？"></a>2. 拍照使用手机的品牌是什么？</h4><p>制造商：Xiaomi<br>·A:小米/红米</p><h4 id="3-该图片被拍摄时相机的感光度（ISO）是多少？"><a href="#3-该图片被拍摄时相机的感光度（ISO）是多少？" class="headerlink" title="3. 该图片被拍摄时相机的感光度（ISO）是多少？"></a>3. 该图片被拍摄时相机的感光度（ISO）是多少？</h4><p>曝光：光圈:1.8, 快门:1/1264秒, ISO84<br>·A:84</p><h4 id="4-照片拍摄日期是哪一天？"><a href="#4-照片拍摄日期是哪一天？" class="headerlink" title="4. 照片拍摄日期是哪一天？"></a>4. 照片拍摄日期是哪一天？</h4><p>时间：2022:05:14 18:23:35.220027+09:00<br>·A:2022/05/14</p><h4 id="5-照片拍摄时是否使用了闪光灯？"><a href="#5-照片拍摄时是否使用了闪光灯？" class="headerlink" title="5. 照片拍摄时是否使用了闪光灯？"></a>5. 照片拍摄时是否使用了闪光灯？</h4><p>闪光灯：Off, Did not fire<br>·A:否</p><p><img src="/2022/11/06/HackerGame2022/img_21.png" alt><br><strong>flag{1f_y0u_d0NT_w4nt_shOw_theSe_th3n_w1Pe_EXlF}</strong><br>got it</p><h3 id="第二题：社工实践"><a href="#第二题：社工实践" class="headerlink" title="第二题：社工实践"></a>第二题：社工实践</h3><p>乐不出来了。要不是问了航班，我是看都没看见图片里有个飞机。<br><img src="/2022/11/06/HackerGame2022/img_22.png" alt><br><img src="/2022/11/06/HackerGame2022/img_23.png" alt></p><p><font size="6">宁这鸟也太小小了吧？</font><br><img src="/2022/11/06/HackerGame2022/memes_8.jpg" alt><br>能怎么办，开呗。<br>开盒我倒是开过的，第一次开盒是和前女友约会之前。她说她还在外面，我给她发消息她只回复了我一张照片，黑屏的网吧电脑上依稀还反光着她拿着手机的影子。我也是贱啊闲着就去分析照片，我们破地方那么小，哪个网吧只需要看看内饰就能分辨出来，但是做过图像处理之后愣是在反光里的她的旁边看到了熟悉的”别的男人“。捏妈，宁不是说跟他只是普通朋友🐎？？宁也够忙，跟我约会前还忙着要跟别人约会，属实给👴整笑<br><img src="/2022/11/06/HackerGame2022/memes_3.jpg" alt><br>👴连🤡都当过，查个鸟应该不成问题吧。</p><h4 id="酒店"><a href="#酒店" class="headerlink" title="酒店"></a>酒店</h4><p>首先要确定位置：<br>我最一开始真没想到国外，直接把体育场截了图去百度识图，当然找不到的。<br>突然看到马路上的公交车是靠左行驶<br><img src="/2022/11/06/HackerGame2022/img_25.png" alt><br>突然意识到出现的汉字可能不是国内而是日本，<br>再放大看商业街：<br><img src="/2022/11/06/HackerGame2022/img_24.png" alt><br>果断google<br><img src="/2022/11/06/HackerGame2022/img_26.png" alt="ZOZO Marine Stadium"><br>再根据google map<br><img src="/2022/11/06/HackerGame2022/img_27.png" alt><br>在这里我以为结束了，直接填了zozo海洋球场的邮编。后来才知道娘希匹的日本邮编划分有时候会精确到某个社区，保险起见找到拍照的酒店：<br><img src="/2022/11/06/HackerGame2022/img_28.png" alt><br>果然邮编不一样。（这酒店蛮眼熟，突然想起来17年我还是个中二的时候，听说apa酒店提供极右反华的书籍，遂跟着水军在各个平台给apa酒店举报+差评，这家酒店我好像还差评过<br>还有一个有趣的点是我刚刚复盘的时候，居然看到有杀软在赛间直接把图片发到知乎提问：<a href="https://www.zhihu.com/question/561462294/answer/2725783112">https://www.zhihu.com/question/561462294/answer/2725783112</a><br><img src="/2022/11/06/HackerGame2022/img_29.png" alt><br>没必要，真没必要<br>然后是看手机型号：<br><img src="/2022/11/06/HackerGame2022/img_30.png" alt><br>已知是小米/红米，显然可以通过摄像头块+某宝就能找到：<br><img src="/2022/11/06/HackerGame2022/img_31.png" alt><br><img src="/2022/11/06/HackerGame2022/img_32.png" alt></p><h4 id="航班"><a href="#航班" class="headerlink" title="航班"></a>航班</h4><p>来看看鸟（是指飞机）<br>不难看出这个高度应该是刚起飞/要降落，但看着更像是攀升。另外有个细节是在水平拍摄时可以看到飞机两侧机翼，则证明这鸟在拐弯儿。顺手打开FlightWare看看附近机场<br><img src="/2022/11/06/HackerGame2022/img_33.png" alt><br>HND起飞应该没跑，初步估摸着大概就是这么个情景。接下来就是硬肝，因为没钱买五个月前的航班记录（后来才知道用飞常准居然是免费的，可恶），只能是去查HND的航班记录。<br>根据航行图锁定了如下几个航班：<br><img src="/2022/11/06/HackerGame2022/img_34.png" alt><br>这么多，都挺符合的，咋整，挨个试呗。试了一圈突然意识到时差问题。。。不过最后还是找到了这个：<br><img src="/2022/11/06/HackerGame2022/img_35.png" alt><br><img src="/2022/11/06/HackerGame2022/img_36.png" alt><br><strong>flag{Buzz_0ver_y0ur_h34d_and_4DSB_m19ht_111egal}</strong><br>got it</p><h2 id="LaTex机器人"><a href="#LaTex机器人" class="headerlink" title="LaTex机器人"></a>LaTex机器人</h2><p><em>在网上社交群组中交流数学和物理问题时，总是免不了输入公式。而显然大多数常用的聊天软件并不能做到这一点。为了方便大家在水群和卖弱之余能够高效地进行学术交流，G 社的同学制作了一个简单易用的将 LaTeX 公式代码转换成图片的网站，并通过聊天机器人在群里实时将群友发送的公式转换成图片发出。<br>这个网站的思路也很直接：把用户输入的 LaTeX 插入到一个写好头部和尾部的 TeX 文件中，将文件编译成 PDF，再将 PDF 裁剪成大小合适的图片。<br>“LaTeX 又不是被编译执行的代码，这种东西不会有事的。”<br>物理出身的开发者们明显不是太在意这个网站的安全问题，也没有对用户的输入做任何检查。<br>那你能想办法获得服务器上放在根目录下的 flag 吗？</em></p><h3 id="LaTex是个啥？"><a href="#LaTex是个啥？" class="headerlink" title="LaTex是个啥？"></a>LaTex是个啥？</h3><p>LaTeX(LATEX，音译“拉泰赫”)是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特(Leslie Lamport)在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天、甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。<br>简单来说，即LaTeX是一种基于ΤΕΧ的排版系统，主要功能是生成数学公式和文章排版，而本文就是由前者数学公式而引出。</p><h3 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h3><p>既然LaTeX的操作规律是将用户端输入的内容插入到一个写好头部和尾部的 TeX 文件中，将文件编译成 PDF，再将 PDF 裁剪成大小合适的图片,最后返回到界面，显而易见的用户可以在输入端进行注入，获取根目录下的文本文件并返回。<br>至于注入命令语句，参考：<a href="https://zhuanlan.zhihu.com/p/455901476">实战LaTex Injection <em>by 云山雾隐</em> - 知乎</a></p><h4 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h4><p><em>第一个 flag 位于 /flag1，flag 花括号内的内容由纯文本组成（即只包含大写小写字母和数字 0-9）。</em><br><img src="/2022/11/06/HackerGame2022/img_37.png" alt><br><strong>flag{becAr3fu11dUd3e033e7c96d}</strong><br>got it</p><h4 id="特殊字符混入"><a href="#特殊字符混入" class="headerlink" title="特殊字符混入"></a>特殊字符混入</h4><p><em>第二个 flag 位于 /flag2，这次，flag 花括号内的内容除了字母和数字之外，还混入了两种特殊字符：下划线（</em>）和井号（#）。你可能需要想些其他办法了。<em><br>尝试过后可以发现，无法正常输出的原因是LaTeX在读取目标文件的时候读到了非法的文字段，因而可以判断它将特殊符号进行了绕过处理。<br>要进行的操作就是用命令行处理绕过。<br>查到了相关的解决方案且发现了个不错的仓库，fork一下：[LaTex Injection _by bodik</em> -github](<a href="https://github.com/MoonlightHt/PayloadsAllTheThings/tree/master/LaTeX%20Injection">https://github.com/MoonlightHt/PayloadsAllTheThings/tree/master/LaTeX%20Injection</a>)<br><img src="/2022/11/06/HackerGame2022/img_38.png" alt><br><strong>flag{latex<em>bec<em>0_m##es_co</em></em>#ol_8d3ec11d2f}</strong><br>got it.</p><h2 id="Flag的痕迹"><a href="#Flag的痕迹" class="headerlink" title="Flag的痕迹"></a>Flag的痕迹</h2><p><em>小 Z 听说 Dokuwiki 配置很简单，所以在自己的机器上整了一份。可是不巧的是，他一不小心把珍贵的 flag 粘贴到了 wiki 首页提交了！他赶紧改好，并且也把历史记录（revisions）功能关掉了。<br>「这样就应该就不会泄漏 flag 了吧」，小 Z 如是安慰自己。<br>然而事实真的如此吗？<br>（题目 Dokuwiki 版本基于 2022-07-31a “Igor”）</em><br><img src="/2022/11/06/HackerGame2022/img_39.png" alt><br>漏洞利用，显然DokuWiki igor版本为关键词，存在revision漏洞。根据这个进行google，查看Dokuviki历史版本以及漏洞解决。<br><img src="/2022/11/06/HackerGame2022/img_40.png" alt><br>这里发现Dokuwiki有一个功能是通关diff来比较上传的新旧版本文档的差别。遂<br>xxx//doku.php?id=start&amp;do=diff<br>得到：<br><img src="/2022/11/06/HackerGame2022/img_41.png" alt><br><img src="/2022/11/06/HackerGame2022/img_42.png" alt><br><strong>flag{d1gandFInD_d0kuw1k1_unexpectEd_API}</strong><br>got it.</p><h2 id="线路板"><a href="#线路板" class="headerlink" title="线路板"></a>线路板</h2><p><em>中午起床，看到室友的桌子上又多了一个正方形的盒子。快递标签上一如既往的写着：线路板。和往常一样，你“帮”室友拆开快递并抢先把板子把玩一番。可是突然，你注意到板子表面似乎写着些东西……看起来像是……flag？<br>可是只有开头的几个字母可以看清楚。你一时间不知所措。<br>幸运的是，你通过盒子上的联系方式找到了制作厂家，通过板子丝印上的序列号查出了室友的底细，并以放弃每月两次免费 PCB 打样包邮的机会为代价要来了这批带有 flag 的板子的生产文件。那这些文件里会不会包含着更多有关 flag 的信息呢？</em><br><img src="/2022/11/06/HackerGame2022/img_43.png" alt><br>下载题目后文件夹里给了一大堆的.gbr文件，百度知道GBR或Gerber文件用于保存Gerber格式的印刷电路板（PCB）设计数据。可以使用Altium Designer打开。<br>搜索到的所谓破解版都会卡在安装时的account login处，也就是没有申请到license的无法正常下载。于是我干脆去AD官网下正版，官网指导我可以下载试用版，然后下载了之后它要我license，于是我去申请了student-academic，申请通过后它又要我log in，fine我去注册用户，注册用户它又要我申请student-academic…????我申请了啊？账号没给我开通啊？</p><p><font size="6">你搁这跟我搁这呢？？？</font><br><img src="/2022/11/06/HackerGame2022/memes_2.jpg" width="50%"><br>ok，我上淘宝斥8.8r巨资买了带license版的。然后店家给我发了1个多g的百度网盘？？？？我百度云盘没会员，下载速度100kb/s。<br>行，<font size="6">我又在淘宝斥10r巨资买了百度网盘24小时会员</font>。<br><img src="/2022/11/06/HackerGame2022/memes_9.jpg" alt><br>whatever，我折腾一晚上终于下载下来了AD。<br>研究了一通.gbr的文件和ad基本工具的使用，发现ebaz_sdr-F_Cu.gbr文件隐藏了flag：<br><img src="/2022/11/06/HackerGame2022/img_44.png" alt><br>使用工具-&gt;PCB拼版，获得：<br><img src="/2022/11/06/HackerGame2022/img_45.png" alt><br><strong>flag{8_1ayER_rogeRS_81ind_V1a}</strong><br>got it.</p><h2 id="微积分计算小练习"><a href="#微积分计算小练习" class="headerlink" title="微积分计算小练习"></a>微积分计算小练习</h2><p><em>小 X 作为某门符号计算 课程的助教，为了让大家熟悉软件的使用，他写了一个小网站：上面放着五道简单的题目，只要输入姓名和题目答案，提交后就可以看到自己的分数。<br><a href="http://202.38.93.111:10056/">点击此链接访问练习网站</a><br>想起自己前几天在公众号上学过的 Java 设计模式免费试听课，本着前后端离心（咦？是前后端离心吗？还是离婚？离。。离谱？总之把功能能拆则拆就对啦）的思想，小 X 还单独写了一个程序，欢迎同学们把自己的成绩链接提交上来。<br>总之，因为其先进的设计思想，需要同学们做完练习之后手动把成绩连接贴到这里来：</em><br><a href="http://202.38.93.111:10057/">点击此链接提交练习成绩 URL</a><br><img src="/2022/11/06/HackerGame2022/img_46.png" alt><br><img src="/2022/11/06/HackerGame2022/img_47.png" alt><br>一眼看到input标签，且对输入的文段没有绕过处理，显然是js注入。<br>下载源码看看实现如何的操作：<br><img src="/2022/11/06/HackerGame2022/img_48.png" alt><br>注意到此处，是在提交练习成绩生成的URL中，将flag的值赋值给document.cookie，且注意到前后端分离的运行机制，则考虑在前端通过input进行xss注入，在后端读取url提交的数据时执行js，并在flag赋值到cookie之后将cookie输出到终端上。<br>已知终端读取并输出的标签变量有#score和#greeting，考虑将cookie的值再赋值给这两个变量中的一个即可实现flag的输出。<br>同时，由于cookie赋值的时机，选择用onerror事件触发，并执行实现上述操作的函数。<br>注入内容为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> //构造错误</span></span><br><span class="line"><span class="tag">     <span class="attr">onerror</span>=<span class="string">&quot;var s=document.cookie; //由于无法直接赋值，因此添加中间变量</span></span></span><br><span class="line"><span class="string"><span class="tag">     document.querySelector(&#x27;#score&#x27;).innerHTML=s;&quot;</span> //修改#<span class="attr">score</span>标签的<span class="attr">innerHTML</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><br>将生成的url提交到terminal：<br><img src="/2022/11/06/HackerGame2022/img_49.png" alt><br><strong>flag{xS5_1OI_is_N0t_SOHARD_c5b8e2b4ed}</strong><br>got it.</p><h2 id="企鹅拼盘"><a href="#企鹅拼盘" class="headerlink" title="企鹅拼盘"></a>企鹅拼盘</h2><p><em>这是一个可爱的企鹅滑块拼盘。（觉得不可爱的同学可以换可爱的题做）<br>和市面上只能打乱之后拼回的普通滑块拼盘不同，这个拼盘是自动打乱拼回的。一次游戏可以帮助您体验到 16/256/4096 次普通拼盘的乐趣。<br>每一步的打乱的方式有两种，选择哪一种则由您的输入（长度为 4/16/64 的 0/1 序列）的某一位决定。如果您在最后能成功打乱这个拼盘，您就可以获取到 flag 啦，快来试试吧wwwwww<br>你可以在下面列出的两种方法中任选其一来连接题目：<br>点击下面的 “打开/下载题目” 按钮通过网页终端与远程交互。如果采用这种方法，在正常情况下，你不需要手动输入 token。<br>在 Linux、macOS、WSL 或 Git Bash 等本地终端中使用 stty raw -echo; nc 202.38.93.111 11011; stty sane 命令来连接题目。如果采用这种方法，你必须手动输入 token（复制粘贴也可）。注意，输入的 token 不会被显示，输入结束后按 Ctrl-J 即可开始题目。</em><br><img src="/2022/11/06/HackerGame2022/img_50.png" alt></p><h3 id="这么简单我闭眼都可以！"><a href="#这么简单我闭眼都可以！" class="headerlink" title="这么简单我闭眼都可以！"></a>这么简单我闭眼都可以！</h3><p>因为简单模式的输入是4位二进制数，于是还没搞清楚具体实现什么操作和原理，直接爆破+allexcute<br><img src="/2022/11/06/HackerGame2022/img_51.png" alt><br><img src="/2022/11/06/HackerGame2022/img_52.png" alt><br><strong>flag{it_works_like_magic_16adc9241e}</strong><br>确实是闭眼都可以，但是后续两个level，我甚至在level2里也硬生生爆破，当然是又浪费时间又没拿到flag，就放弃了。<br>赛后简单了解了一下游戏规则，<a href="https://github.com/USTC-Hackergame/hackergame2022-writeups/blob/master/official/%E4%BC%81%E9%B9%85%E6%8B%BC%E7%9B%98/README.md">hackergame2022-writeups/official/企鹅拼盘 -github</a></p><p><font size="6">没看懂.</font><br><img src="/2022/11/06/HackerGame2022/memes_10.jpg" width="50%"></p><h2 id="火眼金睛的小-E"><a href="#火眼金睛的小-E" class="headerlink" title="火眼金睛的小 E"></a>火眼金睛的小 E</h2><p><em>小 E 有很多的 ELF 文件，它们里面的函数有点像，能把它们匹配起来吗？<br>小 A：这不是用 BinDiff 就可以了吗，很简单吧？</em></p><p>我就知道所有的困难都源自于软件/插件的安装，这次又卡在BinDiff安装上（我记得我很早就安装过？？<br>坑死坑活没能安装下来，遂又双叒斥17.6巨资上淘宝找了家远程安装软件的，连了我电脑之后上来给我下了个360，然后嘎嘎一顿乱删我软件，还把老子迅雷给删了。<br>删了一气发消息问我：<font size="6">你要下载什么来着？</font><br><img src="/2022/11/06/HackerGame2022/memes_5.jpg" width="50%"><br>他甚至还嘲讽我的阿尼亚光标：<br><img src="/2022/11/06/HackerGame2022/img_1.jpg" alt><br>他好像在内涵我是什么sb？）可恶<br>它长这样：<br><img src="/2022/11/06/HackerGame2022/img_53.png" alt><br>拜托，<font size="6">我真的觉得很可爱好吗？？？？？？</font><br>他鼓捣了半天也没下好，因为当时装系统的时候用户名用了中文，导致database的路径检索错误，并发言：<br><img src="/2022/11/06/HackerGame2022/img_2.jpg" alt><br><img src="/2022/11/06/HackerGame2022/img_3.jpg" alt><br>我。。。<br>我说要不然，创建一个新用户吧，用英文，凑合一下。<br>他：<br><img src="/2022/11/06/HackerGame2022/img_4.jpg" alt><br>用这个解决方案，总算是把bindiff配置好了。<br><img src="/2022/11/06/HackerGame2022/memes_13.jpg" width="50%"></p><h3 id="有手就行"><a href="#有手就行" class="headerlink" title="有手就行"></a>有手就行</h3><p><img src="/2022/11/06/HackerGame2022/img_54.png" alt><br>大概意思是就是说，以时间戳为出题的源，在给定时间内，将提供的两个文件通过url下载下来，用找到文件A中某地址(hex)的函数所对应的在文件B中相似函数的地址，提交上去。<br>第一关比较简单，只需要完成两次提交并100%正确率就行。<br>先将其中一个通过IDA pack成i64格式的文件：<br><img src="/2022/11/06/HackerGame2022/img_55.png" alt><br>在用IDA打开另一个文件，使用bindiff，在Matched Function进行比较并查找相似函数的地址：<br><img src="/2022/11/06/HackerGame2022/img_56.png" alt><br>ctrl+f检索到题干地址：<br><img src="/2022/11/06/HackerGame2022/img_57.png" alt><br>复盘时因为懒于是只拿一个例子做示范。<br>两次如上提交后获得flag<br><strong>flag{easy_to_use_bindiff_b97f49e305}</strong><br>got it.</p><h1 id="承上启下过渡句"><a href="#承上启下过渡句" class="headerlink" title="承上启下过渡句"></a>承上启下过渡句</h1><p>如上，就是我这次在赛间拿到的所有flag的题解，事实上很多很多都做了一半/有了思路，但是最终没能及时成功拿到，赛后看了官方题解恍然大悟，蛮遗憾的。<br><img src="/2022/11/06/HackerGame2022/img_58.png" alt="组内排名"></p><p><font size="6">个签说的兰格格酸奶真的很好喝！真的特别好喝！都给我去喝！！</font><br>至于标签提到的内工大five领导，是因为在赛间，老家疫情突然严重起来，在呼和浩特读书的好朋友们给我讲了内工大防控不力局面，心痛愤怒之余骂两句图个口快。好在亲朋好友都无恙。（后续，诸如死亡列车/兴光A9 等等呼和浩特魔幻现实主义的负面新闻，不想赘述。<br>无论如何，为了不耽误白天正常课业和任务的进行，做比赛都是在晚上熬大夜去赶<br><img src="/2022/11/06/HackerGame2022/memes_11.jpg" width="50%"><br>Doesn’t matter, 真的很好玩。全程的精神状态也保持在高调且积极的<font size="6">“卧槽还能这样？”</font>之中。</p><p>接下来打算把当时没能在赛间解决的题目，重新做一下，并写个write-ups。不过到现在，就先写这么多吧。</p><h1 id="赛后捉急"><a href="#赛后捉急" class="headerlink" title="赛后捉急"></a>赛后捉急</h1><h2 id="家目录里的秘密-1"><a href="#家目录里的秘密-1" class="headerlink" title="家目录里的秘密"></a>家目录里的秘密</h2><h3 id="Rclone-里的-flag"><a href="#Rclone-里的-flag" class="headerlink" title="Rclone 里的 flag"></a>Rclone 里的 flag</h3><p>占个坑先</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> write-ups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
            <tag> ctf </tag>
            
            <tag> web </tag>
            
            <tag> general </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[法语]词汇积累-Conjugaison</title>
      <link href="/2022/07/05/Conjugaison-tous%20les%20jours/"/>
      <url>/2022/07/05/Conjugaison-tous%20les%20jours/</url>
      
        <content type="html"><![CDATA[<h1 id="变位-Conjugaison"><a href="#变位-Conjugaison" class="headerlink" title="变位-Conjugaison"></a>变位-Conjugaison</h1><h2 id="直陈式现在时-lt-br-gt-Indicatif-Present"><a href="#直陈式现在时-lt-br-gt-Indicatif-Present" class="headerlink" title="直陈式现在时&lt;/br&gt;Indicatif Présent"></a>直陈式现在时&lt;/br&gt;Indicatif Présent</h2><div class="table-container"><table><thead><tr><th style="text-align:center">词汇&lt;/br&gt;(现分)&lt;/br&gt;(过分)</th><th style="text-align:center">第一人称单数</th><th style="text-align:center">第二人称单数</th><th style="text-align:center">第三人称单数</th><th style="text-align:center">第一人称复数</th><th style="text-align:center">第二人称复数</th><th style="text-align:center">第三人称复数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>être</strong>&lt;/br&gt;(étant)&lt;/br&gt;(été)</td><td style="text-align:center">je <strong>suis</strong></td><td style="text-align:center">tu <strong>es</strong></td><td style="text-align:center">il <strong>est</strong></td><td style="text-align:center">nous <strong>sommes</strong></td><td style="text-align:center">vous <strong>êtes</strong></td><td style="text-align:center">ils <strong>sont</strong></td></tr><tr><td style="text-align:center"><strong>avoir</strong>&lt;/br&gt;(ayant)&lt;/br&gt;(eu)</td><td style="text-align:center">j’<strong>ai</strong></td><td style="text-align:center">tu <strong>as</strong></td><td style="text-align:center">il <strong>a</strong></td><td style="text-align:center">nous <strong>avons</strong></td><td style="text-align:center">vous <strong>avez</strong></td><td style="text-align:center">ils <strong>ont</strong></td></tr><tr><td style="text-align:center"><strong>faire</strong>&lt;/br&gt;(faisant)&lt;/br&gt;(fait)</td><td style="text-align:center">je <strong>fais</strong></td><td style="text-align:center">tu <strong>fais</strong></td><td style="text-align:center">il <strong>fait</strong></td><td style="text-align:center">nous <strong>faisons</strong></td><td style="text-align:center">vous <strong>faites</strong></td><td style="text-align:center">ils <strong>font</strong></td></tr><tr><td style="text-align:center"><strong>prendre</strong>&lt;/br&gt;(prenant)&lt;/br&gt;(pris)</td><td style="text-align:center">je <strong>prends</strong></td><td style="text-align:center">tu <strong>prends</strong></td><td style="text-align:center">il <strong>prend</strong></td><td style="text-align:center">nous <strong>prenons</strong></td><td style="text-align:center">vous <strong>prenez</strong></td><td style="text-align:center">ils <strong>prennent</strong></td></tr><tr><td style="text-align:center"><strong>venir</strong>&lt;/br&gt;(venant)&lt;/br&gt;(venu)</td><td style="text-align:center">je <strong>viens</strong></td><td style="text-align:center">tu <strong>viens</strong></td><td style="text-align:center">il <strong>vient</strong></td><td style="text-align:center">nous <strong>venons</strong></td><td style="text-align:center">vous <strong>venez</strong></td><td style="text-align:center">ils <strong>viennent</strong></td></tr><tr><td style="text-align:center"><strong>écrire</strong>&lt;/be&gt;(écrivant)&lt;/br&gt;(écrit)</td><td style="text-align:center">j’<strong>écris</strong></td><td style="text-align:center">tu <strong>écris</strong></td><td style="text-align:center">il <strong>écrit</strong></td><td style="text-align:center">nous <strong>écrivons</strong></td><td style="text-align:center">vous <strong>écrivez</strong></td><td style="text-align:center">ils <strong>écrivent</strong></td></tr><tr><td style="text-align:center"><strong>pouvoir</strong>&lt;/br&gt;(pourvoyant)&lt;/br&gt;(pourvu)</td><td style="text-align:center">je <strong>peux/puis</strong></td><td style="text-align:center">tu <strong>peux</strong></td><td style="text-align:center">il <strong>peut</strong></td><td style="text-align:center">nous <strong>pouvons</strong></td><td style="text-align:center">vous <strong>pouvez</strong></td><td style="text-align:center">ils <strong>peuvent</strong></td></tr><tr><td style="text-align:center"><strong>lire</strong>&lt;/br&gt;(lisant)&lt;/br&gt;(lu)</td><td style="text-align:center">je <strong>lis</strong></td><td style="text-align:center">tu <strong>lis</strong></td><td style="text-align:center">il <strong>lit</strong></td><td style="text-align:center">nous <strong>lisons</strong></td><td style="text-align:center">vous <strong>lisez</strong></td><td style="text-align:center">ils <strong>lisent</strong></td></tr><tr><td style="text-align:center"><strong>vouloir</strong>&lt;/br&gt;(voulant)&lt;/br&gt;(voulu)</td><td style="text-align:center">je <strong>veux</strong></td><td style="text-align:center">tu <strong>veux</strong></td><td style="text-align:center">il <strong>veut</strong></td><td style="text-align:center">nous <strong>voulons</strong></td><td style="text-align:center">vous <strong>voulez</strong></td><td style="text-align:center">ils <strong>veulent</strong></td></tr><tr><td style="text-align:center"><strong>partir</strong>&lt;/br&gt;(partant)&lt;/br&gt;(parti)</td><td style="text-align:center">je <strong>pars</strong></td><td style="text-align:center">tu <strong>pars</strong></td><td style="text-align:center">il <strong>part</strong></td><td style="text-align:center">nous <strong>partons</strong></td><td style="text-align:center">vous <strong>partez</strong></td><td style="text-align:center">ils <strong>partent</strong></td></tr><tr><td style="text-align:center"><strong>devoir</strong>&lt;/br&gt;(devant)&lt;/br&gt;(dû)</td><td style="text-align:center">je <strong>dois</strong></td><td style="text-align:center">tu <strong>dois</strong></td><td style="text-align:center">il <strong>doit</strong></td><td style="text-align:center">nous <strong>devons</strong></td><td style="text-align:center">vous <strong>devez</strong></td><td style="text-align:center">ils <strong>doivent</strong></td></tr><tr><td style="text-align:center"><strong>attendre</strong>&lt;/br&gt;(attendant)&lt;/br&gt;(attendu)</td><td style="text-align:center">j’<strong>attends</strong></td><td style="text-align:center">tu <strong>attends</strong></td><td style="text-align:center">il <strong>attend</strong></td><td style="text-align:center">nous <strong>attendons</strong></td><td style="text-align:center">vous <strong>attendez</strong></td><td style="text-align:center">ils <strong>attendent</strong></td></tr><tr><td style="text-align:center"><strong>offrir</strong>&lt;/br&gt;(offrant)&lt;/br&gt;(offert)</td><td style="text-align:center">j’<strong>offre</strong></td><td style="text-align:center">tu <strong>offres</strong></td><td style="text-align:center">il <strong>offre</strong> ｜ nous <strong>offrons</strong></td><td style="text-align:center">vous <strong>offrez</strong></td><td style="text-align:center">ils <strong>offrent</strong></td></tr><tr><td style="text-align:center"><strong>ouvrir</strong>&lt;/br&gt;(ouvrant)&lt;/br&gt;(ouvert)</td><td style="text-align:center">j’<strong>ouvre</strong></td><td style="text-align:center">tu <strong>ouvres</strong></td><td style="text-align:center">il <strong>ouvre</strong></td><td style="text-align:center">nous <strong>ouvres</strong></td><td style="text-align:center">vous <strong>ouvrez</strong></td><td style="text-align:center">ils <strong>ouvrent</strong></td></tr><tr><td style="text-align:center"><strong>mettre</strong>&lt;/br&gt;(mettant)&lt;/br&gt;(mis)</td><td style="text-align:center">je <strong>mets</strong></td><td style="text-align:center">tu <strong>mets</strong></td><td style="text-align:center">il <strong>met</strong></td><td style="text-align:center">nous <strong>mettons</strong></td><td style="text-align:center">vous <strong>mettez</strong></td><td style="text-align:center">ils <strong>mettent</strong></td></tr><tr><td style="text-align:center"><strong>répondre</strong>&lt;/br&gt;(répondant)&lt;/br&gt;(répondu)</td><td style="text-align:center">je <strong>réponds</strong></td><td style="text-align:center">il <strong>répond</strong></td><td style="text-align:center">nous <strong>répondons</strong></td><td style="text-align:center">vous <strong>répondez</strong></td><td style="text-align:center">ils <strong>répondent</strong></td></tr><tr><td style="text-align:center"><strong>recevoir</strong>&lt;/br&gt;(recevant)&lt;/br&gt;(reçu)</td><td style="text-align:center">je <strong>reçois</strong></td><td style="text-align:center">tu <strong>reçois</strong></td><td style="text-align:center">il <strong>reçoit</strong></td><td style="text-align:center">nous <strong>recevons</strong></td><td style="text-align:center">vous <strong>recevez</strong></td><td style="text-align:center">ils <strong>reçoivent</strong></td></tr><tr><td style="text-align:center"><strong>tenir</strong>&lt;/br&gt;(tenant)&lt;/br&gt;(tenu)</td><td style="text-align:center">je <strong>tiens</strong></td><td style="text-align:center">tu <strong>tiens</strong></td><td style="text-align:center">il <strong>tient</strong></td><td style="text-align:center">nous <strong>tenons</strong></td><td style="text-align:center">vous <strong>tenez</strong></td><td style="text-align:center">ils <strong>tiennent</strong></td></tr><tr><td style="text-align:center"><strong>sortir</strong>&lt;/br&gt;(sortant)&lt;/br&gt;(sorti)</td><td style="text-align:center">je <strong>sors</strong></td><td style="text-align:center">tu <strong>sors</strong></td><td style="text-align:center">il <strong>sort</strong></td><td style="text-align:center">nous <strong>sortons</strong></td><td style="text-align:center">vous <strong>sortez</strong></td><td style="text-align:center">ils <strong>sortent</strong></td></tr><tr><td style="text-align:center"><strong>boire</strong>&lt;/br&gt;(buvant)&lt;/br&gt;(bu)</td><td style="text-align:center">je <strong>bois</strong></td><td style="text-align:center">tu <strong>bois</strong></td><td style="text-align:center">il <strong>boit</strong></td><td style="text-align:center">nous <strong>buvons</strong></td><td style="text-align:center">vous <strong>buvez</strong></td><td style="text-align:center">ils <strong>boivent</strong></td></tr><tr><td style="text-align:center"><strong>servir</strong>&lt;/br&gt;(servant)&lt;/br&gt;(servi)</td><td style="text-align:center">je <strong>sers</strong></td><td style="text-align:center">tu <strong>sers</strong></td><td style="text-align:center">il <strong>sert</strong></td><td style="text-align:center">nous <strong>servons</strong></td><td style="text-align:center">vous <strong>servez</strong></td><td style="text-align:center">ils <strong>servent</strong></td></tr><tr><td style="text-align:center"><strong>courir</strong>&lt;/br&gt;(courant)&lt;/br&gt;(couru)</td><td style="text-align:center">je <strong>cours</strong></td><td style="text-align:center">tu <strong>cours</strong></td><td style="text-align:center">il <strong>court</strong></td><td style="text-align:center">nous <strong>courons</strong></td><td style="text-align:center">vous <strong>courez</strong></td><td style="text-align:center">ils <strong>courent</strong></td></tr></tbody></table></div><h1 id="词汇-Vocabulaire"><a href="#词汇-Vocabulaire" class="headerlink" title="词汇-Vocabulaire"></a>词汇-Vocabulaire</h1><h2 id="日常-quotidien"><a href="#日常-quotidien" class="headerlink" title="日常-quotidien"></a>日常-quotidien</h2><h3 id="月份与星期-Mois-et-semaine"><a href="#月份与星期-Mois-et-semaine" class="headerlink" title="月份与星期-Mois et semaine"></a>月份与星期-Mois et semaine</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">星期一</td><td style="text-align:center">lundi</td></tr><tr><td style="text-align:center">星期二</td><td style="text-align:center">mardi</td></tr><tr><td style="text-align:center">星期三</td><td style="text-align:center">mercredi</td></tr><tr><td style="text-align:center">星期四</td><td style="text-align:center">jeudi</td></tr><tr><td style="text-align:center">星期五</td><td style="text-align:center">vendredi</td></tr><tr><td style="text-align:center">星期六</td><td style="text-align:center">samedi</td></tr><tr><td style="text-align:center">星期日</td><td style="text-align:center">dimanche</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">一月</td><td style="text-align:center">janvier</td></tr><tr><td style="text-align:center">二月</td><td style="text-align:center">févier</td></tr><tr><td style="text-align:center">三月</td><td style="text-align:center">mars</td></tr><tr><td style="text-align:center">四月</td><td style="text-align:center">avril</td></tr><tr><td style="text-align:center">五月</td><td style="text-align:center">mai</td></tr><tr><td style="text-align:center">六月</td><td style="text-align:center">juin</td></tr><tr><td style="text-align:center">七月</td><td style="text-align:center">juillet</td></tr><tr><td style="text-align:center">八月</td><td style="text-align:center">août</td></tr><tr><td style="text-align:center">九月</td><td style="text-align:center">septembre</td></tr><tr><td style="text-align:center">十月</td><td style="text-align:center">octobre</td></tr><tr><td style="text-align:center">十一月</td><td style="text-align:center">novembre</td></tr><tr><td style="text-align:center">十二月</td><td style="text-align:center">décembre</td></tr></tbody></table></div><h1 id="Situation-dans-l’espace"><a href="#Situation-dans-l’espace" class="headerlink" title="Situation dans l’espace"></a>Situation dans l’espace</h1><p><img src="/2022/07/05/Conjugaison-tous%20les%20jours/img_6.png" alt="Situation dans l&#39;espace"></p>]]></content>
      
      
      <categories>
          
          <category> 法语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[法语]语法笔记-Notes grammaticales</title>
      <link href="/2022/07/04/fran%C3%A7ais/"/>
      <url>/2022/07/04/fran%C3%A7ais/</url>
      
        <content type="html"><![CDATA[<h1 id="Les-Articles-冠词"><a href="#Les-Articles-冠词" class="headerlink" title="Les Articles 冠词"></a>Les Articles 冠词</h1><p><img src="/2022/07/04/fran%C3%A7ais/img.png" alt="Tableau des le articles"><br><strong>Note</strong>: <strong>l’</strong> est utilisé spécifiquement avant lès mots qui commencent par une voyelle ou un <strong>h factice</strong>.<br><strong>注意</strong>：<strong>l’</strong>专用在以元音字母或<strong>哑音h</strong>开头的单词前。</p><ul><li><p>Les <strong>articles définis</strong> désignent les noms qu’ils qualifient ou qui ont été mentionnés ci - dessus, tandis que les <strong>articles indéfinis</strong> désignent les noms qu’ils qualifient comme génériques.<br><strong>定冠词</strong>表示它所限定的名词是确指的或是上文中已提及过的，而<strong>不定冠词</strong>则表示其所限定的名词是泛指的。</p></li><li><p>Example:</p></li></ul><ol><li>Il y a <strong>un ordinateur</strong> sur la table. 桌上有一台电脑。<br><strong>L’ordinateur</strong> est à moi. 这台电脑是我的。</li><li>Il a acheté <strong>une voiture</strong>. 他买了一辆汽车。<br><strong>La voiture</strong> est rouge. 这辆汽车是红色的。</li><li>Ce sont <strong>des étudiants</strong>. 这是一群大学生。<br><strong>Les étudiants</strong> sont jeunes. 这群大学生很年轻。</li></ol><ul><li><p>Bien que l’utilisation d’articles indéfinis et d’articles définis soit définie par des références générales et précises, dans certaines expressions, leur utilisation va bien au - delà de ces dispositions.<br>尽管不定冠词和定冠词的使用是以泛指与确指为界定的，但在有些表达中，它们的用法远远地超越了这样的规定。</p><ul><li>Example：</li></ul></li></ul><ol><li>Il n’aime pas <strong>le soleil</strong>. 他不喜欢太阳。(众所周知的，唯一的)</li><li><strong>Le vélo</strong> est pratique. 自行车很方便。(指“自行车”这一类交通工具)</li><li><strong>L’homme</strong> est mortel. 人难免一死.(指所有人)</li></ol><ul><li><p>Dans certaines phrases spécifiques, les phrases qui n’utilisaient pas d’articles à l’origine ont été ajoutées avec des articles indéfinis pour exprimer des significations rhétoriques supplémentaires.<br>在某些特定的词组中，为了表达附加上的修辞意义，原先并不使用冠词的，反而要加上不定冠词。</p><ul><li>Example:</li></ul></li></ul><ol><li>La petite a <strong>une grande</strong> peur. 小女孩非常害怕。</li><li>Le garçon a <strong>une</strong> soif <strong>incroyable</strong>. 小男孩口干舌燥。</li><li>Nous avons <strong>une</strong> faim <strong>énorme</strong>. 我们饥渴难耐。</li></ol><ul><li><p>Dans l’utilisation quotidienne, l’article indéfini et l’article défini ne sont jamais opposés, ils sont souvent entrelacés pour exprimer la subordination entre les choses, la relation plus limitée ou d’autres relations logiques implicites.<br>而在日常的使用中，不定冠词和定冠词绝不是对立的，它们往往交织在一起，表达事物与事物之间的从属关系，更进一步的限定关系或是其他暗含的逻辑关系。</p><ul><li>Example:</li></ul></li></ul><ol><li>un manuel <strong>de</strong> français. 一本法语教材</li><li>le manuel de français  <strong>de</strong> ma sœur. 我姐姐的法语教材</li><li>Je veux <strong>une</strong> orange. 我想要一只橙子。</li><li>Je veux <strong>l’</strong> orange qui est là. 我想要放在那儿的橙子。</li></ol><ul><li><p>Omettre les articles avant les noms dirigés par des adverbes spécifiques ou des phrases représentant des quantités.<br>在一些由特定副词或表示数量的词组引导的名词前，省去冠词。</p><ul><li>Example:</li></ul></li></ul><ol><li>Nous avons <strong>beaucoup de</strong> vacances. 我们的假期很多。</li><li>Elle achète <strong>peu de</strong> cahiers. 她买了很少的本子。</li><li>Tu as <strong>trop de</strong> questions. 你的问题太多了。</li><li>Il a <strong>assez d’</strong> argent. 他有足够的钱。</li><li>L’enfant a<strong>un peu de</strong> monnaie. 这个孩子有一点儿钱。</li><li>J’achète <strong>deux bouteilles de</strong> vin. 我买了两瓶葡萄酒。</li></ol><ul><li><p><strong>Article condensé</strong>: désigne une nouvelle forme formée par la combinaison de la préposition à ou de et de l’article défini, qui est dérivée et différente de l’article défini.<br><strong>缩合冠词</strong>：是指介词à或de分别和定冠词组合之后形成的一种新形式，可谓是出之于定冠词，又与之有别。<br><img src="/2022/07/04/fran%C3%A7ais/img_1.png" alt="article condensé"></p><ul><li>Example:</li></ul></li></ul><ol><li>Elle va <strong>au</strong> cinéma. 她去看电影。(aller à)</li><li>Nathalie est <strong>à la</strong> piscine. 娜塔莉在游泳池。(être à)</li><li>Nous avons besoin <strong>des</strong> manuelsde français. 我们需要法语教材。(avoir besoin de)</li><li>Les touristes ont peur <strong>de la</strong> tempête. 旅游者都害怕暴风雨。(avoir peur de)</li><li>Mon frère s’intéresse <strong>aux</strong> mathématiques. 我哥哥对数学感兴趣。(s’intéresser à)</li></ol><ul><li><p>En français, conditions d’utilisation de certains articles :<br>Tout d’abord, l’utilisation d’articles partiels doit être un nom incommensurable ;<br>Deuxièmement, les verbes qui guident ce nom incommensurable doivent être des verbes qui peuvent exprimer le sens d’une « utilisation partielle ».<br>法语中，部分冠词使用的条件：<br>首先，使用部分冠词的必须是不可数名词；<br>其次，引导这一不可数名词的动词必须是可以表达“部分使用”之意的动词。</p></li><li><p>Example:</p></li></ul><ol><li>J’aime <strong>le</strong> café. 我喜欢咖啡。</li><li>Je veux <strong>du</strong> café． 我想喝些咖啡。</li><li>J‘aimerais <strong>du</strong> café． 我想喝些咖啡。</li></ol><h1 id="L’imperatif-命令式"><a href="#L’imperatif-命令式" class="headerlink" title="L’impératif 命令式"></a>L’impératif 命令式</h1><p>L’impératif est une forme de langage. Il existe deux formes de temps: Le présent et le passé. Ce chapitre se concentre sur le présent impératif.<br>命令式是一种语式。它有两种时态形式：现在时和过去时。本章主要研究命令式的现在时。</p><ul><li>Lorsque nous avons besoin d’exprimer des attitudes subjectives telles que la commande / interdiction / demande / encouragement, nous pouvons utiliser l’impératif.<br>当我们需要表达命令/禁止/请求/鼓励等主观态度时，可以使用命令式：</li></ul><ol><li><strong>Parlez</strong> fort! 说大声一点！(命令)</li><li>Ne <strong>fumez</strong> pas! 请勿吸烟！(请求)</li><li><strong>Donne</strong>-moi de l’eau, s’il te plaît! 请给我些水！(请求)</li><li><strong>Sois</strong> courageux! 勇敢些！(鼓励)</li></ol><ul><li><p>Le présent impératif de chaque verbe n’a que trois formes de conjugaison, à savoir le singulier de deuxième personne, le pluriel de première personne et le pluriel de deuxième personne. En général, la conjugaison de l’impératif n’utilisent que l’expression présente directe du verbe, mais les pronoms personnels doivent être supprimés.<br>每一个动词的命令式现在时都只有三种变位形式，即第二人称单数，第一人称复数，第二人称复数。通常情况下，命令式的变位只用动词的直陈式现在时，但必须删去人称代词。</p></li><li><p>Example:</p></li></ul><ol><li><strong>Prends</strong> du café! 你喝些咖啡吧！ (第二人称单数)</li><li><strong>Allons</strong> au cinéma! 我们去看电影吧！(第一人称复数)</li><li><strong>Restez</strong> tranquille! 你们安静些！(第二人称复数)</li></ol><ul><li>Il y a cependant des exceptions pour le premier groupe de verbes et pour les verbes qui se terminent en partie par <strong><em>-ir</em></strong> (par exemple, ouvrir, offrir, cueillir, souffrir, couvrir). Les formes singulières de la deuxième personne de ces verbes se terminent maintenant par - es et doivent être supprimées lorsqu’elles sont converties en formes impératives.<br>不过，对于第一组动词以及部分以 <strong><em>-ir</em></strong> 结尾的动词（例如ouvrir，offrir，cueillir，souffrir，couvrir）来说，情况有些例外。这些动词的单数第二人称直陈式现在时变为都是以-es结尾的，再转换成命令式时，必须删去词尾的s：</li></ul><ol><li>parler 👉 tu parles 👉 <strong>Parle</strong> !</li><li>ouvrir 👉 tu ouvres 👉 <strong>Ouvre</strong> !</li><li>offrir 👉 tu offres 👉 <strong>Offre</strong> !</li></ol><ul><li>Toutefois, si le verbe ci - dessus est suivi d’un sous - pronom en ou y dans l’ordre, la lettre finale s est conservée en raison de la prononciation.<br>但如果上述这些动词在命令式中后接副代词en或y的话，由于发音关系，词尾字母s则要继续保留：</li></ul><ol><li>tu y entres 👉 <strong>Entres-y</strong>!</li><li>tu en manges 👉 <strong>Manges-en</strong>!</li><li>tu em offres 👉 <strong>Offres-en</strong>!</li></ol><ul><li>Bien que le verbe aller ne fasse pas partie du premier groupe de verbes, mais se référer également aux règles correspondantes du premier groupe de verbes dans l’impératif<br>虽然动词aller不属于第一组动词，但也参照第一组动词在命令式中的相应规则：</li></ul><ol><li>tu vas 👉 <strong>Va</strong>!</li><li>tu y vas 👉 <strong>Vas-y</strong>!</li></ol><ul><li><p>Conjugaison de spécial à mémoriser.<br>需特殊记忆的变位形式:<br><img src="/2022/07/04/fran%C3%A7ais/img_2.png" alt="Conjugaison spécial"></p></li><li><p>Dans la pratique, il arrive que le négatif impératif prend la forme de non - finitions. La négation impérative ajoute également ne…pas après le verbe. Pas, c’est - à - dire que la négation impérative commence toujours par ne.<br>在实际使用中，有时命令式是以否定式的形式出现的。命令式否定式也是在动词的前后加上ne…pas，也就是说，命令式否定式总是以ne开头的：</p></li></ul><ol><li>Ne sors pas! 你别出去！</li><li>N’y va pas! 你别去那儿！</li><li>N’ayez pas peur! 您别怕！</li><li>Ne vendons pas notre appartement! 我们别卖房子！</li></ol><ul><li>Pour éviter la répétition, nous devons parfois utiliser des pronoms personnels.<br>Si vous avez besoin d’exprimer des commandes à une troisième personne, vous devez utiliser le virtuel。<br>为了避免重复，有时在命令式中我们需要使用一些人称代词。<br>如果需要对第三人称表达命令的话，我们需要使用虚拟式：</li></ul><ol><li>Qu’il parle! 让他说！(第三人称单数)</li><li>Qu’elles fassent vite leurs devoirs! 让她们快点做作业！(第三人称复数)</li></ol><ul><li>Express present / simple future / infinitive peut exprimer des commandes.<br>直陈式现在时/简单将来时/不定式都可以表达命令：</li></ul><ol><li>Vous finissez tout d’abord vos devoirs. 你们首先先做完作业。(直陈式现在时)</li><li>Tu achèteras du pain, s’il te plaît! 请你买些面包！(直陈式简单将来时)</li><li>Couper le jambon en morceaux. 把火腿切成小块。(动词不定式)</li></ol><h1 id="Les-verbes-pronominaux-代动词"><a href="#Les-verbes-pronominaux-代动词" class="headerlink" title="Les verbes pronominaux 代动词"></a>Les verbes pronominaux 代动词</h1><p>Les verbes pronominaux sont des verbes avec des pronoms personnels réflexifs, qui sont une sorte de verbes spéciaux.<br>代动词是指有自反人称代词的动词，是一类特殊的动词。<br>La conjugaison des verbes pronominaux implique deux parties, l’une est la modification de la partie réflexive du pronom personnel, l’autre est la conjugaison de la partie du verbe, les deux doivent faire des changements correspondants en fonction de la personne du sujet.<br>代动词的动词变位牵涉到两部分内容，一是自反人称代词部分的变化，二是动词部分的变位，两者都必须根据主语人称作出相应的变化。</p><ul><li><p>Dans l’infinitif du pronom, nous utilisons se pour exprimer le pronom personnel réflexif, tandis que dans la transposition concrète du verbe, nous changeons en fonction de la personne du sujet de différents sexes.<br>在代动词的不定式中，我们用se来表示自反人称代词，而在具体的动词变位中则根据不同性数的主语人称进行变化，即：<br><img src="/2022/07/04/fran%C3%A7ais/img_3.png" alt="conjugaison de pronomiaux"></p></li><li><p>Cependant, lorsque le verbe contemporain apparaît directement dans la phrase sous forme d’infinitif, le pronom réflexif se doit également correspondre aux différents sexes de la personne du sujet, tandis que la partie du verbe reste inchangée.<br>不过，当代动词以不定式的形式直接出现在句子中时，自反人称代词se也必须和主语人称进行性数配合，而动词部分则保持不变。</p></li><li><p>Example:</p></li></ul><ol><li>Je vais <strong>me reposer</strong>. 我马上要休息了。</li><li>Vous allez <strong>vous coucher</strong>. 你们马上要睡觉了。</li><li>Ils vont <strong>se lever</strong>. 他们马上要起床了。</li></ol><ul><li><p>Nous considérons toujours les pronoms personnels réflexifs et les verbes comme un tout. Par conséquent, dans la phrase négative, il est nécessaire de placer ne devant le pronom personnel réflexif et pas derrière le verbe.<br>我们始终将代动词中的自反人称代词和动词看成一个整体。因此，在否定句中，需要吧ne放在自反人称代词的前面，pas放在动词的后面。</p></li><li><p>Example:<br>Je me couche. 👉 Je <strong>ne</strong> me couche <strong>pas</strong>.</p></li><li><p>De même, dans la question de l’inversion du sujet et du prédicat, le pronom personnel réflexif est placé devant le verbe, c’est - à - dire que nous considérons le pronom personnel réflexif comme faisant partie du verbe, puis nous effectuons l’inversion du sujet et du prédicat sur cette base.<br>同样，在主谓倒置式的疑问句中，自反人称代词放在动词的前面，也就是说，我们将自反人称代词视为动词的一部分，然后再在此基础上进行主谓倒置。</p></li><li><p>Example:<br>Tu te laves. 你洗澡。 👉 Te laves-tu? 你洗澡吗？</p></li><li><p>Derrière le verbe, et le pronom personnel de la deuxième personne singulière te doit être réécrit dans sa forme de relecture toi. Dans la forme de l’ordre de négation, le pronom personnel réflexif est toujours placé devant le verbe, et il n’y a pas de changement de forme.<br>而在肯定命令式中，自反人称代词放在动词后面，单数第二人称的人称代词te则要改写成它的重读形式toi。再否定命令形式中，自反人称代词仍放在动词的前面，且没有任何形式上的变化。</p></li><li><p>Example:</p></li></ul><ol><li>Lève-<strong>toi</strong>! 你起床！</li><li>Ne <strong>te</strong> lève pas! 你别起床！</li></ol><ul><li>Les pronoms eux - mêmes peuvent être divisés en quatre catégories.<br>代动词本身又可以分为四类。</li></ul><ol><li>Les <strong>sens réflexif</strong> verbes pronominaux indique que l’action est appliquée à l’acteur lui - même, c’est - à - dire au sens réflexif du sujet. À ce stade, le pronom personnel réflexif dans le pronom peut être l’objet direct du verbe ou l’objet indirect du verbe.<br><strong>自反意义</strong>代动词表示动作施加于施动者本身，也就是自反于主语的意思。这时，代动词中的自反人称代词可以是动词的直接宾语，也可以是动词的间接宾语。</li></ol><ul><li>Example:<br>Je <strong>me</strong> couche. 我睡觉。(me为直接宾语)<br>Il <strong>se</strong> brosse les dents. 他刷牙。(se时间接宾语，le dents为动词brosser的直接宾语)<br>判断自反意义代动词中的直接宾语或间接宾语的关键是看动词后面有没有宾语，如果有，这个宾语就是直接宾语，自反人称代词则为间接宾语；倘若没有，自反人称代词则为直接宾语。</li></ul><ol><li>Les <strong>sens mutuel</strong> verbes pronominaux indique que l’action se produit entre les sujets. Nous pouvons donc juger que le sujet du verbe pronom de sens mutuel est pluriel, ou que le pronom personnel est le pronom on qui représente le concept pluriel. De même, les pronoms personnels réflexifs dans les pronoms de sens mutuel peuvent être soit des objets directs, soit des objets indirects.<br><strong>相互意义</strong>代动词表示动作发生在主语之间。我们由此可以判断出，相互意义代动词的主语复数的，或者是表示复数概念的人称代词on。同样，相互意义代动词中的自反人称代词既可以是直接宾语，也可以是间接宾语。</li></ol><ul><li>Example:<br>Vous <strong>vous</strong> regardez. 你们四目相对。(vous为直接宾语)<br>Ils <strong>s</strong>‘écrivent. 他们相互写信。(se是间接宾语)<br>判断相互意义代动词中的直接宾语或间接宾语的关键是看动词本身亦不敢改后接直接宾语还是间接宾语。在以上的两个例句中，动词regarder的搭配是regarder quelqu‘un，因此，剧中的vous为直接宾语。而动词écrire à  quelqu’un,所以，句子中的se为间接宾语。</li></ul><ol><li>Les <strong>sens passif</strong> verbes pronominaux indique que l’action est passive, ce qui équivaut à la voix passive.<br><strong>被动意义</strong>代动词表示动作是被动的，相当于被动语态。</li></ol><ul><li>Example:<br>La fenêtre <strong>se</strong> ferme. 窗关上了。</li></ul><ol><li>Les <strong>sens absolu</strong> verbes pronominaux personnels réflexifs dans les pronoms sont inhérents aux pronoms et n’expriment aucun sens grammatical.<br><strong>绝对意义</strong>代动词中的自反人称代词是代动词所固有的，不表达任何语法上的意义。</li></ol><ul><li>Example:<br>Il <strong>s</strong>‘en va. 他走了。</li></ul><h1 id="Pronoms-personnels-complements-d’objet-indirect-简介宾语人称代词"><a href="#Pronoms-personnels-complements-d’objet-indirect-简介宾语人称代词" class="headerlink" title="Pronoms personnels compléments d’objet indirect -, 简介宾语人称代词"></a>Pronoms personnels compléments d’objet indirect -, 简介宾语人称代词</h1><ol><li>间接宾语人称代词的形式<br>| 人称 | 单数形式 | 复数形式 |<br>|:——-:|:——-:|:——-:|<br>| 第一人称 | me(m‘) | nous |<br>| 第二人称 | te(t’) | vous |<br>| 第三人称 | lui | leur |</li><li>主要用法<br>间接宾语热诚代词一般用来代替介词à及其引导的指人的间接宾语，一般置于相关<strong>动词之前</strong>。</li></ol><ul><li>Example:<br>1) Paul <strong>nous</strong> donne ses livres. (nous = à nous) 保罗把他的书给了我们。<br>2) Est-ce que tu peux <strong>m’</strong> apporter du thé, s’il te plaît? (m’ = à moi) 你能给我带点茶来吗？</li></ul><p>注意：间接宾语人称代词不可以用来代替带此时动词的间接宾语，以及penser à等短语中的间接宾语：在以上情况中，须使用à+重读人称代词作为间接宾语。<br>1) Li Ming a recentré des problèmes, donc il s’adresse à moi.<br>2) - À qui penses-tu? À tes parents ? 你在香水？你的父母吗？</p><ul><li>Oui, je pense à eux. 是的，我在想念他们。</li></ul><ol><li>命令式肯定句中的间接宾语人称代词<br>在<strong>命令式肯定句</strong>中，间接宾语人称代词置于<strong>动词之后</strong>，并使用连字符-引导；<strong>如果间接宾语人称代词为me或te，则应使用重读形式moi或toi</strong>。</li></ol><ul><li>Example:<br>1) Envoyez-lui cette le titre ! 把这封信寄给他.<br>2) Passe-moi le journal ! 把报纸递给我！</li></ul><h1 id="C’est…qui-C’est…que-强调句型"><a href="#C’est…qui-C’est…que-强调句型" class="headerlink" title="C’est…qui / C’est…que - 强调句型"></a>C’est…qui / C’est…que - 强调句型</h1><p>当需要突出强调句子中的某一成分时，可采用强调句型c’est…qui或c’est…que，以唤起对方的注意；需要注意的是，该句型不可强调谓语。</p><ol><li>强调主语用<strong>c’est…qui</strong>，句中动词需要与主语进行配合；在口语表达中，c‘est可以代替ce sont.</li></ol><ul><li>Example:<br>1）Olivia a donné des renseignements à Li Ming. 奥维莉雅给黎明提供了信息。<br>👉 <strong>C’est</strong> Olivia <strong>qui</strong> a donné des renseignements à Li Ming.<br>是奥维莉雅给李明提供了信息。<br>2）J’ai besoin d’ouvrir un compte bancaire. 我需要开一个银行账户。<br>👉 <strong>C’est</strong> moi <strong>qui</strong> ai besoin d’ouvrir un compte bancaire.<br>是我需要开银行账户。<br>3）Ces chemises me plaisent beaucoup. 我喜欢这些衬衣。<br>👉 <strong>Ce sont</strong> ces chemises <strong>qui</strong> me plaisent beaucoup.<br>我喜欢的正是这些衬衣。<br>注意：主语人称代词在C’est…qui结构中，应变为重读人称代词形式。</li></ul><ol><li>强调直接宾语、间接宾语、状语、表语用<strong>c’est…que</strong>。</li></ol><ul><li>Example:<br>1）Nous avons rencontré un célèbre médecin hier. 我们昨天遇见了一个著名的医生。<br>👉 <strong>C’est</strong> un célèbre médecin <strong>que</strong> nous avons rencontré hier.<br>我们昨天遇见的是一个著名的医生。<br>2）Elles sont partis en vacances avec leurs copines. 他们跟朋友出发去度假了。<br>👉 <strong>C’est</strong> avec leurs copines <strong>qu</strong>‘elles sont partis en vacances.<br>他们是跟朋友们出发去度假的。<br>3）Nous ne sommes pas venus, parce qu’il a plu.<br>我们没来，因为下雨了。<br>👉 <strong>C’est</strong> parce qu’il a plu <strong>que</strong> nous ne sommes pas venus.<br>是因为下雨了我们才没有来。<br>4）Pour ouvrir un compte bancaire, Li Ming s’adresse à Olivia. 为了开银行账户，李明求助于奥莉薇娅。<br>👉 Pour ouvrir un compte bancaire, <strong>C’est</strong> à Olivia <strong>que</strong> Li Ming s’adresse.<br>为了开银行账户，李明是奥莉薇娅求助的。</li></ul><h1 id="Pronoms-personnels-comportement-d’objet-direct-直接宾语人称代词"><a href="#Pronoms-personnels-comportement-d’objet-direct-直接宾语人称代词" class="headerlink" title="Pronoms personnels comportement d’objet direct - 直接宾语人称代词"></a>Pronoms personnels comportement d’objet direct - 直接宾语人称代词</h1><ol><li>直接宾语人称代词的形式<br>| 人称 | 单数形式 | 复数形式 |<br>|:——-:|:——-:|:——-:|<br>| 第一人称 | me(m‘) | nous |<br>| 第二人称 | te(t’) | vous |<br>| 第三人称 | le/la(l’) | les |</li><li>主要用法<br>直接宾语人称代词一般用来代替指人或事物的直接宾语。与间接宾语人称代词相同，直接宾语人称代词一般置于相关<strong>动词之前</strong>。</li></ol><ul><li>Example:<br>1）Je <strong>vous</strong> aime. 我爱你们。<br>2）Quelles belles fleurs! Je vais <strong>les</strong> donner à maman. 多美的花！我要把他们送给妈妈。<br>3）Hier, il <strong>m</strong>‘a rencontré dans la rue. 昨天，他在街上碰见了我。</li></ul><ol><li>命令式在肯定句中的直接宾语人称代词<br>在<strong>命令式肯定句</strong>中，直接宾语人称代词置于<strong>动词之后</strong>，并使用连字符“-”引导；<strong>如果直接宾语人称代词为me或te，则应使用其重读形式moi或toi</strong>。</li></ol><ul><li>Example:<br>1）Regarde-moi! 看着我！<br>2）Suivez-la! 跟着她！</li></ul><h1 id="Accord-du-participe-passe-dans-le-temps-compose-复合时态中过去分词的配合1-以-avoir-为助动词的复合时态中，过去分词的配合"><a href="#Accord-du-participe-passe-dans-le-temps-compose-复合时态中过去分词的配合1-以-avoir-为助动词的复合时态中，过去分词的配合" class="headerlink" title="Accord du participe passé dans le temps composé 复合时态中过去分词的配合1. 以 avoir 为助动词的复合时态中，过去分词的配合"></a>Accord du participe passé dans le temps composé 复合时态中过去分词的配合1. 以 avoir 为助动词的复合时态中，过去分词的配合</h1><p>在以 avoir 为助动词的复合时态中，过去分词通常不变；但是当直接宾语位于 avoir 之前时，过去分词需要与前置的直接宾语进行性数配合。<br>1） Combien de livres as-tu lus ? 你读了几本书？<br>2） C’est la leçon 5 que nous avons apprise hier. 我们昨天学的是第五课。<br>3） Ces formulaires, je les ai déjà remplis. 这些表格，我已经填了。</p><ol><li>以 être 为助动词的复合时态中，过去分词的配合<br>在以 être 为助动词的复合时态中，过去分词通常须与主语进行性数配合；但当代词式动词中的自反代词 se 是动词的间接宾语时，过去分词保持不变。<br>1） Elle s’est lavée en 20 minutes. 她洗澡用了 20 分钟。<br>Elle s’est lavé les mains avant le repas. 她饭前洗了手。<br>2） Elles se sont rencontrés dans la rue, mais elles ne se sont pas dit bonjour.<br>她们在街上相遇了，但没有打招呼。</li><li>表示位置移动的动词，过去分词的配合有些表示位移的动词既可使用 avoir 做助动词，又可使用être 做助动词。当动词有直接宾语时，需要使用 avoir 做助动词，此时过去分词不与主语配合；当动词没有直接宾语时，需要使用être 做助动词，此时过去分词与主语配合。<br>1） Elle est montée au deuxième étage. 她上了三楼。<br>2） Elle a monté une chaise au deuxième étage. 她把一把椅子搬到了三楼。<br>3） Elle est sortie de bonne heure. 她一大早就出去了。<br>4） Elle a sorti les vêtements de bonne heure. 她一大早就把衣服拿出来了。</li></ol><h1 id="la-voix-passive-被动态"><a href="#la-voix-passive-被动态" class="headerlink" title="la voix passive 被动态"></a>la voix passive 被动态</h1><ol><li><p>形式<br>法语有两大语态：主动态（la voix active）和被动态（la voix passive）。当句子的主语是动作的施动者时，该句子为主动态；主语是动作的承受者时，该句为被动态。被动态的构成方式如下：<br>être+（直接及物）动词的过去分词（+par/de+施动者补语），如：<br>1) Le contrat est signé par Jacques.<br>2) Paris est traversé par la Seine.</p></li><li><p>过去分词的配合<br>在被动态句子，过去分词必须与主语在性、数上进行配合，如：<br>1) Cette lettre est écrite par son ami.<br>2) Les étudiants étrangers sont reçus par ce prof.</p></li><li><p>时态<br>被动态的时态由助动词être的时态变化展现，如：<br>1) La maison a <strong>été</strong> construire par mon grand-père. （直陈式复合过去时）<br>2) La tarte aux pommes <strong>est</strong> préparée par une pâtissière très connue. （直陈式现在时）<br>3) Votre demande ne peut pas <strong>être</strong> acceptée par une notre banque. （不定式）</p></li><li><p>施动者补语<br>1) 大部分情况下，被动态的施动者补语由介词par引出。<br>2) 如果被动态的动词表示状态、认知、情感等，则施动者补语由介词de引出。<br>3) 当施动者补语未知或不需要强调时，可将其省略。</p></li></ol><h1 id="Simples-时态"><a href="#Simples-时态" class="headerlink" title="Simples 时态"></a>Simples 时态</h1><h2 id="Le-passe-compose-直陈式复合过去时"><a href="#Le-passe-compose-直陈式复合过去时" class="headerlink" title="Le passé composé 直陈式复合过去时"></a>Le passé composé 直陈式复合过去时</h2><p>Le passé composé indique les actions qui se sont produites et qui ont été accomplies au cours d’une période définie dans le passé.<br>复合过去时表示过去起止时间明确的某一段时间内发生并完成的动作。<br>Composition : la forme expressive du verbe auxiliaire avoir ou celui - ci est maintenant + le participant passé du verbe.<br>构成：助动词avoir或être的直陈式现在时+动词的过去分词。</p><ul><li>La formation du participant passé<br>过去分词的构成：<br>(1). 第一组动词去掉词尾的-er加上-é:&lt;/br&gt; regarder 👉 regardé<br>(2). 第二组动词去掉词尾的-ir加上-i:&lt;/br&gt; finir 👉 fini<br>(3). 常用的不规则动词的过去分词&lt;/br&gt;</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">avoir 👉 eu</td><td style="text-align:center">vouloir 👉 voulu</td><td style="text-align:center">voir 👉 vu</td></tr><tr><td style="text-align:center">être 👉 été</td><td style="text-align:center">prendre 👉 pris</td><td style="text-align:center">pouvoir 👉 pu</td></tr><tr><td style="text-align:center">faire 👉 fait</td><td style="text-align:center">boire 👉 bu</td><td style="text-align:center">pleuvoir 👉 plu</td></tr><tr><td style="text-align:center">dire 👉 dit</td><td style="text-align:center">lire 👉 lu</td><td style="text-align:center">recevoir 👉 reçu</td></tr><tr><td style="text-align:center">devoir 👉 dû</td><td style="text-align:center">tenir 👉 tenu</td><td style="text-align:center">offrir 👉 offert</td></tr><tr><td style="text-align:center">savoir 👉 su</td><td style="text-align:center">connaître 👉 connu</td><td style="text-align:center">ouvrir 👉 ouvert</td></tr></tbody></table></div><ul><li>Verbes avec avoir comme auxiliaire.<br>以avoir为助动词的动词：<br>La plupart des verbes utilisent avoir comme auxiliaire.<br>大部分动词都使用avoir作为助动词。</li></ul><ul><li><p>Verbes avec être comme auxiliaire.<br>以être为助动词的动词：<br>(1). Verbe transitionnel représentant un déplacement de position ou un changement d’état.<br>表示位置移动或状态变化的及物动词：<br>aller, venir, entrer, sortir, monter, descendre, arriver, partir, passer, rester, tomber, mourir, naître, apparaître(包括他们的派生词：devenir, revenir, rentrer…)<br><strong>Note</strong>: certains de ces verbes peuvent également être utilisés comme verbes transitifs, suivis d’objets directs, et maintenant utiliser avoir comme verbes auxiliaires.<br><strong>注意</strong>：这些动词中有些也可以作及物动词，后跟直接宾语，此时用avoir作助动词：</p></li><li><p>Example:<br>Je suis montré en haut de la tour Eiffel. 我登上埃菲尔铁塔的高处。<br>Le garçon de l’hôtel amontre les valises dans la chambre. 旅馆的男侍将行李送到了房间。<br>Béatrice est passée chaz moi à 8 h. 贝亚特莉丝八点来过我家。<br>On a passé toute la matinée à l’hôpital. 我们在医院度过了整整一个上午。</p><p>(2). Tous les pronoms.所有的代动词：<br>se laver, s’assoir, se souvenir…</p></li><li><p>Example:<br><img src="/2022/07/04/fran%C3%A7ais/img_4.png" alt="examples de les verbes pronominaux"></p></li></ul><p><strong>Note</strong><br><strong>注意</strong>：</p><ul><li>La phrase négative est placée des deux côtés du verbe auxiliaire dans la phrase négative.<br>否定句中否定短语置于助动词两边：<br>Elle <strong>n’a pas réussi</strong> ses examens. 她没有顺利通过考试。<br>Je <strong>ne suis pas allé</strong> à l’université hier. 昨天我没有去上大学。<br>Je <strong>ne me suis pas réveillé</strong> à 7 heures ce matin. 今天早晨7点钟我还没有睡醒。</li><li>Verbes auxiliaires et inversion du sujet dans les phrases interrogatives.<br>疑问句中助动词与主语倒装：<br>As-tu trouvé test clés ? 你找到钥匙了吗？<br>À quelle heure êtes-vous arrivé ? 您几点钟到的？<br>Quand s’est-elle couchée ? 她什么时候上床休息的？</li></ul><h2 id="imparfait-未完成过去时"><a href="#imparfait-未完成过去时" class="headerlink" title="imparfait 未完成过去时"></a>imparfait 未完成过去时</h2><ol><li>构成<br>动词直陈式现在时第一人称复数形式去掉此为-ons，再按人称je，tu，il/elle，nous，vous，ils/elles顺序加：-ais, -ais, -ait, -ions, -iez, -aient</li></ol><ul><li>Example:<br><img src="/2022/07/04/fran%C3%A7ais/img_5.png" alt="exmaples"><br>注意：1）être的未完成过去时为特殊形式</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">j’étais</td><td style="text-align:center">nous étions</td></tr><tr><td style="text-align:center">tu étais</td><td style="text-align:center">vous étiez</td></tr><tr><td style="text-align:center">il/elle était</td><td style="text-align:center">ils/elles étaient</td></tr></tbody></table></div><p>2）下列动词未完成过去时的变化。</p><div class="table-container"><table><thead><tr><th style="text-align:center">commencer</th><th style="text-align:center">je commençais</th></tr></thead><tbody><tr><td style="text-align:center">manger</td><td style="text-align:center">je mangeais</td></tr><tr><td style="text-align:center">étudier</td><td style="text-align:center">j’étudiais</td></tr></tbody></table></div><ol><li>用法<br>1）表示过去的状态，描写过去事件的背景。<br>a. Hier, il faisait froid. Le ciel était gris. Il y avait peu de monde dans la rue.<br>昨天，天气很冷，天空阴沉，街上几乎没有人。<br>b. Avant, il habitait en ville.<br>以前，他住在城里。<br>2） 表示在过去一段时间里，习惯或重复性的动作。<br>a. Pendant les vacances, il se levait toujours à 8 heures du matin.<br>在假期中，他总是早上 8 点起床。<br>b. Avant, sa soeur travaillait à Paris. Il allait la voir deux fois par mois.<br>过去，他的姐姐在巴黎工作，他每月去看她两次。<br>c. Il sortait souvent avec ses copains quand il était au lycée.<br>他上高中时，经常与同伴出去玩。<br>3） 在复合句中，与复合过去时配合使用。未完成过去时表示在过去时间中持续进行的动作，而复合<br>过去时表示过去一次性发生并完成的动作。<br>a. Il est arrivé pendant que j’écoutais de la musique.<br>在我听音乐的时候，他来了。<br>b. Il pleuvait quand je me suis réveillé.<br>当我醒来的时候，正在下雨。</li></ol><h2 id="Le-futur-simple-简单将来时"><a href="#Le-futur-simple-简单将来时" class="headerlink" title="Le futur simple 简单将来时"></a>Le futur simple 简单将来时</h2><ol><li><p>形式</p><p>直陈式简单将来时的变为通常是在动词不定式后，按照人称顺序加上词尾-ai, -as, -a, -ons, -ez, -ont构成。如果动词不定式以e结尾，则需去掉e，然后再加上上述后缀。如：</p><p>|      第一组动词      |    第二组动词     |     第三组动词      |<br>| :—————————: | :———————-: | :————————-: |<br>|       arriver        |       finir       |       prendre       |<br>|     j’arriverai      |    je finirai     |     je prendrai     |<br>|     tu arriveras     |    tu finiras     |     tu prendras     |<br>|   il/elle arrivera   |  il/elle finira   |   il/elle prendra   |<br>|   nous arriverons    |   nous finirons   |   nous prendrons    |<br>|    vous arriverez    |   vous finirez    |    vous prendrez    |<br>| ils/elles arriveront | is/elles finiront | ils/elles prendront |</p><p>1）第一组动词变位的特殊形式</p><p>| 动词不定式 | 第一人称单数 |   第一人称复数   |    其他变位方式相同的动词    |<br>| :————: | :—————: | :———————: | :—————————————: |<br>|   amener   |  j’amènerai  |  nous amènerons  | mener, lever, acheter, geler |<br>|  appeier   | j’appellerai | nous appellerons | jeter, rappeler, renouveler  |<br>|  essayer   | j’essaierai  | nous essaierons  |  payer, nettoyer, employer   |<br>|  envoyer   |  j’enverrai  |  nous enverrons  |           renvoyer           |</p><p>2）第三组常见动词变位的特殊形式</p><p>| 动词不定式 |          第一人称单数           |                 第一人称复数                 |<br>| :————: | :——————————————-: | :—————————————————————: |<br>|   aller    |             j‘irai              |                  nous irons                  |<br>|    être    |            je serai             |                 nous serons                  |<br>|   faire    |            je ferai             |                 nous ferons                  |<br>|   avoir    |             j’aurai             |                 nous aurons                  |<br>|   savoir   |            je saurai            |                 nous saurons                 |<br>|   tenir    |           je tiendrai           |                nous tiendrons                |<br>|   venir    |           je viendrai           |                nous viendons                 |<br>|   devoir   |            je devrai            |                 nous devrons                 |<br>|  recevoir  |           je recevrai           |                nous recevrons                |<br>|   courir   |           je courrai            |                nous courrons                 |<br>|  pouvoir   |           je pourrai            |                nous pourrons                 |<br>|    voir    |            je verrai            |                 nous verrons                 |<br>|  vouloir   |           je voudrai            |                nous voudrons                 |<br>| s’asseoir  | je m’assiérai&lt;/br&gt;je m’assoirai | nous nous assiérons &lt;/br&gt;nous nous assoirons |<br>|   valoir   |           je vaudrai            |                nous vaudrons                 |</p></li><li><p>用法</p><p>简单将来时一般表示将来要发生或可能要发生的动作或状态，如：</p><p>1）Une réunion de rentrée aura lieu après-demain à 14 heurtes. </p><p>开学大会将于后天下午2点召开</p><p>2）Vous devrez passer un test de niveau de français dans 3 jours.</p><p>你们3天后需要参加法语水平测试。</p><p>3）Pierre et Olivia feront un voyage ensemble le mois prochain.</p><p>Pierre和Olivia下个月要一起去旅行。</p></li></ol><h2 id="Le-conditionnel-present-条件式现在时"><a href="#Le-conditionnel-present-条件式现在时" class="headerlink" title="Le conditionnel présent  条件式现在时"></a>Le conditionnel présent  条件式现在时</h2><ol><li><p>形式</p><p>条件式现在时的变位由直陈式简单将来时的词根加上直陈式未完成过去时的词尾构成。如：</p><p>|       第一组动词       | 第二组动词 | 第三组动词 |<br>| :——————————: | :————: | :————: |<br>|        arriver         |   finir    |   aller    |<br>|      j’arriverais      |            |            |<br>|     tu arriverais      |            |            |<br>|   il/elle arriverait   |            |            |<br>|    nous arriveriez     |            |            |<br>|    vous arriveriez     |            |            |<br>| ils/elles arriveraient |            |            |</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 法语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网络攻防]简单的DLL注入实践-干爆扫雷</title>
      <link href="/2022/07/01/NAD-DLL/"/>
      <url>/2022/07/01/NAD-DLL/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：DLL注入技术与网络安全"><a href="#相关叨叨：DLL注入技术与网络安全" class="headerlink" title="相关叨叨：DLL注入技术与网络安全"></a>相关叨叨：DLL注入技术与网络安全</h1><p>对于网络安全的课题，攻与防是同等地位的重要，可攻可受（？）是每一个学习网络安全的~冤种~技术人所应同时具备的能力。<br>而DLL注入技术，一般来讲是向一个正在运行的进程插入/注入代码的过程，可以被正常软件用来添加/扩展其他程序，调试或逆向工程的功能性；该技术也常被恶意软件以多种方式利用。这意味着从安全角度来说，了解DLL注入的工作原理是十分必要的。<br><img src="https://pic1.zhimg.com/80/v2-e7797fe6b55556041e4fc1154691b584_720w.jpg" alt="DLL注入原理与流程（图源网）"></p><h2 id="实验目标与内容"><a href="#实验目标与内容" class="headerlink" title="实验目标与内容"></a>实验目标与内容</h2><p>利用DLL注入，实现扫雷一件通关辅助：</p><ol><li>找到地雷数组所在内存位置；</li><li>数组中的各个值代表的含义；</li><li>实现辅助</li></ol><p>实验拟题来自于 <strong>中国海洋大学 网络攻防先导实践 lab03：简单的DLL注入实践</strong> <em>-by 曲海鹏 等</em></p><h1 id="实验依赖工具"><a href="#实验依赖工具" class="headerlink" title="实验依赖工具"></a>实验依赖工具</h1><h2 id="Windows-消息传递机制"><a href="#Windows-消息传递机制" class="headerlink" title="Windows 消息传递机制"></a>Windows 消息传递机制</h2><p>所谓的Windows消息传递机制就类似于生活中的物流公司。当寄件人（例如鼠标、键盘）将包裹（消息）交给物流公司（Windows系统）时，物流公司（Windows系统）会进行整理并且派发（整理及派发主要由消息循环完成），交给相应的快递员（窗口过程）来处理。快递员（窗口过程）拿到包裹（消息）后则有多种方式来处理，如立马交给收件人，等一天交给收件人，或转交给其他快递派发，这就需要在窗口过程中用switch/case来区分。<br><img src="/2022/07/01/NAD-DLL/img.png" alt="Windows消息传递机制示意"><br><img src="/2022/07/01/NAD-DLL/img_1.png" alt="WIndows消息传递的回调与响应函数"><br>对于通过DLL进行的消息劫持与注入，则需要利用Windows消息传递机制来完成，下述为Windows消息事件的介绍及获取/模拟：</p><h3 id="Windows消息来源相关知识部分应用"><a href="#Windows消息来源相关知识部分应用" class="headerlink" title="Windows消息来源相关知识部分应用"></a>Windows消息来源相关知识部分应用</h3><p>消息可以由系统或者应用程序产生。系统在发生输入事件时产生消息。举个例子, 当用户敲键, 移动鼠标或者单击控件。系统也产生消息以响应由应用程序带来的变化, 比如应用程序改变系统字体，改变窗体大小。应用程序可以产生消息使窗体执行任务，或者与其他应用程序中的窗口通讯。</p><ol><li><p>Windows中，消息使用统一的结构体（MSG）来存放信息，其中message表明消息的具体的类型，<br>&lt;/br&gt;而wParam，lParam是其最灵活的两个变量，为不同的消息类型时，存放数据的含义也不一样。<br>time表示产生消息的时间，pt表示产生消息时鼠标的位置。<br>Windows中消息MSG声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMsg</span><br><span class="line">&#123;</span><br><span class="line">HWND hwnd; // 接受该消息的窗口句柄，告诉操作系统，应该把消息发生给哪个应用 哪个窗口</span><br><span class="line">UINT message; // 消息常量标识符，也就是我们通常所说的消息号</span><br><span class="line">WPARAM wParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">LPARAM lParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">DWORD time; // 消息创建时的时间</span><br><span class="line">POINT pt; // 消息创建时的鼠标/光标在屏幕坐标系中的位置</span><br><span class="line">&#125;MSG;</span><br></pre></td></tr></table></figure></li><li><p>消息类型<br><img src="/2022/07/01/NAD-DLL/img_2.png" alt="消息类型"><br>(1) 窗口消息：即与窗口的内部运作有关的消息，如创建窗口，绘制窗口，销毁窗口等。<br>可以是一般的窗口，也可以是MainFrame,Dialog,控件等。<br>如：WM_CREATE, WM_PAINT, WM_MOUSEMOVE, WM_CTLCOLOR, WM_HSCROLL等.&lt;/br&gt;<br>(2) 当用户从菜单选中一个命令项目、按下一个快捷键或者点击工具栏上的一个按钮，都将发送WM_COMMAND命令消息。<br>LOWORD(wParam)表示菜单项，工具栏按钮或控件的ID；如果是控件, HIWORD(wParam)表示控件消息类型。&lt;/br&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOWORD(l) ((WORD)(l))</span><br><span class="line">#define HIWORD(l) ((WORD)(((DWORD)(l) &gt;&gt; 16) &amp; 0xFFFF))</span><br></pre></td></tr></table></figure><p>(3) 随着控件的种类越来越多，越来越复杂（如列表控件、树控件等），仅仅将wParam，lParam将视为一个32位无符号整数，已经装不下太多信息了。<br>为了给父窗口发送更多的信息，微软定义了一个新的WM_NOTIFY消息来扩展WM_COMMAND消息。<br>WM_NOTIFY消息仍然使用MSG消息结构，只是此时wParam为控件ID，lParam为一个NMHDR指针，<br>不同的控件可以按照规则对NMHDR进行扩充，因此WM_NOTIFY消息传送的信息量可以相当的大。<br>注：Window 9x 版及以后的新控件通告消息不再通过WM_COMMAND 传送，而是通过WM_NOTIFY 传送，<br>但是老控件的通告消息， 比如CBN_SELCHANGE 还是通过WM_COMMAND 消息发送。&lt;/br&gt;<br>(4) windwos也允许程序员定义自己的消息，使用SendMessage或PostMessage来发送消息。&lt;/br&gt;</p></li><li><p>消息队列(Message Queues)<br>Windows中有两种类型的消息队列<br>(1) 系统消息队列(System Message Queue)<br>这是一个系统唯一的Queue，设备驱动(mouse, keyboard)会把操作输入转化成消息存在系统队列中，然后系统会把此消息放到目标窗口所在的线程的消息队列(thread-specific message queue)中等待处理.&lt;/br&gt;<br>(2) 线程消息队列(Thread-specific Message Queue)<br>每一个GUI线程都会维护这样一个线程消息队列。(这个队列只有在线程调用GDI函数时才会创建，默认不创建)。然后线程消息队列中的消息会被送到相应的窗口过程(WndProc)处理.<br>注意： 线程消息队列中WM_PAINT，WM_TIMER只有在Queue中没有其他消息的时候才会被处理，WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。&lt;/br&gt;</p></li><li><p>队列消息(Queued Messages)和非队列消息(Non-Queued Messages)<br>(1) 队列消息(Queued Messages)<br>消息会先保存在消息队列中，消息循环会从此队列中取出消息并分发到各窗口处理<br>如：WM_PAINT，WM_TIMER，WM_CREATE，WM_QUIT，以及鼠标，键盘消息等。<br>其中，WM_PAINT，WM_TIMER只有在队列中没有其他消息的时候才会被处理， WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。&lt;/br&gt;<br>(2) 非队列消息(NonQueued Messages)<br>消息会绕过系统消息队列和线程消息队列直接发送到窗口过程被处理 如： WM_ACTIVATE, WM_SETFOCUS, WM_SETCURSOR， WM_WINDOWPOSCHANGED<br>注意: postMessage发送的消息是队列消息，它会把消息Post到消息队列中； SendMessage发送的消息是非队列消息， 被直接送到窗口过程处理.&lt;/br&gt;</p></li><li><p>窗体函数（WindowProc）<br><img src="/2022/07/01/NAD-DLL/img_3.png" alt="应用程序消息循环（messager loop）"><br>Windows 应用程序创建的每个窗口都在系统核心注册一个相应的窗口函数，窗口函数程序代码形式上是一个巨大的switch 语句，用以处理由消息循环发送到该窗口的消息，窗口函数由Windows 采用消息驱动的形式直接调用，而不是由应用程序显示调用的，窗口函数处理完消息后又将控制权返回给Windows。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//而窗体负责响应消息的函数称为“窗体过程（Window Procedure）”，窗体过程是一个函数，每个窗体一个，它大致拥有以下的“模样”（C++代码）：</span><br><span class="line">LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line"> &#123;</span><br><span class="line">     //……</span><br><span class="line">     switch (uMsg) //依据消息标识符进行分类处理</span><br><span class="line">     &#123;</span><br><span class="line">     case WM_CREATE:</span><br><span class="line">         // 初始化窗体.</span><br><span class="line">         return 0;</span><br><span class="line">     case WM_PAINT:</span><br><span class="line">         // 绘制窗体</span><br><span class="line">         return 0;</span><br><span class="line">         //</span><br><span class="line">         //处理其他消息</span><br><span class="line">         //</span><br><span class="line">     default:</span><br><span class="line">         //如果窗体没有定义处理此种消息的代码，则转去调用系统默认的消息处理函数</span><br><span class="line">         return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> //可以看到，“窗体过程”不过就是一个多分支语句罢了，在这个语句中，窗体对不同类型的消息进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>以上内容来自<a href="https://blog.51cto.com/u_15080034/4353635"><strong>(整理)window 消息传递机制</strong></a><br>~事实上，上述内容我也看的懵懂，大概当个了解~</p><h2 id="Spy"><a href="#Spy" class="headerlink" title="Spy++"></a>Spy++</h2><p>Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。<br><img src="/2022/07/01/NAD-DLL/img_4.png" alt="介个就是spyxx.exe"><br><img src="https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/exp/w=500/sign=7ba3254179cb0a4685228b395b62f63e/64380cd7912397ddd6145fbf5b82b2b7d0a28718.jpg" alt="spyxx界面"></p><p>后续在本实验的应用上，我拿这个用来在创建模拟点击事件时的定位窗口坐标。</p><h2 id="Cheat-Engine"><a href="#Cheat-Engine" class="headerlink" title="Cheat Engine"></a>Cheat Engine</h2><p>Cheat Engine是一款专注于游戏的修改器。它可以用来扫描游戏中的内存，并允许修改它们。它还附带了调试器、反汇编器、汇编器、变速器、作弊器生成、Direct3D操作工具、系统检查工具等。<br><img src="/2022/07/01/NAD-DLL/img_5.png" alt="这个是Cheat Engine"><br><img src="/2022/07/01/NAD-DLL/img_6.png" alt="CE界面"></p><p>针对游戏的修改器/辅助器/或你叫它什么都好，总之要想达到作弊的效果，最重要的当然是要分析破译游戏内存数据所代表的含义，并能精准定位所要实现修改的内存存放地址，因此在后续的操作中，Cheat Engine扮演了十分重要的角色。</p><h2 id="Xenos"><a href="#Xenos" class="headerlink" title="Xenos"></a>Xenos</h2><p>《Xenos》是2007年池泽辰也执导的悬疑片，由海东键、一戸奈美、堀田ゆい夏等主演。<br><img src="/2022/07/01/NAD-DLL/img_7.png" alt="Xenos"></p><font size="3">...当然，不可能是这个"Xenos"</font><p>我们所要介绍的Xenos，是用来进行DLL注入的软件，长这样：<br><img src="/2022/07/01/NAD-DLL/img_8.png" alt="这个才是注入器Xenos"><br><img src="/2022/07/01/NAD-DLL/img_9.png" alt="Xenos界面"></p><p>这个工具，则是帮助我们将写好的DLL类型文件对程序进行注入。</p><p>以上，则是本次实验/本类型任务的基本搭建环境和操作工具，接下来正式进入对本实验的分析与实践。</p><h1 id="实验分析：让俺看看扫雷背后都有啥"><a href="#实验分析：让俺看看扫雷背后都有啥" class="headerlink" title="实验分析：让俺看看扫雷背后都有啥"></a>实验分析：让俺看看扫雷背后都有啥</h1><p>摆烂了将近一个月终于开始继续</p><h2 id="WinMine-XP-exe-游戏规则分析"><a href="#WinMine-XP-exe-游戏规则分析" class="headerlink" title="WinMine_XP.exe 游戏规则分析"></a>WinMine_XP.exe 游戏规则分析</h2><p><img src="/2022/07/01/NAD-DLL/img_10.png" alt="扫雷游戏界面"></p><ol><li>坐上叫雷数（剩余旗🚩数）显示；</li><li>右上角计时器显示：初始点击雷区按钮触发计时，点击充值按钮触发计时器重置；</li><li>雷区按钮：<ul><li>左击：① 显示该按钮下内容：数字（1、2…）：以该按钮坐标周围3*3个单位坐标按钮下存在雷的个数；② 雷（被引爆，游戏结束）；</li><li>右击：① 单机：插旗🚩（当且仅当在所有雷都进行插旗排雷后通关），占用旗数；② 双击：问好，不占用旗数，用于个人怀疑记录；</li></ul></li><li>game设置选项：<br><img src="/2022/07/01/NAD-DLL/img_11.png" alt="Game设置界面"><br>可设置棋盘规格大小；其中Custom选项可进行自定义，且Height&lt;=24，Width&lt;=30.<br><strong>注：在开始扫雷时左击的第一个按钮，即使是雷也会由程序自动将该地址的雷转移到其他地址，保证玩家不会上来就挂.</strong></li></ol><h2 id="实现思路分析"><a href="#实现思路分析" class="headerlink" title="实现思路分析"></a>实现思路分析</h2><p>获取棋盘雷区数据存储地址，通过模拟点击事件对雷区所有按钮进行遍历点击，其中对内存存储数值含义为雷的进行模拟右击插旗，其他进行左击排查；通过计时器存储数值判断棋盘数据是否重置。</p><p>通过Spy++获取WinMine_XP.exe窗口句柄：<br><img src="/2022/07/01/NAD-DLL/img_12.png" alt="句柄"><br>其中<br>IpClassName: Minesweeper<br>IpWindowsName: Minesweeper</p><h2 id="通过Cheat-Engine获取窗口WinMine-XP-exe窗口内存数据，并查找到棋盘内存点进行数据分析："><a href="#通过Cheat-Engine获取窗口WinMine-XP-exe窗口内存数据，并查找到棋盘内存点进行数据分析：" class="headerlink" title="通过Cheat Engine获取窗口WinMine_XP.exe窗口内存数据，并查找到棋盘内存点进行数据分析："></a>通过Cheat Engine获取窗口WinMine_XP.exe窗口内存数据，并查找到棋盘内存点进行数据分析：</h2><p><img src="/2022/07/01/NAD-DLL/img_13.png" alt><br>分析棋盘数据（以9*9棋盘为例）</p><ul><li>棋盘规格数据：<br>· 宽度数据存储地址：Width=0x0100553;<br>· 长度数据存储地址：Height=0x0100553;<br><img src="/2022/07/01/NAD-DLL/img_15.png" alt></li><li>雷区起始点地址：0x01005361;</li><li>计时器数据存储地址：0x0100579C;</li><li>地雷布局的内存位置：0x0100534;<br><img src="/2022/07/01/NAD-DLL/img_14.png" alt></li><li>雷区按钮数据：<br>· 10：棋盘边界；<br>· 0F：无雷且未点击；<br>· 8F：有雷且未点击；<br>· 0E：无雷插旗；<br>· 8E：有雷插旗；<br>· CC：点击引爆；</li></ul><h2 id="通过spy-获取雷区按钮坐标相关信息"><a href="#通过spy-获取雷区按钮坐标相关信息" class="headerlink" title="通过spy++获取雷区按钮坐标相关信息"></a>通过spy++获取雷区按钮坐标相关信息</h2><p><img src="/2022/07/01/NAD-DLL/img_16.png" alt><br>按钮坐标（1，1）中心对应串钩坐标约为（20，63），且相邻两个按钮之间的窗口坐标差值约为16个单位长度。</p><h1 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    PBYTE t = (PBYTE)<span class="number">0x0100579C</span>;</span><br><span class="line">    <span class="comment">//char szChar[20];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对不同窗口信息传送进行对应操作指令</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//输入任意字符实现一键通关</span></span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*t == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//内存地址</span></span><br><span class="line">            PBYTE m = (PBYTE)<span class="number">0x01005361</span>;</span><br><span class="line">            PBYTE w = (PBYTE)<span class="number">0x01005334</span>;</span><br><span class="line">            PBYTE h = (PBYTE)<span class="number">0x01005338</span>;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">20</span>, y = <span class="number">63</span>, n = <span class="number">1</span>, q = <span class="number">1</span>;  <span class="comment">//坐标</span></span><br><span class="line">            <span class="comment">//雷区按钮遍历</span></span><br><span class="line">            <span class="keyword">while</span> (x &lt;= <span class="number">20</span> + *w * <span class="number">16</span> &amp;&amp; y &lt;= <span class="number">63</span> + (*h - <span class="number">1</span>) * <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt; *h)</span><br><span class="line">                    y = <span class="number">63</span>;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; *w)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = <span class="number">20</span>;</span><br><span class="line">                    y += <span class="number">16</span>;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                    m += <span class="number">32</span> - *w;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (*m != <span class="number">143</span>)  <span class="comment">//非雷则左击</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//雷则右击</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_RBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_RBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//完成该按钮操作后移动至下一按钮坐标处</span></span><br><span class="line">                x += <span class="number">16</span>;</span><br><span class="line">                n++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">            y = <span class="number">63</span>;</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>((WNDPROC)OPROC, hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>数据地址定义：<br>· PBYTE t: 计时器数据存储地址；<br>· PBYTE m: 雷区按钮起始点地址；<br>· PBYTE w: 雷区宽度数据存储地址；<br>· PBYTE h: 雷区长度数据存储地址；</li><li>坐标定义：<br>· x,y: 窗口坐标；<br>· n,q: 按钮坐标；</li><li>Switch(uMsg): 对不同窗口信息传送进行对应操作指令（在此选择通过从键盘输入任意字符实现一键通关指令）</li><li>while(x &lt;= 20 + w <em> 16 &amp;&amp; y &lt;= 63 + (</em>h - 1) * 16): 对雷区按钮进行遍历；<br>· if 此按钮坐标（n,q）下数据m!=143（8F）时，对该按钮坐标（x，y）模拟鼠标左击事件；<br>· else 对该按钮窗口坐标（x,y）模拟鼠标右击事件<br>· 完成该按钮操作后进行坐标移动</li><li>*t==0时（棋盘重置）重复上述操作；</li></ol><p><strong>笔记：</strong></p><ul><li><strong>同列相邻行间地址差推算：address+32-width；</strong> </li><li><strong>棋盘重置可通过 * p的值作为条件，棋盘重置后需要将地址指针及坐标悉数重置；</strong></li><li><strong>若本次布雷，在（1，1）即为雷时，由于程序对内存数据的访问限制会使第一次的模拟点击跳过，需在遍历后补充一次对（1，1）按钮的左击。</strong></li></ul><h2 id="注入函数"><a href="#注入函数" class="headerlink" title="注入函数"></a>注入函数</h2><p>void injected()<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">injected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">nullptr</span>, <span class="string">&quot;injected&quot;</span>, <span class="string">&quot;title&quot;</span>, MB_OK);</span><br><span class="line">    HWND OW = <span class="built_in">FindWindowA</span>(<span class="string">&quot;Minesweeper&quot;</span>, <span class="string">&quot;Minesweeper&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!OW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(<span class="literal">nullptr</span>, <span class="string">&quot;find window failed&quot;</span>, <span class="string">&quot;Failed&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OPROC = <span class="built_in">SetWindowLong</span>(OW, GWL_WNDPROC, (LONG)WindowProc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="入口点函数"><a href="#入口点函数" class="headerlink" title="入口点函数"></a>入口点函数</h2><p>BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">injected</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><h2 id="注入测试"><a href="#注入测试" class="headerlink" title="注入测试"></a>注入测试</h2><p>通过Xenos注入：<br><img src="/2022/07/01/NAD-DLL/img_17.png" alt><br>接收到注入函数中设定的注入成功的MessageBox;</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=686304538&bvid=BV1SU4y1e733&cid=783764201&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><ol><li>模拟鼠标点击事件：<br>SendMessage()函数；<br>参考：<a href="https://wenku.baidu.com/view/b71d76a1ef3a87c24028915f804d2b160b4e8665.html"><strong>如何使用Sendmessage模拟某一按钮的点击事件</strong> - <em>百度文库</em></a></li><li>由于扫雷程序对第一次左击不触雷的设定，致使在测试中出现第一个按钮未被执行点击的情况：在遍历后补充对第一个按钮的无差别点击。</li></ol><h1 id="篇末BB"><a href="#篇末BB" class="headerlink" title="篇末BB"></a>篇末BB</h1><p>事实上这个外挂辅助的实现有许多不同中的思路，我不能确保自己选择的是最巧妙的但是我所唯一能操作实现的。<br>在大量辅助工具的帮助下对目标程序的内存分析十分简单且便捷。<br>个人认为本次实验的困难包括但不限于对内存数据的分析与利用，虽然能<del>照本宣科地</del>使用Spy++/CE/Xenos等，但我并未能利用好PeiD工具，或许因为人错过了更为便捷的信息获取与分析途径。<br>总而言之，虽然“独立”完成了扫雷外挂的编程实现是极具满足感的，但或以更多的是在对辅助工具的认识与使用上，于是更期待之后能够更熟练运用这些工具，做出更可拷/可刑的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLL </tag>
            
            <tag> 外挂 </tag>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[人工智能先导实践]1.n-Queens的多种算法题解</title>
      <link href="/2022/06/26/AI-nQueens/"/>
      <url>/2022/06/26/AI-nQueens/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：8皇后问题与n皇后问题"><a href="#相关叨叨：8皇后问题与n皇后问题" class="headerlink" title="相关叨叨：8皇后问题与n皇后问题"></a>相关叨叨：8皇后问题与n皇后问题</h1><p>八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。<br>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<br>下图是八皇后问题的一个解，可以用向量表示为：[f, d, g, a, h, b, e, c]，分别表示每行的皇后位置（列号）。<br><img src="https://i.postimg.cc/PJnPNvxZ/image.png" alt="八皇后问题的一个解"></p><p>实验拟题来自于 <strong>中国海洋大学 人工智能先导实践 lab03：比特匠心&amp;模拟退火</strong> <em>-by 徐建良</em></p><h1 id="n-queens多种解题方法思路"><a href="#n-queens多种解题方法思路" class="headerlink" title="n-queens多种解题方法思路"></a>n-queens多种解题方法思路</h1><h2 id="回溯与8皇后"><a href="#回溯与8皇后" class="headerlink" title="回溯与8皇后"></a>回溯与8皇后</h2><p>“回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。“<br>就是说，回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。<br>而对于解决八皇后问题，以深度优先的回溯法作为最基础的思路，有如下应用：<br>step1. 尝试先放置第一枚皇后，被涂黑的地方是不能放皇后<br><img src="https://pic3.zhimg.com/80/v2-bde25f03b5a86cc6ca47ee03fd171c9e_720w.jpg"><br>step2. 第二行的皇后只能放在第三格或第四格，比方我们放第三格，则：<br><img src="https://pic2.zhimg.com/80/v2-40654679a56af2cd9282b9ae60d4c641_720w.jpg"><br>step3. 可以看到再难以放下第三个皇后，此时我们就要用到回溯算法了。我们把第二个皇后更改位置，此时我们能放下第三枚皇后了。<br><img src="https://pic1.zhimg.com/80/v2-b810b81e8843c11e30e62277ddde1b4c_720w.jpg"><br>step4. 虽然是能放置第三个皇后，但是第四个皇后又无路可走了。返回上层调用（3号皇后），而3号也别无可去，继续回溯上层调用（2号），2号已然无路可去，继续回溯上层（1号），于是1号皇后改变位置如下，继续回溯。<br><img src="https://pic2.zhimg.com/80/v2-a22c5c4152b4b8b488555be294837f39_720w.jpg"><br>以上内容引自 <a href="https://zhuanlan.zhihu.com/p/54275352"><strong>小白带你学—-回溯算法（Back Tracking)</strong> <em>-知乎 @小白算法</em></a></p><p>下面我们就建立在这一最基础的算法思路上，运用不同的进阶算法解决N阶皇后问题，且不断优化。</p><h2 id="利用哈希表降维进行初探"><a href="#利用哈希表降维进行初探" class="headerlink" title="利用哈希表降维进行初探"></a>利用哈希表降维进行初探</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>这个题解仅仅是建立在对该问题的探索与思考上，并无“创新”抑或“优化”可言，基于最暴力且朴素的降维思路，不断尝试从中找出规律、再考虑优化。</p><h3 id="二维哈希表"><a href="#二维哈希表" class="headerlink" title="二维哈希表"></a>二维哈希表</h3><p>· 实现过程：</p><ol><li>建立二维数组，将棋盘布局通过数组模拟占位信息。其中另外通过开辟数组分别存储列冲突、左斜冲突、和右斜冲突的信息。</li><li>设置回溯函数，统计该行下空余且不冲突可放置皇后的位置；<br>-&gt;更新并计算位置占用情况；<br>-&gt;若有空余位置，则从右起对每一位置依次进行回溯试探；<br>-&gt;进入下一行的试探，深度优先搜索正确解，只要遇到无空位可放置，则逐层向上回溯，至存在空位的行；<br>-&gt;依次对该行存在的可放置空位进行遍历试探，并对试探失败的空位进行排除；<br>-&gt;记录可行解的个数。</li><li>回溯函数部分代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span>** hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; hash[rowp][i] == <span class="number">0</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>** temp = <span class="keyword">new</span> <span class="type">int</span>* [n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">temp[i][j] = hash[rowp + i + <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i])</span><br><span class="line">&#123;</span><br><span class="line">hash[rowp][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;down &lt; n;down++, l--, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= <span class="number">0</span>)</span><br><span class="line">hash[down][l] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n)</span><br><span class="line">hash[down][r] = <span class="number">0</span>;</span><br><span class="line">hash[down][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>][h] = temp[m][h];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>· 小结<br>对于n-queens问题探索可行解过程，若n取值较小时较为迅速，且内存情况还算勉强，但对于8皇后、16皇后、甚至100皇后问题的求解，会占用大量内存，不仅执行过程极其缓慢，且容易导致触发程序断点、或是溢出问题。因而引出如下逐渐降维的实现过程。</li></ol><h3 id="一维哈希表"><a href="#一维哈希表" class="headerlink" title="一维哈希表"></a>一维哈希表</h3><p>· 实现：</p><ol><li>为了减少内存压力，通过将二进制数的位运算与数组进行结合，用n个二进制数记录行中可放置位置，并将之存放在一维数组中；</li><li>思路与上大致相同，不再赘述。</li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span>* hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = hash[rowp] &amp; -hash[rowp];</span><br><span class="line"><span class="type">int</span> position = <span class="built_in">log</span>(p) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*int position = p == 1 ? 0 : pow(p, 0.5);*/</span></span><br><span class="line">hash[rowp] -= p;</span><br><span class="line"><span class="type">int</span>* temp = <span class="keyword">new</span> <span class="type">int</span>[n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">temp[i] = hash[rowp + i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">1</span>;down &lt; n;down++, l++, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n - position)</span><br><span class="line">left = left + p &lt;&lt; l;</span><br><span class="line"><span class="keyword">if</span> (r &lt;= position)</span><br><span class="line">right = right + p &gt;&gt; r;</span><br><span class="line">hash[down] = hash[down] &amp; ~(left | right | p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; rowp &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; bitset&lt;6&gt;(hash[i]) &lt;&lt; endl;*/</span></span><br><span class="line"><span class="built_in">dfs1</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>] = temp[m];</span><br><span class="line"><span class="keyword">delete</span>[]temp;</span><br><span class="line">&#125; <span class="keyword">while</span> (hash[rowp]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>· 小结：<br>相较起二维数组，效率仅仅提高了一点点，内存占用情况仍不够美观，遂考虑压缩至0维哈希，即仅使用一个二进制数来存储全部占位信息并进行回溯。</li></ol><h2 id="位运算解法（0维哈希表）"><a href="#位运算解法（0维哈希表）" class="headerlink" title="位运算解法（0维哈希表）"></a>位运算解法（0维哈希表）</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算与位运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;   <span class="comment">//60 = 0011 1100</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;   <span class="comment">//13 = 0000 1101</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a &amp; b;             <span class="comment">//12 = 0000 1100 按位与</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 1 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a | b;             <span class="comment">//61 = 0011 1101 按位或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 2 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a ^ b;             <span class="comment">//49 = 0011 0001 异或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 3 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = ~a;                <span class="comment">//-61 = 1100 0011 按位取反</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 4 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;            <span class="comment">//240 = 1111 0000 位左移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 5 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;            <span class="comment">//15 = 0000 1111 位右移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 6 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><h3 id="n-queens与位运算"><a href="#n-queens与位运算" class="headerlink" title="n-queens与位运算"></a>n-queens与位运算</h3><ol><li>思路说明（以8皇后为例）<br>首先，我们的基本思路与传统一样，每一行只能放并且必须放一个皇后。每次放置一个皇后之后，它就会对后面所有行中，可能放置皇后的位置产生影响。如下图所示，我们已经放置了三个皇后 Q1，Q2，Q3。 接着在下面一行放置 Q4 时，用彩色标注出的区域都是不可行的方案，会与已经放置的三个皇后产生冲突。<br><img src="https://i.postimg.cc/2jKVq5cV/image.png" alt="表达有无冲突的二进制数图解（本图来源于网络）">这个冲突其实有三种不同的情况，我们用三个变量 A，B，C 分别表示这三种不同的冲突。这三个变量都是一个八位的二进制数，这八位中，为 1 的表示有冲突，为 0 则表示没有冲突。<br>(1)与已放置的皇后处于同一列中：<br>我们用 A 表示这种冲突。例如在图中，第四行会有三个位置因为列攻击而不能再放置皇后（图中大红色方块），因此 A = 1000 1001。<br>(2)与已放置的皇后处于同一左斜(指向右下方)对角线中：<br>我们用 B 表示这种冲突。例如在图中，蓝色方块所表示的位置，分别是由于Q1和Q2的左斜对角线上的攻击而不能够放置新的皇后， 因此B = 0001 0010。<br>(3)与已放置的皇后处于同一右斜(指向右上方)对角线中：<br>我们用 C 表示这种冲突。例如图中粉色方块，是由 Q2 的右斜对角线的攻击造成的。因此 C = 0010 0000。<br>有了 A，B，C 三个变量，我们很容易求出当前行(第 4 行)中，有哪些位置是可以放置皇后的。这个变量我们用 D 来表示，我们可以写出 D = ~(A|B|C)。D中为 1 的那些位置则是我们可以放置皇后的位置。上图中，D = 0100 0100。<br>此时，我们有两个可能的放置皇后的位置，那么如何取出每个可能的位置呢？<br>这里有一个技巧。我们用 bit 表示可能的一个位置，使用 bit = D &amp; (-D) 即可取出 D 中最右边的 1（LSB，Least Significant Bit）。例如 D = 0100 0100，则-D = 10111100（注意计算机中的数都是补码，-D = ~D + 1）。而bit = D &amp; (-D) = 0000 0100 取出了最右边的那个 1，代表在第 4 行第 6 列放置一个皇后。那么在此基础上，如何确定第 5 行的 A、B、C 的值呢？其实也很简单，对于表示列冲突的变量 A 来说，只要使用 A|bit 即可表示下一行的列冲突情况，对于 B，采用(B|bit)&lt;<1，对于 c，采用(c|bit)>&gt;1 即可表示下一行中，对角线冲突的情况。<br>上述算法的思路来自于 <a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><strong>Backtracking Algorithms in MCPL using Bit Patterns and Recursion</strong> <em>-by Martin Richards</em></a> (这个链接好像并不很稳定的样子，可以挂个梯子去看)</1，对于></li><li>代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> hash,<span class="type">int</span> B,<span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//B左斜冲突</span></span><br><span class="line">    <span class="comment">//C右斜冲突</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//由于同列冲突的条件限定，且棋盘行数与列数相等</span></span><br><span class="line">    <span class="comment">//若想在每一列都放置皇后，则皇后不可能在同列，同时满足每一列都有皇后</span></span><br><span class="line">    <span class="comment">//因而可通过判断是否满足每一列都有皇后的条件来判断是否达成最终效果</span></span><br><span class="line"><span class="comment">//hash记录列冲突</span></span><br><span class="line"><span class="comment">//当hash==n，即所有每一列都放置了皇后时，结束本轮试探并计数</span></span><br><span class="line"><span class="keyword">if</span> (hash==n)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置回溯记忆点rememtemp</span></span><br><span class="line"><span class="comment">//若rememtemp==0时，即该行无位置可供放置，结束试探并开始回溯</span></span><br><span class="line"><span class="type">int</span> rememtemp = n &amp; ~(B | C | hash);  <span class="comment">//初始继承上一行中的放置情况</span></span><br><span class="line"><span class="keyword">while</span> (rememtemp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义A表示同列冲突，且其列位置会直接被继承到该行后的各行中</span></span><br><span class="line"><span class="type">int</span> A = rememtemp &amp; -rememtemp;     <span class="comment">//取当前行中最右一个可放置皇后的位置</span></span><br><span class="line">rememtemp -= A;       <span class="comment">//在记忆点中将A位置设置为0</span></span><br><span class="line"><span class="comment">//左斜冲突与右斜冲突在继承上一行的冲突情况同时，分别通过对该A位置的左移与右移进行对下一行冲突的更新</span></span><br><span class="line"><span class="comment">//对hash更新列冲突情况</span></span><br><span class="line"><span class="built_in">dfs0</span>(hash | A, (B | A) &lt;&lt; <span class="number">1</span>, (C | A) &gt;&gt; <span class="number">1</span>);      <span class="comment">//进入下一行</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果输出：<img src="https://i.postimg.cc/ZRmDxZwN/image.png" alt="6-queens"> <img src="https://i.postimg.cc/y89PQtgy/image.png" alt="10-queens"> <img src="https://i.postimg.cc/W1262n5M/image.png" alt="14-queens"> <img src="https://i.postimg.cc/d0f8jKwB/image.png" alt="16-queens"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3>利用位运算对n-queens问题可行解的数量进行统计，其延续了上述通过哈希表的思路，但代码更为简洁、运行速度更快、占用空间更小。唯一比较困难的是对于单一的二进制变量来储存整个棋盘的空位更新信息，在向下试探过程中容易忽略对当前行的“存档”，而在回溯过程中又容易忘记“读档”，而导致信息混乱。这个问题的解决则是在每次递归之前设置一个存档变量，将当前的数据存储之后再进行向下的试探，因而保证了在每一层的回溯过程中会自动读取上次所记录的数据。<br>下图是1-27阶问题的所有可行解：<br><img src="/2022/06/26/AI-nQueens/image.png" alt="1~27阶可行解"><br>对于该图中的分布状态的总结与思考，又引出了下文新的算法——多项式时间算法。</li></ol><h2 id="N皇后的多项式时间算法"><a href="#N皇后的多项式时间算法" class="headerlink" title="N皇后的多项式时间算法"></a>N皇后的多项式时间算法</h2><h3 id="算法说明-1"><a href="#算法说明-1" class="headerlink" title="算法说明"></a>算法说明</h3><p>本算法来自于<a href="https://dl.acm.org/doi/pdf/10.1145/101340.101343"><strong>A Polynomial Time Algorithm for the N-Queens Problem</strong> <em>-by Rok Sosic &amp; Jun Gu</em></a> (这个链接好像并不很稳定的样子，可以挂个梯子去看) 在 1990 年首先提出。其灵感来源于对n阶可行解数量的考察，可以得出：可行解数量众多且均匀分布于整个状态空间 (棋盘上皇后的所有可能的 n!个排列)中。<br>思路简述：<br>通过一维数组将行数与该行对应皇后的列位置建立映射；<br>-&gt;随机打乱并保证每行皇后不在同一列；<br>-&gt;遍历判断皇后i或皇后j是否存在对角线冲突；<br> -&gt;若冲突，则试探交换两行皇后的位置；<br>  -&gt;判断交换后，全局冲突(评估值)是否减少，若减少则确定交换并使操作数自增记录，否则不交换且不记录；<br> -&gt;若都不冲突则不操作；<br>-&gt;遍历，知道操作数为0；<br>-&gt;判断调整后全局是否存在冲突，若存在则打乱重来（重启）；<br>-&gt;输出该解。</p><p>如下图是原论文中关于算法思路的说明(部分):<br><img src="/2022/06/26/AI-nQueens/image%20(2" alt="A Fast Algorithm for the N-Queens Problem ">.png)</p><p>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下（虽然感觉我写的怪怪的）:</p><ol><li><p>评估函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评估函数，计算当前棋盘下的冲突数，作为评估值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单个皇后局部对角线冲突计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个皇后局部对角线冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Attacked</span><span class="params">(<span class="type">int</span> *Board,<span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Att = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=row+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(Board[i] - Board[row]))</span><br><span class="line">Att++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Att&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Att;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>取解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heuristic</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> swaps_performed = <span class="number">0</span>;  <span class="comment">//设定计步器</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span>[n];      <span class="comment">//设定当前棋盘</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span>[n];         <span class="comment">//设定试探棋盘</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">swaps_performed = <span class="number">0</span>;     <span class="comment">//重计</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Attacked</span>(Current, i) || <span class="built_in">Attacked</span>(Current, j))   <span class="comment">//if queeni is attacked or queenj is attacked</span></span><br><span class="line">&#123;</span><br><span class="line">Next[i] = Current[j];</span><br><span class="line">Next[j] = Current[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Next) &lt; <span class="built_in">Conflicts</span>(Current))     <span class="comment">//if swap(queeni,queenj) reduces collisions </span></span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Next[i];</span><br><span class="line">Current[j] = Next[j];</span><br><span class="line">swaps_performed++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;*/</span></span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Next[i] = Current[i];</span><br><span class="line">Next[j] = Current[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Current))      <span class="comment">//检查是否获得解，若未获得解则打乱重来</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Current[i];</span><br><span class="line">Current[i] = Current[j];</span><br><span class="line">Current[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">swaps_performed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (swaps_performed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = Current[i];</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多项式时间测试主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polyn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;         </span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">Heuristic</span>(Board);</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示(14皇后为例)：<br><img src="/2022/06/26/AI-nQueens/img.png" alt="14queens"></p></li></ol><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>在编写过程中，感觉有些熟悉，有点随机重启爬山的味道，怀疑是不是自己并没有很好地利用好原作者的多项式时间算法思路）因为在实现过程中会出现自动跳出局域最优解（而可能并未达到全局最优），因而出现错误的结果，遂在完全照搬论文中伪代码的内容同时，增添了随机重启的部分，来确保最终结果为全局最优而非仅仅的局部最优。<br>我在这里的处理似乎并不是一个最合适的弥补策略，可以说并未很好地遵照多项式时间算法的巧妙设计。后续（或许很有可能不会）再返回来好好参悟一下算法来源的论文。<br>而面对上述提到的局部最优解的跳出，下文将会由此展示一个巧妙解决局部困死问题/提高效率的算法。</p><h2 id="模拟退火算法在N皇后问题的运用"><a href="#模拟退火算法在N皇后问题的运用" class="headerlink" title="模拟退火算法在N皇后问题的运用"></a>模拟退火算法在N皇后问题的运用</h2><p>模拟退火很好地解决了局部困死地问题，因为它在运行过程中会对微小变动进行一定程度上的接受，即使这个微小变动所得到的最终解并不是我们想要的解，正是这种设定提高了执行效率。<br>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="算法说明-2"><a href="#算法说明-2" class="headerlink" title="算法说明"></a>算法说明</h3><p>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合一定的概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。<br>这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。将温度T当作控制参数，目标函数值f视为内能E，而固体在某温度T时的一个状态对应一个解[公式]，然后算法试图随着控制参数T的降低，使目标函数f(内能E)也逐渐降低，直至趋于全局最小值（退火中低温时的最低能量状态），就像金属退火过程一样。<br><img src="https://pic4.zhimg.com/80/v2-e1529b1b1577eecd16fb8a5418d51533_720w.jpg" alt="模拟退火流程图"><br>其中有几个需要注意的点：<br>· 初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。<br>· 在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。<br>· 当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</p><p>以上内容来自 <a href="https://zhuanlan.zhihu.com/p/266874840"><strong>模拟退火算法详解</strong> <em>-知乎 @智能算法</em></a> </p><p>思路简述：<br>通过一维数组将行数与该行对应皇后的列位置建立映射；<br>-&gt;设定初始温度且足够大，设定最小温度且一定小，设定退火速率；<br>-&gt;以行为单位遍历调整皇后位置，并计算调整前后的冲突值的差；<br>-&gt;若能量差小于0，则证明修改后的评估值耕地，在一定概率下接收评估值降低的修改，且使这个概率不知逐渐减小；否则直接接受调整；<br>-&gt;逐渐降温确保在未获得最优解时跳出局部最低温；<br>-&gt;直至调整到获得全局最低温结束；<br>-&gt;输出该解。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下：</p><ol><li><p>评估函数（与多项式时间算法的全局冲突数函数一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>退火调整：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">proper</span><span class="params">(<span class="type">int</span>* Board, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> T = <span class="number">100.0</span>;    <span class="comment">//设定初始温度且足够大</span></span><br><span class="line"><span class="type">double</span> Tmin = <span class="number">1.0</span>;        <span class="comment">//设定最小温度且一定小</span></span><br><span class="line"><span class="type">double</span> Rate = <span class="number">0.8</span>;           <span class="comment">//退火速率</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span> [n];         <span class="comment">//记录当前棋盘放置情况</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span> [n];           <span class="comment">//记录修改后棋盘放置情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (T &gt; Tmin)        <span class="comment">//开始退火</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>;p &lt; n;p++)        <span class="comment">//遍历修改</span></span><br><span class="line">&#123;</span><br><span class="line">Next[row] = p;</span><br><span class="line"><span class="type">double</span> dE = <span class="built_in">Conflicts</span>(Next) - <span class="built_in">Conflicts</span>(Current);       <span class="comment">//计算能量差</span></span><br><span class="line"><span class="comment">//若能量差小于0，则证明修改后的评估值更低</span></span><br><span class="line"><span class="comment">//在一定概率下接受评估值降低的修改，且使这个概率值逐渐减小</span></span><br><span class="line"><span class="keyword">if</span> (dE &lt;= <span class="number">0</span> || (<span class="built_in">exp</span>((<span class="number">-1</span>) * dE / T) &gt; <span class="built_in">rand</span>() % <span class="number">100</span> * <span class="number">1.0</span> / <span class="number">10</span>))</span><br><span class="line">Current[row] = Next[row];</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Current[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">T *= Rate;         <span class="comment">//降温</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line">Board[row] = Current[row];</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"><span class="keyword">return</span> Board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟退火测试主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Simul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Conflicts</span>(Board))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == n)         <span class="comment">//重置</span></span><br><span class="line">row = <span class="number">0</span>;</span><br><span class="line">Board = <span class="built_in">proper</span>(Board, row++);         <span class="comment">//修改第row行皇后放置位置</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; row;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果：<br>与上无差，不做赘述。</p></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>经过对N皇后问题的不断深入探索（主要依赖于牛批前辈们的不同算法的提出），模拟退火用于寻找并输出n阶任一可行解，较好地解决了暴力遍历算法所导致的内存占用过大的问题/耗时过长效率低的问题，同时解决了多项式算法局部困死的问题，对该问题的不同算法探索到此为止（事实上是因为实验布置的内容要求到此为止）。</p><h1 id="篇末BB"><a href="#篇末BB" class="headerlink" title="篇末BB"></a>篇末BB</h1><p>N-Queens/N皇后/无论怎么称呼的这一人工智能问题，属实经典，且解法众多，包括但远不限于如上所展示的 位运算/多项式时间算法/模拟退火算法 的经典算法，甚至如用爬山算法也将是很好的解题思路。对于人工智能，算法优化是其最关键的部分，面对庞大计算量，能否使程序语句更加精炼/占用内存尽可能少/运行速度更快，决定了你的人工是否足够智能。</p><p>~（反正对于这一灵活度极高的问题上，我搜索且浏览了很多资料和文献才逐步探索出最优的算法，一圈子下来只是觉得自己是一人工智障）~</p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 模拟退火 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello/Bonjour/你好</title>
      <link href="/2022/06/26/Hello/"/>
      <url>/2022/06/26/Hello/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><font size="4">This blog belongs to a student of Ocean University of China. It is used to record and share his undergraduate leaning experience and some interesting technology in computer science major.</font><h2 id="Bonjour"><a href="#Bonjour" class="headerlink" title="Bonjour!"></a>Bonjour!</h2><font size="4">Ce blog appartient à un étudiant de l'université Océanique de Chine. Il est utilisé pour documenter et partager son expérience  de premier cycle en informatique et centaines technique interessantes.</font><h2 id="你好哇！"><a href="#你好哇！" class="headerlink" title="你好哇！"></a>你好哇！</h2><font size="4">这个博客是一个中国海洋大学的学生创设的，用来记录和分享一些他本科期间在计算机专业的一些学习经验和有趣的技术。对了，他的网名常用“小二上馄饨”，他喜欢被叫做“馄饨”。</font><hr>]]></content>
      
      
      <categories>
          
          <category> 题外话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ME </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
