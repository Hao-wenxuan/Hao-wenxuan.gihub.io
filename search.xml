<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[日常] v我50来点文子哥的保研经历</title>
      <link href="/article/3daea8eb/"/>
      <url>/article/3daea8eb/</url>
      
        <content type="html"><![CDATA[<h1 id="我">我</h1><h2 id="bg">BG</h2><ul><li>title：中国海洋大学（山东末9，水专）</li><li>major：软件工程SE（学科评估B）</li><li>rank：综合评定排名2/38（5.3%），成绩排名5/38（13.1%）</li><li>科研：一段无产出的科研经历（CV方向，模型攻防）</li><li>竞赛：全国大学生系统能力竞赛全国二等奖（2/3核心成员）+数模竞赛获奖若干</li><li>实践：软著*1，无srdp无大创</li></ul><h2 id="target">target</h2><ol type="1"><li><p><strong>规划？</strong></p><p>对自己并没有特别清晰的规划：准备按部就班一步一个脚印地读，没有一口气吃成个大胖子的准备（直博），没有决心就业/工程向（工程硕士）。</p></li><li><p><strong>方向？</strong></p><p>目标方向是做AI，尤其是在国防/航空航天方向的交叉，不想做计算机纯理论或软件向开发。</p></li><li><p><strong>专硕or学硕？</strong></p><p>难易度：学硕&gt;直博&gt;专硕。title和学硕似乎是不可兼得的，认识的好多朋友放弃title换强导学硕，而我最终为了名校梦，奔着title去了，走了专硕。</p></li></ol><h2 id="summary">summary</h2><ol type="1"><li><p><strong>夏令营</strong></p><ul><li>厦门大学人工智能研究院</li><li>西安交通大学软件学院</li><li>浙江大学软件学院</li><li>国防科技大学计算机学院</li></ul></li><li><p><strong>预推免</strong></p><ul><li>南开大学人工智能学院</li><li>四川大学计算机学院</li><li>西北工业大学计算机学院</li></ul></li><li><p><strong>最终去向</strong></p><p>浙江大学</p></li></ol><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20241009225039390.png" alt="结算画面：收集了好多冰箱贴" style="zoom:50%;"></p><h1 id="保研情况">保研情况</h1><h2 id="导师套磁">导师套磁</h2><table><colgroup><col style="width: 3%"><col style="width: 12%"><col style="width: 34%"><col style="width: 14%"><col style="width: 34%"></colgroup><thead><tr class="header"><th>姓名</th><th>邮箱</th><th>方向</th><th>学校</th><th>回复</th></tr></thead><tbody><tr class="odd"><td>魏巍</td><td>weiweinwpu@nwpu.edu.cn</td><td>计算机视觉、遥感图像处理、机器学习及人工智能。空天地海一体化</td><td>西北工业大学 计算机学院</td><td>未答复（发了三次都没答复）<br>后记：梦导，突然call来电话说只剩直博名额了，犹豫再三还是拒了…终生遗憾</td></tr><tr class="even"><td>戴玉超</td><td>daiyuchao@nwpu.edu.cn</td><td>三维视觉、CV</td><td>西北工业大学 电子信息学院</td><td>听说去年就已经把今年的招满了</td></tr><tr class="odd"><td>王莉莉</td><td>wanglily@buaa.edu.cn</td><td>计算机图形学、虚拟现实、可视化</td><td>北京航空航天计算机学院</td><td>未答复</td></tr><tr class="even"><td>纪荣嵘</td><td>rrji@xmu.edu.cn</td><td>计算机视觉，移动增强现实</td><td>厦门大学 人工智能研究院</td><td>考核通过，但是院筛没过</td></tr><tr class="odd"><td>FVL</td><td>zxwu@fudan.edu.cn</td><td>视觉</td><td>复旦大学-cs</td><td>未答复</td></tr><tr class="even"><td>曹健</td><td>caojian@ss.pku.edu.cn</td><td>人工智能终端应用研究。研究领域包括：高效具身智能系统软硬件协同设计、人工智能芯片软硬件协同应用开发。</td><td>北大-软微</td><td>未答复</td></tr><tr class="odd"><td>郑伟诗</td><td>wszheng@ieee.org</td><td>1）视频图像处理（侧重行为识别、视频图像AI安全建模）；2）计算机三维建模与分析（侧重点云信息处理与三维物体生成）；3）AIRoboticsLearning（计算机视觉建模学习驱动的机器人行为学研究、人机交互研究；研究组未来重点，估计35%左右的研究力量）</td><td>中山-cs</td><td>未答复</td></tr></tbody></table><h2 id="夏令营">夏令营</h2><table style="width:100%;"><colgroup><col style="width: 20%"><col style="width: 35%"><col style="width: 29%"><col style="width: 13%"></colgroup><thead><tr class="header"><th>学院</th><th>官网通知</th><th>备注</th><th>入营情况</th></tr></thead><tbody><tr class="odd"><td><strong>南京大学</strong>-计算机科学与技术系</td><td></td><td></td><td>未入营</td></tr><tr class="even"><td><strong>南京大学</strong>-智能软件与工程学院</td><td>https://ise.nju.edu.cn/info/1018/1841.htm</td><td>专硕 苏州</td><td>未入营</td></tr><tr class="odd"><td><strong>复旦大学</strong>-信息学院-生物医学工程</td><td>https://mp.weixin.qq.com/s/XWEsFxROQnh7zOLdeL90gQ</td><td></td><td>未入营</td></tr><tr class="even"><td><strong>吉林大学</strong>-软件学院</td><td>https://csw.jlu.edu.cn/info/1156/7193.htm</td><td></td><td>未入营</td></tr><tr class="odd"><td><strong>西安交通大学</strong>-软件学院</td><td>http://se.xjtu.edu.cn/info/1043/2679.htm</td><td>线上，七月上旬 宣讲营，没效力</td><td>祝继华考核，感觉默拒了</td></tr><tr class="even"><td><strong>西安交通大学</strong>-前沿交叉</td><td>https://fist.xjtu.edu.cn/info/1013/4052.htm</td><td></td><td>未入营</td></tr><tr class="odd"><td><strong>厦门大学</strong>-人工智能研究院（MAC）</td><td>https://iai.xmu.edu.cn/info/1110/4044.htm</td><td>官方说无wl，普通营员直接踢出群聊了</td><td>未优营</td></tr><tr class="even"><td><strong>哈尔滨工业大学</strong>-计算学部</td><td>https://cs.hit.edu.cn/2024/0510/c11474a344345/pagem.htm</td><td></td><td>未入营</td></tr><tr class="odd"><td><strong>浙江大学</strong>-软件学院元宇宙</td><td>http://www.cst.zju.edu.cn/2024/0531/c32178a2926228/page.htm</td><td>线上夏令营，海王营，优营预推免入场券，卓营给offer</td><td>卓营，offer，最终去向</td></tr><tr class="even"><td><strong>国防科技大学</strong>-计算机学院</td><td></td><td></td><td>入营，但是排名很靠后</td></tr></tbody></table><h2 id="预推免">预推免</h2><table><colgroup><col style="width: 16%"><col style="width: 29%"><col style="width: 24%"><col style="width: 29%"></colgroup><thead><tr class="header"><th>学院</th><th>官网通知</th><th>备注</th><th>申请情况</th></tr></thead><tbody><tr class="odd"><td><strong>天津大学</strong>-智算学部</td><td>https://cic.tju.edu.cn/info/1041/4968.htm</td><td>完全可以直接报导师团，报了夏令营就不能报导师团了</td><td>初筛考试和学校答辩冲突了，无缘</td></tr><tr class="even"><td><strong>哈尔滨工业大学</strong>-计算学部</td><td>http://hityzb.hit.edu.cn/zhxy-yjs-zs_v2/common/login?redirectUrl=/pc/tms/index</td><td></td><td>被默拒了</td></tr><tr class="odd"><td><strong>哈尔滨工业大学</strong>-深圳cs</td><td></td><td>今年bar巨高</td><td>忘交材料..</td></tr><tr class="even"><td><strong>哈尔滨工业大学</strong>-航天学院</td><td></td><td></td><td>被默拒了</td></tr><tr class="odd"><td><strong>中科院</strong>-软件所</td><td>https://zhaosheng.ucas.ac.cn/sign_up/TMS/views/index.aspx</td><td></td><td>被默拒了</td></tr><tr class="even"><td><strong>南京大学</strong>-软件学院</td><td>https://gs.nju.edu.cn/geapp/sys/yjsbmxsd/entrance.do</td><td>Magus初筛过了。</td><td>被院筛默拒了，今年bar突然提高</td></tr><tr class="odd"><td><strong>南京大学</strong>-人工智能学院</td><td></td><td></td><td>被默拒了</td></tr><tr class="even"><td><strong>同济大学</strong>-计算机学院</td><td>https://yzbm.tongji.edu.cn/logon<br>https://sse.tongji.edu.cn/info/1132/5276.htm</td><td></td><td>被默拒了</td></tr><tr class="odd"><td><strong>复旦大学</strong>-cs</td><td>https://gsao.fudan.edu.cn/<br>https://cs.fudan.edu.cn/8a/d6/c24277a690902/page.htm</td><td></td><td>被拒了</td></tr><tr class="even"><td><strong>南开大学</strong>-人工智能学院</td><td>https://yzxt.nankai.edu.cn/intern/frontend/web/user-action/status<br>https://ai.nankai.edu.cn/info/1024/5923.htm</td><td></td><td>参加，专硕offer，面试后双选，放弃</td></tr><tr class="odd"><td><strong>中山大学</strong>-cs</td><td>https://cse.sysu.edu.cn/content/7164</td><td>优先招录夏令营批次，预推免全员wl且仅剩专硕</td><td>初筛通过，未参加</td></tr><tr class="even"><td><strong>中科大</strong>-科学岛</td><td>https://gs.hfcas.ac.cn/home</td><td>群友说优先录优营</td><td>被默拒</td></tr><tr class="odd"><td><strong>西工大</strong>-计算机学院</td><td>https://yjsjy.nwpu.edu.cn/zsbm/tmsg</td><td>非常弱com，只要填了系统，并且有老师决定要，就offer</td><td>梦导call来，只剩直博，拒了；后记：不甘心，联系了另外一位同组老师，有学硕名额，个人犹豫再三后放弃。</td></tr><tr class="even"><td><strong>上海交通大学</strong>-电子学院</td><td>https://www.seiee.sjtu.edu.cn/yjspy_zsgz_sszs/10659.html<br>https://ga.sjtu.edu.cn/zsgl/ytmgl/</td><td></td><td>被默拒</td></tr><tr class="odd"><td><strong>西安交通大学</strong>-人工智能</td><td>https://yzbm.xjtu.edu.cn/logon<br>http://www.aiar.xjtu.edu.cn/info/1028/3386.htm</td><td></td><td>被拒</td></tr><tr class="even"><td><strong>北大</strong>-软微</td><td>https://www.ss.pku.edu.cn/admission/admnotice/4603.html</td><td></td><td>被拒</td></tr><tr class="odd"><td><strong>北航</strong>-cs</td><td>https://scse.buaa.edu.cn/info/1299/11380.htm</td><td></td><td>初筛通过，累了，没去。</td></tr><tr class="even"><td><strong>中山</strong>-ai</td><td>https://sse.sysu.edu.cn/article/771</td><td>听说bar是出了名的高</td><td>被默拒了</td></tr><tr class="odd"><td><strong>北京理工大学</strong>-网络空间安全学院</td><td>https://cst.bit.edu.cn/xxfw/tzgg/bb017f985ad047b19a28ba8c629f8b32.htm</td><td>空天方向</td><td>初筛过了，只给嘉兴校区名额，拒了；927又打来电话说有北京名额了，再拒一次（sorry）</td></tr><tr class="even"><td><strong>武汉大学</strong>-cs</td><td>https://cs.whu.edu.cn/info/1071/46641.htm</td><td></td><td>被默拒了</td></tr><tr class="odd"><td><strong>四川大学</strong>-cs</td><td>https://cs.scu.edu.cn/info/1247/18579.htm<br>https://yz.scu.edu.cn/xly/login/</td><td></td><td>初筛通过</td></tr></tbody></table><p>后来这个情况被一个好朋友看到了，她讲：”<strong>我如果每天一打开电脑看到自己满屏幕被拒两个字，我估计都不想活了。</strong>”</p><p>捏麻麻的，我也一样啊我自己早就绷不住了要你说嘛呜呜呜呜呜！！！！</p><h1 id="日记">日记</h1><h2 id="记夏令营">记夏令营</h2><p>夏令营入营报名时的bg：</p><ul><li>6/38（15.7%）</li><li>无国奖</li></ul><h3 id="厦门大学人工智能研究院">厦门大学人工智能研究院</h3><p>厦门大学是我入营并且参营的第一个线下目的地。</p><p>简单说说厦门大学人工智能研究院：</p><ol type="1"><li>只收专硕</li><li>在翔安校区（本部是思明校区，经典的计算机专业发配边郊）</li><li>强组有纪荣嵘老师的MAC，强的一批</li><li>弱com，需要套导师，投递材料本校推荐信+XMUIAI推荐信</li></ol><p>我套了MAC，但有些晚了，据说当时已经宣讲结束并且下发了考核任务。尽管如此，我还是过了初筛，并且完成了考核任务。</p><p>今年MAC组面的考核任务是复现MagicAnimate，有开源代码，只需要跑通并且梳理清除pipeline。由于之前有一定的文献代码复现经验，因此较为轻松，复现的也非常顺利。面试时有3位MAC老师，进行ppt陈述，包括个人主要成果和经历，主要进行文献梳理和复现成果展示，没有考察专业课，纯聊天面，除了复现项目问题之外，回忆起来的其他问题有：</p><ul><li>老家在哪里？为什么想来厦门大学？（我老家在北方，所以老师追问没有考虑在北京发展吗？）</li><li>你对MAC有什么了解，将来想做什么方向</li><li>有没有参加别的夏令营？</li></ul><p>组筛通过，并且接受了线下参营的邀请。</p><ul><li><p>D1：报道与学术讲座</p><p>我很早就去报道了，甚至是第一个去的。夏令营是在厦大思明校区本部举行的，附近就是海滩，交通也非常便利。于是先在周边逛了逛，还淋了一股子猝不及防的雨。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/d1a58f5094d96cf6f00bdf4f2994b82.jpg" alt="白城沙滩天桥拍" style="zoom: 50%;"></p><p>晚上举行了开营仪式，纪荣嵘教授没有亲临现场，是通过视频会议的方式进行了远程的介绍。没记错的话，似乎包括后面的讲座都是由MAC的各位大牛老师们进行的，可以注意到IAI或者说MAC做的东西都非常前沿有趣！！真的非常遗憾没有成功称为MAC的一员…</p></li><li><p>D2：参观</p><p>先前去过厦门，也参观了厦大，非常具有特色的建筑风格，不愧是全国最美校园！！！（没有diss某洋大学，但是真的很美！）</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/f06d8f803c4cde301676ee4decfdc94.jpg" alt="和我记忆里五六年前来的时候一样好看" style="zoom:50%;"></p><p>参观作为思政考核的一部分，有签到（请假也可能会扣考勤分，慎重）印象里去参观了校史馆、党史馆、人类博物馆，然后就是自由活动到处参观。总言之每个角落都好看，闷热也是真热。有意思的是路过特别茂盛的树时候会有奇怪的水滴感滴落在身上，后来才知道那是蝉的尿（？）</p><p>另外值得提一嘴的是，当时夏令营营员被分配到了一个比较老旧的宿舍区，住宿环境体验非常一般，并且由于我恰好被分配到了一楼，户外阳台出去就是很茂盛的草丛，因此活动一天回去像开盲盒一样，不知道就会看到什么小动物。离谱的是有一天晚上开到了一只蛤蟆，在床头蹦跶了一晚上。最常见的就是大到可以看清腿毛的蟑螂，哥们直接僵直，也是那个时候觉得自己好像不是很适合在南方生活。。。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/d1c7bb9df6a3748668de385100deae7.jpg" alt="已老实，求放过" style="zoom:33%;"></p></li><li><p>D3：机考&amp;面试</p><p>上午机考。</p><p>机考是OJ，实时排名，90min，三道题（30、30、40）。回忆了一下题目，大致是涉及到了一元三次方程的实根求解、二叉树以及BFS的大模拟。总而言之并不是很难，但也经不住哥们好久没练算法，考的一塌糊涂，只拿了40多分，后来面试时候被拷打（这个真是我活该）也有很多爆零的选手，因此我虽然得分不高，最后的排名却不算靠后。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/0729941a50f6e8ee7be904d671d6b4b.jpg" alt="在钟铭选楼完成机考后拍" style="zoom:50%;"></p><p>抓紧吃了一口饭之后，就去准备了下午的面试了，非常严格，在等候期间不允许使用电子设备，并且进行现场抽签决定面试次序。</p><p>我是第2个去面试的，似乎注意到面试我的五位老师都是MAC的老师，或许我被分到这个面试组是因为当时陶瓷了MAC？各位老师都很和蔼，在我ppt陈述的过程中也有很认真在听，给足了情绪价值！</p><p>并没有提问专业课，基本上是按照简历提问。回忆起来的问题：</p><ul><li>机考的内容很难吗，为什么分数不高？（我前一位面试的同学80+的佬，我只有人家一半，当然会被拷打…）</li><li>你讲讲对抗攻防分类（这是我的科研经历，应该刚好是这位老师的专业领域）</li><li>……（一些小的问题没有记着）</li><li>你确定你能够保研吗？（当时参营用的排名还很靠后，rk确实低）</li></ul></li></ul><p>优营名单公布之后，可以看到优营率还是非常高的，奈何我确实是没有充分准备，遗憾没有优营，最难受的是一天早上突然醒来看到自己被移除营员的群聊，555555难受的一批。尽管如此，第一次的夏令营体验还是非常不错的，只是不知道下一次来厦大是用着什么身份。</p><h3 id="浙江大学软件学院">浙江大学软件学院</h3><p>浙江大学软件学院的夏令营是海王营，光入营就2k左右吧？并且夏令营阶段是以项目方式进行优营的筛选。今年与往年有所不同，简要说明：</p><ol type="1"><li><p>浙软往年被称为“双非乐园”，似乎对于很多追求title的双非选手是个最佳的选择，并且浙软对bg要求也不同于其他华五（包括浙大其他学院）。然而今年似乎要提升生源质量，在后面的预推免阶段大部分招的是985的学生。</p></li><li><p>浙软往年被称为宣讲营，因为优营没有offer效益，只是预推免的入场券。然而今年新设了“卓越营员”，宣讲时也强调必须是985的优营才可以申请，并且参加线下面试筛选。最重获得卓营的学生可以获得铁offer。卓营的面试通过率非常高，大约可以占到候选人的60%以上。</p></li><li><p>浙软往年被称为宁波软大，由于历史原因，软院在宁波校区与浙大宁波理工学院（独立办学的二本）同处一个校园，这也导致很多学生认为环境很差。但是今年招生老师说明年软院会搬到刚建成的新校区，虽然仍然与浙大宁波理工学院离得很近，但是会在不同的校园（也有说仍然五位一体，只能明年去了才能知道真实情况了）</p></li></ol><p>按照拟录取流程进行回忆。</p><ul><li><p>Stage1：优营选拔</p><p>浙江大学软件学院在很早的时候就进行了线上宣讲。我在报名时选择了元宇宙与智能驾驶分营，该分营下发布了8个任务，似乎是每两个任务归属于一个课题组。元宇宙营的任务给了大约2周时间来完成，但由于当时在厦门参加厦大的夏令营，我在距离截止时间不到4天的时候才去详细了解各个任务的要求，并最后选择了自己有把握完成的嵌入式AI分营的任务。</p><p>我选择的任务是软件定义汽车与自动驾驶场景数字化仿真的综述，几乎不眠不休地肝了几天，阅读了30+篇中外文文献，终于赶在最后较为完美地完成了任务。然后大约不到一周就看到自己拿了优营（似乎是这个任务的唯一一个）。后来听说今年优营率巨低，我只能说我侥幸选择了自己比较擅长的一个，并且沉住气没有放弃做下来了。</p></li><li><p>Stage2：卓营选拔</p><p>优营中的985bg学生可以申请卓营，称为卓营候选人之后需要赴杭州参加线下的面试。刚好后面要在杭电参加一个竞赛的答辩，于是在杭州狠狠呆了9天。</p><p>卓营选拔面试是在浙大的玉泉校区，地理位置绝佳！就在西湖旁边。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/7d43e29214e8289d0000af16f541af4.jpg" alt="玉泉校区的伟人像。从正门刚进来就可以看到伟人的英姿" style="zoom:50%;"></p><p>因为当时我的面试序号比较靠后，于是我逛了逛校园。真的大，有很浓厚的人文历史气息，伙食也真的好（小贵，因为校外人员使用支付宝支付需要额外收一部分的钱）</p><p>赴曹光彪科技楼参加面试，遇到了来自全国各地的9佬们，交流后得知是真的神仙打架，科研经历非常丰富的有、竞赛国奖选手也一大把。当时已经稍有抱着来旅游的心态准备了，干脆没有再复习专业课知识，就把陈述ppt演练了好几十遍，把手里的项目也再熟悉透彻了点。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/04ed026af5594a52bcfcf7376a94a9a.jpg" alt="曹光彪楼，主建筑是cs院的院楼" style="zoom:50%;"></p><p>在参加面试前，就已经提交过了ppt的pdf版和简历，因此人到了就行，什么都不用拿。面试过程中老师们听的非常认真，本以为华五level的面试会有很大的压力感，但似乎整个过程氛围很活跃（也有可能老师们也设置了压力面，但是我木木的没有察觉到），很多回答都把老师们整笑了（褒义）。总共面试20min，10min个人陈述（印象里是），问题也完全是围绕着简历进行提问的，没有问到专业课。大体有如下问题：</p><ul><li>我注意到你参加的东西很杂，你有没有具体想做的东西？</li><li>你具体说一下你提到的科研经历中构想的那个实验，为什么没有做下去？（我的科研经历中提到了自己正在实验一种算法，但是遇到了瓶颈。后来面试老师们甚至给我这个幼稚的构想提供了思路）</li><li>你在系统设计竞赛中具体做了什么？你们这个项目实现了什么，怎么实现的？（因为当时还没有正式获奖，因此仅仅当作一个实践经历阐述的。）</li><li>你这些项目中，你认为哪一个最能体现出你的代码水平和算法能力？</li><li>…….总之问的非常细致，有些已经有点忘记。</li></ul><p>当时氛围真的非常舒服，后面甚至不紧张了，和老师们更像是交流，所以很放松地就结束了面试，离开了曹光彪楼。</p><p>出门的时候才发现下雨了，并且突然变得急促，我拿着的伞也有些架不住这么大的雨浇灌下来，索性就散步样地在雨里逛逛，找了个避雨的地方等雨小些。</p><p>躲雨的时候刚好遇到似乎是来旅游的一家子，我在那里用纸巾擦着自己身上的泥点子，那家的小女孩眼巴巴盯着我，然后把手里的饼干递给我要我吃。自然而然地就交谈一阵子，等雨小些了我就跟他们告别，然后离开。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/6899a648831c32dbf2ee02d3ce3e30c.jpg" alt="下过雨后的浙大校门" style="zoom:50%;"></p></li><li><p>Stage3：双选签协议</p><p>卓营最终的面试公布似乎就是在两天后。那天下午刚刚在杭电旁边的酒店睡醒，听到熟悉的钉钉此起彼伏作响，拿起手机一看自己被拉到了一个新的群，才得知自己居然拿了卓营。有些突然又有些让我感到不真实，不真实到让我没有激起庆祝，反而是平静，只是为自己终于摆脱了夏0营的焦灼而感到松一口气。</p><p>后来开学返校后，与当时完成的项目对应的课题组签了双选协议。</p></li><li><p>Stage4：最终排名</p><p>在预推免结束之后，所有参与面试的营员和预推免考生统一排名。我的最终排名是64/540。哥们第一次这么靠前，哭泣！！！！</p></li></ul><h3 id="西安交通大学软件学院">西安交通大学软件学院</h3><p>今年临时换成宣讲营了，似乎因为往年的鸽王太多。我套磁了祝继华老师，并由组内博士生（应该是）面试。ppt面试，没问专业课，学长听的非常认真，问的也很细致，几乎是对每一页ppt提到的内容都进行了提问。回忆如下：</p><ul><li>你在数学建模竞赛中能收获什么？</li><li>讲讲你在科研经历中具体做了什么？</li><li>ViT和DNN之间有哪些不同？</li><li>TCP和UDP有什么不同？（因为个人陈述中有TCP相关课设，所以被问到）</li><li>平时有哪些爱好？</li><li>为什么选择祝老师的组？你对我们的研究方向有哪些了解？</li></ul><p>面试结束后便再也没有了消息。预推免时再次和学长确认了一下，组内设置了两轮面试，我并没有通知我参加第二轮面试，因此估摸自己没有入选，所以遗憾退场。</p><h3 id="国防科技大学计算机学院">国防科技大学计算机学院</h3><p>国防科大有两批夏令营，第一批因为与厦大冲突，我选择了第二批。</p><p>我说，体验感拉满！！因为我从一开始就对国防事业有着强烈的向往和憧憬，因此来到这个学校对于我而言本身就非常兴奋。所有的安排井然有序，校园也毫无疑问带有浓厚的军地文化氛围，尤其时常响起的军号声庄严静穆。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20241009194829164.png" alt="国防科大的标志性大门" style="zoom:50%;"></p><p>国防科大的夏令营形式主要是体检、讲座、参观、思政考核、面试5个部分。主要说说面试。</p><p>面试的形式没有ppt、没有简历，英文陈述为陈述主体，中文进行补充。在完成英文陈述之后会有英文提问，一般是2~3个问题，提问内容随机。由于当时刚刚结束了系统竞赛的答辩并且获得了国二，而且国防科大主要就是以系统为强项，于是被狠狠提问（尽管我说了我对CV感兴趣，将来也想做AI方向，但是完全没被问到）：</p><ul><li>讲讲移植是做了什么东西？</li><li>你在其中做了什么贡献？</li><li>mmu是怎么实现的？</li><li>讲讲zircon和其他操作系统的主要区别？</li><li>loongarch和其他架构的区别？</li></ul><p>其中每个问题都会涉及到更深一步的追问。总是问的非常到位，我认为比当时决赛答辩的老师们问的都详尽且专业，而我答得非常的差，疯狂道歉…甚至在回答zircon（微内核）与Linux等宏内核的主要区别的时候，把宏内核的特性张冠李戴在了微内核中，把老师整无语了。</p><p>最后面试成绩出来后，也可以看到毫无疑问几乎倒数。难过了好几天。</p><h2 id="记预推免">记预推免</h2><p>预推免报名用的bg：</p><ul><li>2/38（5.2%）</li><li>国二</li><li>软著三作</li></ul><h3 id="南开大学人工智能学院">南开大学人工智能学院</h3><p>南开大学人工智能学院稍有特殊，是自动化与智能控制方向为主。南开的控制巨强，但AI院似乎是刚设立没有多久，主要是以机器人技术、虚拟仿真为主要研究方向，但近几年也有一批机器学习、深度学习方向的人工智能老师开始在AI院招生。</p><p>AI院不在本部，稍微有些偏。应该离天大的北洋园校区不远。校园环境还是非常不错的。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/3f3c21cca0a4feec07c1d233f345cad.jpg" alt="津南校区主体建筑与周总理像" style="zoom:50%;"></p><p>没有机考，只有面试。</p><p>面试氛围很好，老师都很和蔼，十分轻松。但由于稍微跨学科，所以面试时候对于我的简历问的问题很浅，不需要英文陈述，但是会问英文问题（非常突然）。主要问了我的科研学习经历可迁移对抗攻击，让我详细说明了一下这个可迁移对抗攻击是在干啥，让我讲了讲复现的两个算法（FIA、adaEA）。此外还问了问我项目经历中提到的图像处理（提问了Canny边缘检测算法）。完全按照简历问问题，但是似乎面试我的老师们都不是相关方向的，所以有些表现的是在凑时间而提问。关于系统的东西一点都没问。</p><p>后来了解到和我一起来面试的乃子哥在面试时候遇到了相关方向的老师，因此聊的更融洽一些，面试结束后老师主动加了乃子哥的vx（好像这位老师已经招满了学生，但是对乃子哥实在是欣赏，所以加了vx交流。祝贺乃）</p><p>公布面试成绩后也进行了排名，并且按照排名递序给学硕专硕，我只排46/69，当然只拿到了专硕名额。因为目标是拿nku的学硕，所以在得知自己目标无望之后放弃了联系导师双选，直接释放了这个名额。</p><h3 id="四川大学计算机学院">四川大学计算机学院</h3><p>川大是线上面试，同样也没有机试。主要分为：</p><ul><li>英文面试：随机抽题，给一段专业相关的英文文献，要求通读后英译汉。我抽到的是DNN。</li><li>专业知识：从操作系统、计网、数据结构中分别抽题，三选二。我当时抽到的：<ul><li>操作系统：死锁定理；</li><li>数据结构：广义表（一下子没想起来，就没有选）；</li><li>计网：两种自治系统内部网络协议（OSPF和RIP）</li></ul></li><li>问我有无其他offer，我如实回答，并表明自己更希望拿学硕。又问：如果川大给你专硕你会来吗？如实回答：那我要再多考虑考虑。</li></ul><h3 id="西北工业大学计算机学院">西北工业大学计算机学院</h3><p>航空航天一直是我的梦想来着，溯源起来是因为杨利伟曾经就是在我的老家降落的，后面各种航天飞行器也大多选择在我们这边作为着落点。这对于我这种浪漫b来说有着无尽的魅力。</p><p>在南开面试结束准备返程的路上，突然接到了西工大梦导的call，说他这里只有直博名额，问我要不要去。但就像我前面解释过的，我并没有直博的勇气和打算，因此拒绝了梦导的面试邀请。我后来也为此患得患失了许久。</p><p>偶然在绿裙看到与他同一个实验室的另一位牛导空余出了名额，我当即陶瓷，并很快收到了老师的来电，相互电话了解后，决定第二天就在西安见面面谈，我也毫不犹豫买了最早的一班去西安的飞机，并与这位牛导在机场见面，一同驱车去瓜大。</p><p>在路上我们聊了很久，聊了我的个人规划，聊了组内方向，聊了航空航天梦想。老师对我有很强的肯定，尤其是对我的航空航天梦想和为国家做贡献的价值观非常赞赏，因此也非常希望能够指导我实现自己的理想，把我培养成一个国家需要的人才。</p><p>我们聊得非常投缘。只是后来在到达学校之后，我花了两三个小时在校园里乱逛，看到了这个总师摇篮的深厚底蕴的同时，也看到了隐约的压力，似乎每个人都在为报国理想而燃烧自己，每个人身上都肩负着巨大的责任，这却反而让我这种理想主义者叶公好龙般地感到发怵、想要退缩。</p><p>我最后与这位老师答复到：”我似乎并没有做好充分的准备“。老师讲，至少我来了，想清楚了，那就是没有白来。好喜欢这个老师！！</p><p>事实上我的纠结其实就是在于对未来发展的规划。我本来自以为是自己是清晰规划了未来的，梦想着称为祖国的螺丝钉，坚守在国防领域的科研发展中，但却在真正靠近这个梦想的时候却踱步不前。或许这个所谓的梦想在先几年的执着中只不过是一个挂在笨驴脸前的胡萝卜，促使我前进的一个永远不可达的彼方罢了。</p><p>我也不清楚自己是否真正下定了决心，便也这么不了了之了，索性连下一个目的地的北航也没有再去参加的动力。</p><p>至此结束了自己的保研路途。</p><h2 id="记928929">记928/929</h2><p>因为我没有占着茅坑不拉屎的胆量和打算，并且再西工大校园里的纠结中下定决心选定了浙软，因此填报志愿非常的快速且轻松。</p><p>期间收到了北理工网安的call，说北京校区空出了名额，犹豫了一下还是决定了放弃。</p><p>因此，仅填报了一个浙软的志愿，在929悠哉等到了复试通知和待录取通知，美美接受，美美截图，美美发朋友圈，美美晚上聚餐祝贺。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20241009221422029.png" alt="“我们都有美好滴未来”" style="zoom: 67%;"></p><h1 id="这三年">这三年</h1><p>我是目标清晰地迷迷糊糊过来的。</p><p>高考报志愿的时候，我一直期望着自己能够实现外交官的梦想，进入北京外国语大学学习，可惜那年只分配给内蒙古“保加利亚语”和“朝鲜语”的冷门小语种，我爸妈展望到十几二十年之后，仿佛已经看到我被国家分配到保加利亚的田园里去工作，遂在我填报北外志愿的时候架住了我的膀子愣是让我改了志愿，便稀里糊涂地来了中国海洋大学，稀里糊涂顺从了爸妈的建议选择了转入计算机专业。</p><p>刚进入大学，我连打字都是一指禅。</p><p>我花了一年时间让自己找到了一根称得上拐杖的信仰，支持我歪歪扭扭前进下去——我终归的梦想是希望<strong>为国家</strong>做出贡献的，那便也不必囿于我是用着什么样的方式、走着哪条路奔向这个终点。既然选择了计算机的专业，秉着“要么不做，要么做到最好”的原则，埋头苦干便是了。</p><p>这个信仰支撑我走过了大学三年。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20241008175138986.png" alt="未来？" style="zoom: 33%;"></p><p>关于保研：事实上在刚入学时，我并没有想到自己能够保研。为了进入到转专业非常方便的ouc，我在报志愿时秉着“能进就行”的想法，压线被ouc的外国语学院录取，并在开学前就报名参加ouc与法国联合培养的“卓越工程师”计划，用较高的选课优先权学习计算机类专业的课程。</p><p>在第一年，我几乎是完全独立地去接触计算机这门学科，并怀着诚惶诚恐的心情去摸索大学的学习方法，并成功在分流时用着非常考前的排名进入了计科大方向中。也正是在这一年，一时的突出成绩带给我了“我似乎也能保上研”的幻象，让我最终在接下来三年中为这个若即若离的幻境拼尽全力。</p><p>第二年时，我的排名却没有稳定在保研线内。正如我说，第一年的一时之喜给了我无尽的期望与幻想，吊着我一口气不甘心放弃，遂抓紧谋求办法——在老师的建议下决定转入小方向。</p><p>第三年，我转入到了软件工程继续学习。当然，同时转进来的还有其他来自计科并且抱有同样期许的卷王，纵然排名美观了些，我仍是在保研边缘。因此，这一年我是：破釜沉舟地不撞南墙不回头地全神贯注地投入在成绩提升中。学年结算中，我在这一年的纯成绩均分提升了足足2分之多，几乎全部满绩。此外，乃子哥凭借他独到的第三感邀请我组队参加了全国大学生系统能力竞赛，并取得了足够支撑我们获得学术专长加分的国二成绩，我的综合评定再进一步加了2分。至此，我的保研成绩从84.5攀升到了88.8，跻身到了专业第二。</p><p>我最大的成就就是<strong>坚持</strong>下来了。</p><p>就像我前面说的，我并没有做好学计算机的准备，我在刚入学时甚至打字都并不熟练，更别提周围尽是绝对称得上是佬的人物。但我从来不认为自己不如谁，纵然学习的套路依然继承了高中时候的死板，节节课冲在第一排，笔记写完了将近十个本子，临近期末考试也要安排三轮复习——硬是把计算机学成了八股文。</p><p>总有说：“计算机不是这么学的！”——那确实。我只是一个功利的<strong>结果主义者</strong>，我对这门科学（学科）并无兴趣，更谈不上热情，我在做的，无非是希望看到一个让自己满意的结果。于是这三年，我努力给自己看。</p><p>我绝对算不上一个优秀的计算机专业学生，我手上没有拿得出手的技术，肚子里装的学科知识也是针对学分和成绩的空空荡荡。我有着还算丰富的竞赛经历，却没积攒下来值得骄傲的竞赛经验；我有过一段科研经历，却没有获得拿得出手的成果；我有着广泛的知识涉猎，却没有真正深入哪一个领域。</p><p>我足够自信说自己是个<strong>耐得住性子</strong>的人，是一个愿意吃苦、虚极静笃的<strong>摆子</strong>，一个<strong>笨拙</strong>的传统学生。</p><p>我就是这样度过我的三年的。至少结果还尚且让自己满意。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20241009224759566.png" alt="在杭州。"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]可靠传输协议迭代设计-来跟👴握个手</title>
      <link href="/article/7948552/"/>
      <url>/article/7948552/</url>
      
        <content type="html"><![CDATA[<h1 id="bb两句">bb两句</h1><p>这个实验是我海带洪老师为计网课程设计的大实验，还是比较具有挑战性的。当时设置的赋分要求大致为：</p><table><thead><tr class="header"><th>标准</th><th>得分</th></tr></thead><tbody><tr class="odd"><td>RDT 2.0</td><td>3</td></tr><tr class="even"><td>RDT 2.2</td><td>6</td></tr><tr class="odd"><td>RDT 3.0</td><td>8</td></tr><tr class="even"><td>GB/SR/TCP</td><td>13</td></tr><tr class="odd"><td>TCP Tahoe</td><td>15</td></tr><tr class="even"><td>TCP Reno</td><td>16</td></tr><tr class="odd"><td>未完成关键困难</td><td>2</td></tr><tr class="even"><td>迭代开发</td><td>1</td></tr><tr class="odd"><td>已解决主要问题</td><td>1</td></tr><tr class="even"><td>实验系统建议</td><td>1</td></tr><tr class="odd"><td>合计</td><td>20</td></tr></tbody></table><p>事实上，拿到手的实验环境jre包中，已经完成到了RDT2.1版本（但仍需要手动补充校验和的计算类），因此头3分是白送滴。</p><p>我在这个实验中拿了满分，也就是我实现了TCPReno版本，并不容易。我粗略估计了一下，完成到RDT4.0之前的部分，我大约花费了10h左右，由于这部分还未涉及到滑动窗口的引入，因此迭代的过程相对容易；但到了引入滑动窗口的版本时，花费我大约又是15h左右才算最终完成整个实验，这是因为我选择的SR到Tahoe的迭代过程几乎是推翻了前面几个版本，重新搭建类的框架。</p><p>照猫画虎来倒也轻松，难在复习周的时间匀兑，分奴嘛，生来是牛马，用肝子换分子，不亏。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/5d8b93e923d7556ab40a2d8cb1cad5b.jpg" style="zoom:50%;"></p><h1 id="实验环境">实验环境</h1><ul><li><strong>OS</strong>: Windows 11</li><li><strong>Jdk</strong>: jdk-6u45-windows-i586</li><li><strong>Jre</strong>: jre-6</li><li><strong>IDE</strong>: Eclipse 4.29.0</li><li><strong>TCP-TestSys</strong>:TCP_TestSys_Linux.jar(并没有提供windows版本，但该版本在windows上可以正常运行)</li></ul><h1 id="从可靠信道到不可靠信道的迭代开发过程">从可靠信道到不可靠信道的迭代开发过程</h1><h2 id="rdt-2.02.1-信道上可能出现位错管理出错的acknak">RDT 2.0+2.1:信道上可能出现位错、管理出错的ACK/NAK</h2><h3 id="设计方案">设计方案</h3><ul><li><p>错误检测：校验和检查</p></li><li><p>从错误中恢复：ACKs、NAKs；若NAK则重传</p></li><li><p>ACK/NAK出错——管理重复：sequence number</p></li></ul><h3 id="校验和检查函数checksum.java">校验和检查函数CheckSum.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckSum</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*计算TCP报文段校验和：只需校验TCP首部中的seq、ack和sum，以及TCP数据字段*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">computeChkSum</span><span class="params">(TCP_PACKET tcpPack)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">checkSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">CRC32</span> <span class="variable">crc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CRC32</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从首部获取seq、ack和sum*/</span></span><br><span class="line"><span class="type">TCP_HEADER</span> <span class="variable">header</span> <span class="operator">=</span> tcpPack.getTcpH();</span><br><span class="line">crc.update(header.getTh_seq());</span><br><span class="line">crc.update(header.getTh_ack());</span><br><span class="line"><span class="comment">//crc.update(header.getTh_sum()); //加上sum反而会导致错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*从数据部获取数据*/</span></span><br><span class="line"><span class="type">TCP_SEGMENT</span> <span class="variable">segment</span> <span class="operator">=</span> tcpPack.getTcpS();</span><br><span class="line"><span class="type">int</span>[] data = segment.getData();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; data.length; i++) &#123;</span><br><span class="line">crc.update(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计算校验和*/</span></span><br><span class="line">checkSum = crc.getValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">short</span>) checkSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="sender">Sender</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192544126.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//可靠发送（应用层调用）：封装应用层数据，产生TCP数据报；需要修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_send</span><span class="params">(<span class="type">int</span> dataIndex, <span class="type">int</span>[] appData)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成TCP数据报（设置序号和数据字段/校验和),注意打包的顺序</span></span><br><span class="line">    tcpH.setTh_seq(dataIndex * appData.length + <span class="number">1</span>);<span class="comment">//包序号设置为字节流号：</span></span><br><span class="line">    tcpS.setData(appData);</span><br><span class="line">    tcpPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, destinAddr);       </span><br><span class="line">    <span class="comment">//更新带有checksum的TCP 报文头      </span></span><br><span class="line">    tcpH.setTh_sum(CheckSum.computeChkSum(tcpPack));</span><br><span class="line">    tcpPack.setTcpH(tcpH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送TCP数据报</span></span><br><span class="line">    udt_send(tcpPack);</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待ACK报文</span></span><br><span class="line">    <span class="comment">//waitACK();</span></span><br><span class="line">    <span class="keyword">while</span> (flag==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//需要修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitACK</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//循环检查ackQueue</span></span><br><span class="line">    <span class="comment">//循环检查确认号对列中是否有新收到的ACK       </span></span><br><span class="line">    <span class="keyword">if</span>(!ackQueue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> currentAck=ackQueue.poll();</span><br><span class="line">        <span class="comment">// System.out.println(&quot;CurrentAck: &quot;+currentAck);</span></span><br><span class="line">        <span class="keyword">if</span> (currentAck == tcpPack.getTcpH().getTh_seq())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Clear: &quot;</span>+tcpPack.getTcpH().getTh_seq());</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//RDT2.1中有NAK(-1)，收到-1(!=currentAck)则重发</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Retransmit: &quot;</span>+tcpPack.getTcpH().getTh_seq());</span><br><span class="line">            udt_send(tcpPack);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//接收到ACK报文：检查校验和，将确认号插入ack队列;NACK的确认号为－1；不需要修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Receive ACK Number： &quot;</span>+ recvPack.getTcpH().getTh_ack());</span><br><span class="line">    ackQueue.add(recvPack.getTcpH().getTh_ack());</span><br><span class="line">    System.out.println();   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理ACK报文</span></span><br><span class="line">    waitACK();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="receiver">Receiver</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192554080.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//接收到数据报：检查校验和，设置回复的ACK报文段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">    <span class="comment">//检查校验码，生成ACK</span></span><br><span class="line">    <span class="keyword">if</span>(CheckSum.computeChkSum(recvPack) == recvPack.getTcpH().getTh_sum()) &#123;</span><br><span class="line">        <span class="comment">//生成ACK报文段（设置确认号）</span></span><br><span class="line">        tcpH.setTh_ack(recvPack.getTcpH().getTh_seq());</span><br><span class="line">        ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">        tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">        <span class="comment">//回复ACK报文段</span></span><br><span class="line">        reply(ackPack);             </span><br><span class="line"></span><br><span class="line">        <span class="comment">//将接收到的正确有序的数据插入data队列，准备交付</span></span><br><span class="line">        dataQueue.add(recvPack.getTcpS().getData());                    </span><br><span class="line">        sequence++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Recieve Computed: &quot;</span>+CheckSum.computeChkSum(recvPack));</span><br><span class="line">        System.out.println(<span class="string">&quot;Recieved Packet&quot;</span>+recvPack.getTcpH().getTh_sum());</span><br><span class="line">        System.out.println(<span class="string">&quot;Problem: Packet Number: &quot;</span>+recvPack.getTcpH().getTh_seq()+<span class="string">&quot; + InnerSeq: &quot;</span>+sequence);</span><br><span class="line">        tcpH.setTh_ack(-<span class="number">1</span>); <span class="comment">//RDT2.1时仍需要区分ACK和NAK</span></span><br><span class="line">        ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">        tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">        <span class="comment">//回复ACK报文段</span></span><br><span class="line">        reply(ackPack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交付数据（每20组数据交付一次）</span></span><br><span class="line">    <span class="keyword">if</span>(dataQueue.size() == <span class="number">20</span>) </span><br><span class="line">    deliver_data();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试log">测试Log</h3><ul><li>Sender_eFlag = Receiver_eFlag = 0: 假设信道无差错</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192604332.png"></p><ul><li>Sender_eFlag = 1 &amp;&amp; Receiver_eFlag = 0:假设个别数据包某些字节可能位错，但ACK/NAK不出错：</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192622005.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192634747.png"></p><ul><li>Sender_eFlag = 0 &amp;&amp; Receiver_eFlag = 1:假设ACK/NAK出错：</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192642151.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192649921.png"></p><h2 id="rdt2.2-无nak的协议">RDT2.2: 无NAK的协议</h2><h3 id="设计方案-1">设计方案</h3><ul><li><p>接收方若收到错误包则重发上一正确包seq对应的ACK</p></li><li><p>发送方收到重复seq的ACK则重发当前包</p></li></ul><p><img src="/article/7948552/Users\Mo01iHt\AppData\Roaming\Typora\typora-user-images\image-20240219192658119.png"></p><h3 id="sender无改动">Sender（无改动）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitACK</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//循环检查ackQueue</span></span><br><span class="line">    <span class="comment">//循环检查确认号对列中是否有新收到的ACK       </span></span><br><span class="line">    <span class="keyword">if</span>(!ackQueue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> currentAck=ackQueue.poll();</span><br><span class="line">        <span class="comment">// System.out.println(&quot;CurrentAck: &quot;+currentAck);</span></span><br><span class="line">        <span class="keyword">if</span> (currentAck == tcpPack.getTcpH().getTh_seq())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Clear: &quot;</span>+tcpPack.getTcpH().getTh_seq());</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//RDT2.2中没有NAK，若未收到currentAck而是重复收到相同seq的ACK，则重发</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Retransmit: &quot;</span>+tcpPack.getTcpH().getTh_seq());</span><br><span class="line">        udt_send(tcpPack);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="receiver增加类成员修改rdt_recv">Receiver（增加类成员、修改rdt_recv）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCP_Receiver</span> <span class="keyword">extends</span> <span class="title class_">TCP_Receiver_ADT</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET ackPack;   <span class="comment">//回复的ACK报文段</span></span><br><span class="line">    <span class="type">int</span> sequence=<span class="number">1</span>;<span class="comment">//用于记录当前待接收的包序号，注意包序号不完全是</span></span><br><span class="line">    <span class="type">int</span> pre_seq=-<span class="number">1</span>;   <span class="comment">//用于记录上一个接收成功的包序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCP_Receiver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">//调用超类构造函数</span></span><br><span class="line">        <span class="built_in">super</span>.initTCP_Receiver(<span class="built_in">this</span>);  <span class="comment">//初始化TCP接收端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//接收到数据报：检查校验和，设置回复的ACK报文段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">        <span class="comment">//由于sender发送的seq是字节流序号，因此需要求出data长度</span></span><br><span class="line">        <span class="type">int</span>[] data = recvPack.getTcpS().getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="comment">//检查校验码，生成ACK</span></span><br><span class="line">        <span class="keyword">if</span>(CheckSum.computeChkSum(recvPack) == recvPack.getTcpH().getTh_sum()) &#123;</span><br><span class="line">            <span class="comment">//生成ACK报文段（设置确认号）</span></span><br><span class="line">            tcpH.setTh_ack(recvPack.getTcpH().getTh_seq());</span><br><span class="line">            ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">            tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">            <span class="comment">//回复ACK报文段</span></span><br><span class="line">            reply(ackPack);             </span><br><span class="line"></span><br><span class="line">            <span class="comment">//逆向计算seq：dataIndex * appData.length + 1</span></span><br><span class="line">            sequence = (recvPack.getTcpH().getTh_seq() - <span class="number">1</span> ) / datalen;</span><br><span class="line">            <span class="keyword">if</span>(sequence != <span class="built_in">this</span>.pre_seq) &#123; <span class="comment">//重复包丢弃，不交付</span></span><br><span class="line">                <span class="built_in">this</span>.pre_seq = sequence;    <span class="comment">//更新pre_seq</span></span><br><span class="line">                <span class="comment">//将接收到的正确有序的数据插入data队列，准备交付</span></span><br><span class="line">                dataQueue.add(data);           </span><br><span class="line">                sequence++;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//RDT2.2:对于收到错误包，重新发送上一接收成功的包对应的ACK</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Recieve Computed: &quot;</span>+CheckSum.computeChkSum(recvPack));</span><br><span class="line">            System.out.println(<span class="string">&quot;Recieved Packet&quot;</span>+recvPack.getTcpH().getTh_sum());</span><br><span class="line">            System.out.println(<span class="string">&quot;Problem: Packet Number: &quot;</span>+recvPack.getTcpH().getTh_seq()+<span class="string">&quot; + InnerSeq: &quot;</span>+sequence);</span><br><span class="line">            <span class="comment">// tcpH.setTh_ack(-1);     //RDT2.2不需特别标识出NAK</span></span><br><span class="line">            tcpH.setTh_ack(pre_seq * datalen + <span class="number">1</span>);   <span class="comment">//重发上一接收成功的包对应的ACK</span></span><br><span class="line">            ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">            tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">            <span class="comment">//回复ACK报文段</span></span><br><span class="line">            reply(ackPack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交付数据（每20组数据交付一次）</span></span><br><span class="line">        <span class="keyword">if</span>(dataQueue.size() == <span class="number">20</span>) </span><br><span class="line">        deliver_data();   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliver_data</span><span class="params">()</span> &#123;…</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reply</span><span class="params">(TCP_PACKET replyPack)</span> &#123;…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ul><li><p>需要记录上一成功接收的包的序号，因此在类中添加成员pre_seq初始化-1</p></li><li><p>对于重复数据包丢弃，需要判断rdt_rcv收到的包序号是否重复，因此应当计算出当前sequence= (recvPack.getTcpH().getTh_seq() - 1 ) /datalen;（由于sender发送的数据包序号是字节流信号，所以接收方计算seq时需要-1再除以数据长度），并将接收正确的包的序号更新在pre_seq中、交付上层。</p></li><li><p>对于校验失败的错误包，重新发送上接受正确的包seq的ACK。</p></li></ul></blockquote><h3 id="测试logsender_eflag-receiver_eflag-1">测试Log(Sender_eFlag =Receiver_eFlag = 1):</h3><ul><li>Receiver以重复ACK(37801、39001)代替NAK:</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192718721.png"></p><ul><li>Sender成功识别出重复ACK(37801、39001)并重发37901、39101：</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192726713.png"></p><h2 id="rdt3.0-通道上可能出错和丢失数据">RDT3.0:通道上可能出错和丢失数据</h2><h3 id="设计方案-2">设计方案：</h3><ul><li><p>丢包：发送方使用计时器等待ACK，若倒计时间内未收到ACK则重发</p></li><li><p>延迟：接收方对重复seq数据包丢弃</p></li></ul><h3 id="sender增添timer成员retrans成员修改rdt_sendwaitack">Sender（增添Timer成员、reTrans成员，修改rdt_send、waitACK()）</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192734268.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCP_Sender</span> <span class="keyword">extends</span> <span class="title class_">TCP_Sender_ADT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET tcpPack;   <span class="comment">//待发送的TCP数据报</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> UDT_Timer timer;    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">private</span> UDT_RetransTask reTrans; <span class="comment">//重传任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCP_Sender</span><span class="params">()</span> &#123;…</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//可靠发送（应用层调用）：封装应用层数据，产生TCP数据报；需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_send</span><span class="params">(<span class="type">int</span> dataIndex, <span class="type">int</span>[] appData)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成TCP数据报（设置序号和数据字段/校验和),注意打包的顺序</span></span><br><span class="line">        tcpH.setTh_seq(dataIndex * appData.length + <span class="number">1</span>);<span class="comment">//包序号设置为字节流号：</span></span><br><span class="line">        tcpS.setData(appData);</span><br><span class="line">        tcpPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, destinAddr);       </span><br><span class="line">        <span class="comment">//更新带有checksum的TCP 报文头      </span></span><br><span class="line">        tcpH.setTh_sum(CheckSum.computeChkSum(tcpPack));</span><br><span class="line">        tcpPack.setTcpH(tcpH);</span><br><span class="line"></span><br><span class="line">        timer = <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>();    <span class="comment">//RDT3.0：实例化计时器，发送后启动</span></span><br><span class="line">        reTrans = <span class="keyword">new</span> <span class="title class_">UDT_RetransTask</span>(client, tcpPack);   <span class="comment">//实例化重传任务，timeout则重传</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//RDT3.0: 每隔3秒执行重传，直到收到ACK</span></span><br><span class="line">        timer.schedule(reTrans, <span class="number">3000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送TCP数据报</span></span><br><span class="line">        udt_send(tcpPack);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待ACK报文</span></span><br><span class="line">        <span class="comment">//waitACK();</span></span><br><span class="line">        <span class="keyword">while</span> (flag==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udt_send</span><span class="params">(TCP_PACKET stcpPack)</span> &#123;…</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitACK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//循环检查ackQueue</span></span><br><span class="line">        <span class="comment">//循环检查确认号对列中是否有新收到的ACK       </span></span><br><span class="line">        <span class="keyword">if</span>(!ackQueue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> currentAck=ackQueue.poll();</span><br><span class="line">            <span class="comment">// System.out.println(&quot;CurrentAck: &quot;+currentAck);</span></span><br><span class="line">            <span class="keyword">if</span> (currentAck == tcpPack.getTcpH().getTh_seq())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Clear: &quot;</span>+tcpPack.getTcpH().getTh_seq());</span><br><span class="line">                timer.cancel();   <span class="comment">//RDT3.0: 收到对应ACK则停止计时</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//             else&#123;   //RDT3.0: 超时重传，因此对于收到的错误ACK不需回应</span></span><br><span class="line">    <span class="comment">//                  System.out.println(&quot;Retransmit: &quot;+tcpPack.getTcpH().getTh_seq());</span></span><br><span class="line">    <span class="comment">//                  udt_send(tcpPack);</span></span><br><span class="line">    <span class="comment">//                  flag = 0;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;…</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ul><li><p>为Sender类设置UDT_Timer计时器成员、UDT_RetransTask重传任务成员</p></li><li><p>在sender进行rdt_send时初始化计时器和重传任务，设置重传时间为3s（实际运行时发现时间有点长了），在timeout时执行重传任务</p></li><li><p>在weitACK时，若收到正确的ACK则暂停timer，否则不做操作（等待timeout重传）</p></li></ul></blockquote><h3 id="receiver对延迟导致的乱序进行处理">Receiver（对延迟导致的乱序进行处理）</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192745508.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sequence &gt; <span class="built_in">this</span>.pre_seq) &#123;     <span class="comment">//RDT3.0: 对于延迟送达的数据包丢弃</span></span><br><span class="line">    <span class="built_in">this</span>.pre_seq = sequence;    <span class="comment">//更新pre_seq</span></span><br><span class="line">    <span class="comment">//将接收到的正确有序的数据插入data队列，准备交付</span></span><br><span class="line">    dataQueue.add(data);           </span><br><span class="line">    sequence++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试log-1">测试Log</h3><ul><li><p>Sender_eFlag = Receiver_eFlag = 2 （丢包）</p><p>发送方在计时器时间内等待ACK，超时对应的可能情况：数据包丢失、接收方根本没收到于是没有ACK、数据包没丢失并且接收方收到后发送了ACK但是该ACK丢失。发送方并不关心是什么情况，只要等待的ACK超时未收到则重发。</p><p>但是在接收方视角，如果ACK丢失，就会收到发送方重复的数据报，于是丢弃该包后重发ACK。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192755547.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192801472.png"></p></li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192811055.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192820440.png"></p><ul><li><p>Sender_eFlag = Receiver_eFlag = 3 （延迟）</p><p>对于发送方，依旧是并不关心ACK为什么没收到，只要timeout，就重发，若收到错误的ACK（例如接收方ACK延迟送达、接收方对发送方延迟包的ACK）都不做任何操作。</p><p>而对于接收方，若发送方的数据包延迟：对重发的数据包和延迟到达的数据包都进行正常回应，但是对延迟到达的乱序数据包丢弃；若接收方ACK延迟，同样丢弃发送方重发的数据包。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192501749.png"></p></li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192508173.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192516110.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192525678.png"></p><p>​至此，RDT已经可以解决不可靠信道上可能出现的出错、丢包、延迟的所有问题，尽管使用的停止等待使得效率较低。</p><h1 id="效率提高的流水线协议迭代开发过程">效率提高的流水线协议迭代开发过程</h1><h2 id="select-response选择响应协议">Select-Response：选择响应协议</h2><h3 id="设计方案-3">设计方案</h3><p>滑动窗口设计：循环队列。</p><ul><li><p>接收方逐个对所有正确收到的分组进行应答：对接收到的（失序）分组进行缓存，以便最后对上层进行有效递交。</p></li><li><p>发送方仅对未收到应答的分组进行重发：为每个分组设置计时器。</p></li></ul><h3 id="sender-1">Sender:</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192344189.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192400371.png" alt="image-20240219192400371"></p><h4 id="发送方的窗口senderwindow">发送方的窗口SenderWindow:</h4><ul><li><p>数据结构：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219192435858.png"></p><ul><li><p>将窗口内的每个块划分为4个状态：</p><p>0: not usable //表示该块尚未缓存数据包</p><p>1: usable, not yet sent //表示该块已缓存数据，但尚未发送</p><p>2: sent, not yet ack’ed//表示该块缓存的数据已经发送，但尚未收到对应的ACK</p><p>3: already ack’ed //表示该块已发送的数据收到应答</p></li><li><p>为窗口设定三个指针：</p><p>queue_base //窗口基址，即左端</p><p>queue_rear //窗口末端</p><p>next_to_send //下一待发送数据地址</p></li></ul></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************Selective-Response: 选择响应协议</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2023-12-21*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.test.CheckSum;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.TCP_Sender_ADT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_RetransTask;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.Client;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.*;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.tool.TCP_TOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SenderWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">WinSize</span> <span class="operator">=</span> <span class="number">16</span>;    <span class="comment">//窗口大小</span></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET[] tcpPacks = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>[WinSize];    <span class="comment">//待发送的TCP数据报窗口（循环队列）</span></span><br><span class="line">    <span class="keyword">private</span> UDT_Timer[] timers = <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>[WinSize]; <span class="comment">//为窗口内每个包分配一个计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queue_base</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//窗口始端指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">next_to_send</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//待发送包指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queue_rear</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//队末指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] flag; <span class="comment">//0:have no pkt; 1:usable not yet send; 2:sent not yet ack&#x27;ed; 3: already ack&#x27;ed</span></span><br><span class="line">    Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SenderWindow</span><span class="params">(Client client, <span class="type">int</span> WinSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">        <span class="built_in">this</span>.WinSize = WinSize;</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="title class_">int</span>[WinSize];</span><br><span class="line">        Arrays.fill(flag, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口满判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (queue_rear - queue_base) == WinSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在队末处缓冲包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushPack</span><span class="params">(TCP_PACKET packet)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rear_index</span> <span class="operator">=</span> queue_rear % WinSize;  <span class="comment">//求队末相对索引</span></span><br><span class="line">        tcpPacks[rear_index] = packet;</span><br><span class="line">        flag[rear_index] = <span class="number">1</span>; <span class="comment">//标记为可发的包</span></span><br><span class="line">        queue_rear++;</span><br><span class="line">        <span class="type">int</span>[] data = packet.getTcpS().getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequence</span> <span class="operator">=</span> (packet.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">        <span class="comment">//System.out.println(sequence);</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对ACK处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rcvAck</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;</span><br><span class="line">    <span class="comment">//求各项相对索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">seq_index</span> <span class="operator">=</span> sequence % WinSize;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rear_index</span> <span class="operator">=</span> queue_rear % WinSize;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base_index</span> <span class="operator">=</span> queue_base % WinSize;</span><br><span class="line">        <span class="keyword">if</span> (sequence &gt;= queue_base &amp;&amp; sequence &lt;= queue_rear) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[seq_index] == <span class="number">2</span>) &#123;   <span class="comment">//若未收到ACK</span></span><br><span class="line">                timers[seq_index].cancel();   <span class="comment">//计时器暂停</span></span><br><span class="line">                timers[seq_index] = <span class="literal">null</span>;</span><br><span class="line">                flag[seq_index] = <span class="number">3</span>; <span class="comment">//标记为已收到ACK</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;   <span class="comment">//收到重复/错误ACK</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sequence == queue_base) &#123;  <span class="comment">//若窗口左端的包收到ACK</span></span><br><span class="line">                <span class="keyword">while</span>(flag[base_index] == <span class="number">3</span>) &#123; <span class="comment">//检索最大已ACK位置索引</span></span><br><span class="line">                    tcpPacks[base_index] = <span class="literal">null</span>;</span><br><span class="line">                    flag[base_index] = <span class="number">0</span>; <span class="comment">//标记为空（可放入包）</span></span><br><span class="line">                    queue_base++;</span><br><span class="line">                    base_index = queue_base % WinSize;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取可发送包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSendIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">send_index</span> <span class="operator">=</span> next_to_send % WinSize;</span><br><span class="line">        <span class="keyword">if</span>(flag[send_index] == <span class="number">1</span> ) &#123;</span><br><span class="line">            flag[send_index] = <span class="number">2</span>; <span class="comment">//标识为已发送但未ACK</span></span><br><span class="line">            next_to_send++;</span><br><span class="line">            <span class="comment">//System.out.println(send_index);</span></span><br><span class="line">            <span class="keyword">return</span> send_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可发包预备工作</span></span><br><span class="line">    <span class="keyword">public</span> TCP_PACKET <span class="title function_">getPack</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">UDT_RetransTask</span> <span class="variable">retrans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UDT_RetransTask</span>(client, tcpPacks[index]);</span><br><span class="line">        timers[index] = <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>();</span><br><span class="line">        timers[index].schedule(retrans, <span class="number">1000</span>, <span class="number">1000</span>); <span class="comment">//计时开始，超时重发</span></span><br><span class="line">        <span class="keyword">return</span> tcpPacks[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送方窗口类存在五个行为：</p><ul><li><p>ifFull():判断窗口是否缓存满，用来控制应用层的写入节奏，在满时需要进入忙等（直到窗口左端已发数据包收到ACK）；</p></li><li><p>pushPack():将应用层提供的数据包缓存到窗口队列中，在该行为中，将块的状态由0转换到1；</p></li><li><p>getSendIndex():为TCP_Sender类提供预备发送包的接口，即提供该块的索引地址；</p></li><li><p>getPack():完成包的发送工作，在该行为中初始化计时器并设定计时开始，同时将窗口中该块的状态由1转换到2；</p></li><li><p>rcvAck():对当前收到的ACK进行解析，若该ACK的序号为窗口中unACK’ed块所对应的应答，则将状态由2转换到3，否则不做处理；同时，若对应为窗口最左端的块的应答，则将窗口基址移动到下一未收到ACK的块的位置，并将此过程中已收到ACK的块的状态由3转换到0。</p></li></ul></li></ul><h4 id="tcp_sender.java">TCP_Sender.java:</h4><blockquote><p>修改了rdt_end()函数及waitACK()函数：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************2.1: ACK/NACK</span></span><br><span class="line"><span class="comment">**************************** Feng Hong; 2015-12-09*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************Selective-Response: 选择响应协议</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2023-12-21*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>…</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCP_Sender</span> <span class="keyword">extends</span> <span class="title class_">TCP_Sender_ADT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET tcpPack;   <span class="comment">//待发送的TCP数据报</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//private UDT_Timer timer;   //计时器</span></span><br><span class="line">    <span class="comment">//private UDT_RetransTask reTrans;    //重传任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SenderWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SenderWindow</span>(client, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCP_Sender</span><span class="params">()</span> &#123;…&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//可靠发送（应用层调用）：封装应用层数据，产生TCP数据报；需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_send</span><span class="params">(<span class="type">int</span> dataIndex, <span class="type">int</span>[] appData)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成TCP数据报（设置序号和数据字段/校验和),注意打包的顺序</span></span><br><span class="line">        tcpH.setTh_seq(dataIndex * appData.length + <span class="number">1</span>);<span class="comment">//包序号设置为字节流号：</span></span><br><span class="line">        tcpS.setData(appData);</span><br><span class="line">        tcpPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, destinAddr);       </span><br><span class="line">        <span class="comment">//更新带有checksum的TCP 报文头      </span></span><br><span class="line">        tcpH.setTh_sum(CheckSum.computeChkSum(tcpPack));</span><br><span class="line">        tcpPack.setTcpH(tcpH);</span><br><span class="line">        <span class="comment">//System.out.println(dataIndex);</span></span><br><span class="line">        <span class="comment">//若未装满则载入包</span></span><br><span class="line">        <span class="keyword">if</span>(window.isFull()) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装满则等待</span></span><br><span class="line">        <span class="keyword">while</span>(flag == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            window.pushPack(tcpPack.clone());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送TCP数据报</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> window.getSendIndex();</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>) &#123;</span><br><span class="line">            udt_send(window.getPack(index));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udt_send</span><span class="params">(TCP_PACKET stcpPack)</span> &#123;…&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitACK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//循环检查ackQueue</span></span><br><span class="line">        <span class="comment">//循环检查确认号对列中是否有新收到的ACK       </span></span><br><span class="line">        <span class="keyword">if</span>(!ackQueue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> currentAck=(ackQueue.poll() - <span class="number">1</span>) / <span class="number">100</span>; <span class="comment">//?此处已知字节流长度100</span></span><br><span class="line">            window.rcvAck(currentAck);   <span class="comment">//交于窗口处理</span></span><br><span class="line">            <span class="keyword">if</span>(!window.isFull()) &#123;     <span class="comment">//释放锁</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;…&#125;</span><br></pre></td></tr></table></figure><ul><li>当窗口未装满的情况下从上层装入包，否则进入加锁忙等；当next_to_send指针所指向的块可以发送，则发送；收到ACK后交于窗口类处理，当窗口存在空闲块时解锁。</li></ul><h3 id="receiver-1">Receiver：</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219202318815.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219202324381.png"></p><h4 id="接收方的receiverwindow.java">接收方的ReceiverWindow.java</h4><ul><li><p>数据结构：</p><p>窗口块的状态简化为两类：</p><p>0: Expected, not yet received //表示该位序的包尚未收到</p><p>1: already ack’ed //收到该位的包并应答</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************Selective-Response: 选择响应协议</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2023-12-21*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.test.CheckSum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.Client;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.TCP_Sender_ADT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_RetransTask;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_Timer;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.*;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.tool.TCP_TOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiverWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">WinSize</span> <span class="operator">=</span> <span class="number">16</span>;    <span class="comment">//窗口大小</span></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET[] tcpPacks; <span class="comment">//接收TCP数据报窗口（循环队列）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queue_base</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//窗口始端指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queue_rear</span> <span class="operator">=</span> WinSize-<span class="number">1</span>;    <span class="comment">//队末指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] flag; <span class="comment">//0:expected not yet received; 1: already ack&#x27;ed</span></span><br><span class="line">    Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReceiverWindow</span><span class="params">(Client client, <span class="type">int</span> WinSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">        <span class="built_in">this</span>.WinSize = WinSize;</span><br><span class="line">        tcpPacks = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>[WinSize];</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="title class_">int</span>[WinSize];</span><br><span class="line">        Arrays.fill(flag, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前seq是否为窗口最左端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBase</span><span class="params">(<span class="type">int</span> seq)</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">queue_base</span> <span class="operator">=</span>= seq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理收到的包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pullPack</span><span class="params">(TCP_PACKET packet)</span> &#123;</span><br><span class="line">        <span class="comment">//计算seq</span></span><br><span class="line">        <span class="type">int</span>[] data = packet.getTcpS().getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequence</span> <span class="operator">=</span> (packet.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求各项相对索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">seq_index</span> <span class="operator">=</span> sequence % WinSize;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rear_index</span> <span class="operator">=</span> queue_rear % WinSize;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base_index</span> <span class="operator">=</span> queue_base % WinSize;</span><br><span class="line">        <span class="keyword">if</span> (sequence &gt;= queue_base &amp;&amp; sequence &lt;= queue_rear) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[seq_index] == <span class="number">0</span>) &#123;   <span class="comment">//若该块未收到packet</span></span><br><span class="line">                tcpPacks[seq_index] = packet;</span><br><span class="line">                flag[seq_index] = <span class="number">1</span>; <span class="comment">//标记为已收到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequence &gt; queue_rear) &#123;     <span class="comment">//对于超前收到的包不做应答</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sequence;   <span class="comment">//对已收到的包（包括历史窗口）进行应答</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包交付处理（对有序包交付）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">seq_deliver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rear_index</span> <span class="operator">=</span> queue_rear % WinSize;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base_index</span> <span class="operator">=</span> queue_base % WinSize;</span><br><span class="line">        <span class="keyword">if</span>(flag[base_index] == <span class="number">1</span>) &#123;</span><br><span class="line">            queue_base++;</span><br><span class="line">            queue_rear++;</span><br><span class="line">            flag[base_index] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> base_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包接口</span></span><br><span class="line">    <span class="keyword">public</span> TCP_PACKET <span class="title function_">getPack</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">TCP_PACKET</span> <span class="variable">pack</span> <span class="operator">=</span> tcpPacks[index];</span><br><span class="line">        tcpPacks[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该类存在以下四个行为：</p><ul><li>isBase():返回当前收到的包序号是否为窗口最左端，用以在TCP_Receiver中进行交付判定条件；</li><li>pullPack():对收到的包进行处理，其中若该包序号为窗口对应块所期望的，则将块状态由0转换为1，以及序号为历史窗口收到过的（即重复包），返回该包序号，准备应答，而对于序号超前（即还未被窗口收纳的）包，则不做应答直接丢弃；</li><li>seq_deliver():包交付处理，用来返回当前窗口最左端块是否已完成接收，对最左端起始的连续块进行有序交付；</li><li>getPack(): 包返回接口。</li></ul></li></ul><h4 id="tcp_receiver.java">TCP_Receiver.java:</h4><p>修改了rdt_recv函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************2.1: ACK/NACK*****************/</span></span><br><span class="line"><span class="comment">/***** Feng Hong; 2015-12-09******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************Selective-Response: 选择响应协议</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2023-12-21*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> …</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCP_Receiver</span> <span class="keyword">extends</span> <span class="title class_">TCP_Receiver_ADT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET ackPack;   <span class="comment">//回复的ACK报文段</span></span><br><span class="line">    <span class="type">int</span> sequence=<span class="number">1</span>;<span class="comment">//用于记录当前待接收的包序号，注意包序号不完全是</span></span><br><span class="line">    <span class="type">int</span> pre_seq=-<span class="number">1</span>;   <span class="comment">//用于记录上一个接收成功的包序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReceiverWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReceiverWindow</span>(client, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCP_Receiver</span><span class="params">()</span> &#123;…&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//接收到数据报：检查校验和，设置回复的ACK报文段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">        <span class="comment">//检查校验码，生成ACK</span></span><br><span class="line">        <span class="keyword">if</span>(CheckSum.computeChkSum(recvPack) == recvPack.getTcpH().getTh_sum()) &#123;</span><br><span class="line">            <span class="type">int</span>[] data = recvPack.getTcpS().getData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sequence</span> <span class="operator">=</span> (recvPack.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">            <span class="type">int</span> <span class="variable">seq_to_ACK</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前应答ACK报文的seq</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                seq_to_ACK = window.pullPack(recvPack.clone());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(seq_to_ACK != -<span class="number">1</span>) &#123;     <span class="comment">//需要应答（非超前包）</span></span><br><span class="line">                tcpH.setTh_ack(seq_to_ACK * datalen + <span class="number">1</span>);</span><br><span class="line">                ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">                tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">                reply(ackPack);</span><br><span class="line">                <span class="keyword">if</span>(window.isBase(sequence)) &#123;  <span class="comment">//该包恰为最左端块</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> window.seq_deliver();</span><br><span class="line">                    <span class="keyword">while</span> (index != -<span class="number">1</span>) &#123; <span class="comment">//则将连续已接收块的包交付上层</span></span><br><span class="line">                        <span class="type">TCP_PACKET</span> <span class="variable">pack</span> <span class="operator">=</span> window.getPack(index);</span><br><span class="line">                        dataQueue.add(pack.getTcpS().getData());</span><br><span class="line">                        <span class="comment">//                            int seq = (pack.getTcpH().getTh_seq() - 1) / pack.getTcpS().getData().length;</span></span><br><span class="line">                        <span class="comment">//                            System.out.println(seq);</span></span><br><span class="line">                        index = window.seq_deliver();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else&#123;&#125; //对于收到错误包，直接丢弃</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//交付数据（每20组数据交付一次）</span></span><br><span class="line">        deliver_data();   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliver_data</span><span class="params">()</span> &#123;…&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reply</span><span class="params">(TCP_PACKET replyPack)</span> &#123;…&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先判断对接收到的包是否需要应答（超前收到的包不做应答），同时判断若为期望包是否为最左端块所期望的包，若为最左端则交付连续的有序包给上层。</p></blockquote><h3 id="测试log-2">测试Log：</h3><p>对于发送方，其不在乎NO_ACK的具体原因，只要没有收到ACK则等待倒计时结束时重发；由于倒计时时间大于RTT，因此在重发前窗口便已满，因此无法进一步缓存包、发送包，直到刚才未收到ACK（位于窗口最左端）的包倒计时结束、重发后才会有空闲块允许继续发送。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219203409303.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219203416163.png"></p><p>对于失序的问题，Receiver的窗口也很好地完成了任务，保证了接收数据的有序性：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219203424354.png"></p><h2 id="tcp-tahoe拥塞控制方法慢开始和快重传">TCPTahoe：拥塞控制方法——慢开始和快重传</h2><h3 id="设计方案-4">设计方案</h3><p>发送方维持拥塞窗口cwnd状态变量</p><ul><li>发送方让自己的发送窗口等于拥塞窗口，因此，在SR协议的基础上用cwnd取代滑动窗口。</li><li>TCP连接进行初始化时，将拥塞窗口cwnd置为1。慢开始门限ssthresh初始化为16。</li><li>发送方每收到一个确认，就把cwnd加1。</li><li>在慢开始阶段，cwnd随传输轮次RTT指数增长，当cwnd增长到慢开始门限值时，执行拥塞避免算法</li></ul><p>拥塞避免算法：</p><ul><li>cwnd随传输轮次RTT线性增长。</li></ul><p>快重传：</p><ul><li><p>当网络出现超时（发送端计时器结束），判定为网络拥塞，更新ssthresh为当前cwnd值的一半，拥塞窗口重新设置为1，并执行慢开始算法。</p></li><li><p>Tahoe协议中，接收到3个重复Ack同样判定为拥塞，同样更新ssthresh为当前cwnd值的一半，拥塞窗口重新设置为1，并执行慢开始算法。</p></li></ul><h3 id="sender-2">Sender</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219203600986.png"></p><h4 id="senderwindow.java">SenderWindow.java</h4><ul><li><p>数据结构：</p><ul><li>reAck: 记录重复包的个数，用以判定网络状况</li><li>lastAck: 记录上一ACK序号</li><li>cwnd: 拥塞窗口大小</li><li>ssthresh: 慢开始门限</li><li>curAcked: 拥塞窗口中已收到Ack的数量</li><li>RTT: 一个传输轮次（以包为单位）</li></ul></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************TCP-Tahoe</span></span><br><span class="line"><span class="comment"> **************************** 郝文轩; 2024-01-02*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.test.CheckSum;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.TCP_Sender_ADT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_RetransTask;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.FileHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.Client;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.*;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.tool.TCP_TOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SenderWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cwnd</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//拥塞窗口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ssthresh</span> <span class="operator">=</span> <span class="number">16</span>;    <span class="comment">//慢开始门限</span></span><br><span class="line">    <span class="keyword">private</span> Hashtable&lt;Integer, TCP_PACKET&gt; tcpPacks = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, TCP_PACKET&gt;();     <span class="comment">//待发送的TCP数据报窗口（循环队列）</span></span><br><span class="line">    <span class="keyword">private</span> Hashtable&lt;Integer, UDT_Timer&gt; timers = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, UDT_Timer&gt;();  <span class="comment">//为窗口内每个包分配一个计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">reAck</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//重复包个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">lastAck</span> <span class="operator">=</span> -<span class="number">1</span>;    <span class="comment">//上一ACK序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curAcked</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//窗口中已收到Ack的数量（等于cwnd时表示一个RTT结束）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">RTT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Logger logger;</span><br><span class="line">    Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetCwndAndRtt</span><span class="params">()</span> &#123; <span class="comment">//慢开始初始化</span></span><br><span class="line">        cwnd = <span class="number">1</span>;</span><br><span class="line">        curAcked = <span class="number">0</span>;</span><br><span class="line">        RTT = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tahoe_Timer</span> <span class="keyword">extends</span> <span class="title class_">UDT_RetransTask</span> &#123;</span><br><span class="line">        <span class="type">int</span> seq;</span><br><span class="line">        <span class="keyword">private</span> TCP_PACKET packet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tahoe_Timer</span><span class="params">(Client client, TCP_PACKET packet)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(client, packet);</span><br><span class="line">            <span class="type">int</span>[] data = packet.getTcpS().getData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">            seq = (packet.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">            <span class="built_in">this</span>.packet = packet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;############### 拥塞慢开始 ###############&quot;</span>);</span><br><span class="line">            ssthresh = Math.max(cwnd / <span class="number">2</span>, <span class="number">2</span>); </span><br><span class="line">            resetCwndAndRtt();</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;[慢开始阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLogger</span><span class="params">()</span>&#123;   <span class="comment">//设置log文件</span></span><br><span class="line">        logger= Logger.getLogger(SenderWindow.class.getName());</span><br><span class="line"></span><br><span class="line">        logger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">FileHandler</span> <span class="variable">fh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fh = <span class="keyword">new</span> <span class="title class_">FileHandler</span>(<span class="string">&quot;RDTSender.log&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">            fh.setFormatter(<span class="keyword">new</span> <span class="title class_">SimpleFormatter</span>());<span class="comment">//输出格式</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//       fh.setFormatter();</span></span><br><span class="line">        logger.addHandler(fh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SenderWindow</span><span class="params">(Client client)</span> &#123;</span><br><span class="line">        initLogger();</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cwnd &lt;= tcpPacks.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushPack</span><span class="params">(TCP_PACKET packet)</span> &#123;  <span class="comment">//传包</span></span><br><span class="line">        <span class="type">int</span>[] data = packet.getTcpS().getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">seq</span> <span class="operator">=</span> (packet.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">        timers.put(seq, <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>());</span><br><span class="line">        timers.get(seq).schedule(<span class="keyword">new</span> <span class="title class_">Tahoe_Timer</span>(client, packet), <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">        tcpPacks.put(seq, packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ACK处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rcvAck</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到ack: &quot;</span>+ sequence);</span><br><span class="line">        <span class="comment">//       logger.info(&quot;cwnd = &quot; + cwnd + &quot; curAcked = &quot; + curAcked);</span></span><br><span class="line">        <span class="keyword">if</span>(sequence == lastAck) &#123;    <span class="comment">//收到重复包</span></span><br><span class="line">            reAck++;</span><br><span class="line">            logger.info(<span class="string">&quot;############### 收到重复包：sequence = &quot;</span> </span><br><span class="line">            + sequence + <span class="string">&quot; 重复计数: &quot;</span> + reAck + <span class="string">&quot; ###############&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(reAck &gt;= <span class="number">3</span>) &#123;   <span class="comment">//收到3个重复包,快重传</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">resendSeq</span> <span class="operator">=</span> sequence + <span class="number">1</span>;</span><br><span class="line">                <span class="type">TCP_PACKET</span> <span class="variable">pack</span> <span class="operator">=</span> tcpPacks.get(resendSeq);</span><br><span class="line">                <span class="type">UDT_Timer</span> <span class="variable">timer</span> <span class="operator">=</span> timers.get(resendSeq);</span><br><span class="line">                <span class="keyword">if</span>(pack != <span class="literal">null</span> &amp;&amp; timer != <span class="literal">null</span>) &#123;    </span><br><span class="line">                    <span class="comment">//                      System.out.println(&quot;############### 快重传&quot;);</span></span><br><span class="line">                    client.send(pack);</span><br><span class="line">                    timer.cancel();</span><br><span class="line">                    timers.put(resendSeq, <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>());</span><br><span class="line">                    timers.get(resendSeq).schedule(<span class="keyword">new</span> <span class="title class_">Tahoe_Timer</span>(client, pack), <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">                    logger.info(<span class="string">&quot;############### 快重传：seq = &quot;</span> + resendSeq + <span class="string">&quot; ###############&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;############### Tahoe重传慢开始 ###############&quot;</span>);</span><br><span class="line">                ssthresh = Math.max(cwnd / <span class="number">2</span>, <span class="number">2</span>);     <span class="comment">//乘法减小（但不能小于2）</span></span><br><span class="line">                resetCwndAndRtt();</span><br><span class="line">                logger.info(<span class="string">&quot;[慢开始阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curAcked++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastAck +<span class="number">1</span>; i &lt;= sequence; i++) &#123;    <span class="comment">//累积确认</span></span><br><span class="line">                    tcpPacks.remove(i);</span><br><span class="line">                    <span class="keyword">if</span> (timers.containsKey(i)) &#123;</span><br><span class="line">                        timers.get(i).cancel();</span><br><span class="line">                        timers.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            lastAck = sequence; <span class="comment">//记录</span></span><br><span class="line">            reAck = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cwnd &lt; ssthresh) &#123; <span class="comment">//慢开始阶段</span></span><br><span class="line">                cwnd++;</span><br><span class="line">                <span class="keyword">if</span>(curAcked &gt;= RTT) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;[一个传输轮次]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">                    curAcked = <span class="number">0</span>;</span><br><span class="line">                    RTT *= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;   <span class="comment">//拥塞控制阶段</span></span><br><span class="line">            <span class="comment">//                 logger.info(&quot;############### cwnd = &quot; + cwnd + &quot;curAcked = &quot; + curAcked + &quot; ###############&quot;);</span></span><br><span class="line">                <span class="keyword">if</span>(curAcked &gt;= RTT) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;############### 拥塞避免 ###############&quot;</span>);</span><br><span class="line">                    curAcked = <span class="number">0</span>;</span><br><span class="line">                    cwnd ++;</span><br><span class="line">                    RTT ++;</span><br><span class="line">                    logger.info(<span class="string">&quot;[拥塞控制阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="tcp_sender.java仅对rdt_send进行修改">TCP_Sender.java(仅对rdt_send进行修改)：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可靠发送（应用层调用）：封装应用层数据，产生TCP数据报；需要修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_send</span><span class="params">(<span class="type">int</span> dataIndex, <span class="type">int</span>[] appData)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成TCP数据报（设置序号和数据字段/校验和),注意打包的顺序</span></span><br><span class="line">    tcpH.setTh_seq(dataIndex * appData.length + <span class="number">1</span>);<span class="comment">//包序号设置为字节流号：</span></span><br><span class="line">    tcpS.setData(appData);</span><br><span class="line">    tcpPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, destinAddr);       </span><br><span class="line">    <span class="comment">//更新带有checksum的TCP 报文头      </span></span><br><span class="line">    tcpH.setTh_sum(CheckSum.computeChkSum(tcpPack));</span><br><span class="line">    tcpPack.setTcpH(tcpH);</span><br><span class="line">    <span class="comment">//System.out.println(dataIndex);</span></span><br><span class="line">    <span class="comment">//若未装满则载入包</span></span><br><span class="line">    <span class="keyword">if</span>(window.isFull()) &#123;</span><br><span class="line">        <span class="comment">//             System.out.println(&quot;++++++++++++ 发送窗口满&quot;);</span></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装满则等待</span></span><br><span class="line">    <span class="keyword">while</span>(flag == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        window.pushPack(tcpPack.clone());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送TCP数据报</span></span><br><span class="line">    udt_send(tcpPack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="receiver-2">Receiver</h3><p>简化接收端的窗口，仅需实现对包次序的判断：</p><ul><li><p>收到期望包则按序将已收到的有序包交付</p></li><li><p>收到失序包（包序大于期望序），不做丢弃，提前缓存，并立即发送ACK（快重传）等待该序号之前的包悉数收到后，按有序包交付。</p></li></ul><p>TCP_Receiver.java（对rdt_recv进行修改）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到数据报：检查校验和，设置回复的ACK报文段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">    <span class="comment">//检查校验码，生成ACK</span></span><br><span class="line">    <span class="keyword">if</span>(CheckSum.computeChkSum(recvPack) == recvPack.getTcpH().getTh_sum()) &#123;</span><br><span class="line">        <span class="type">int</span>[] data = recvPack.getTcpS().getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequence</span> <span class="operator">=</span> (recvPack.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">        <span class="keyword">if</span>(sequence == excSeq) &#123;    <span class="comment">//若收到期望包</span></span><br><span class="line">            dataQueue.add(data);</span><br><span class="line">            excSeq ++;</span><br><span class="line">            <span class="keyword">while</span>(packets.containsKey(excSeq)) &#123;    <span class="comment">//将有序包逐个上传，并从窗口中剔除</span></span><br><span class="line">                dataQueue.add(packets.get(excSeq).getTcpS().getData());</span><br><span class="line">                packets.remove(excSeq);</span><br><span class="line">                excSeq ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dataQueue.size() &gt;= <span class="number">20</span> || excSeq &gt;= <span class="number">999</span>)</span><br><span class="line">                deliver_data();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">//若收到失序包</span></span><br><span class="line">            <span class="keyword">if</span>(!packets.contains(sequence) &amp;&amp; sequence &gt; excSeq) &#123;</span><br><span class="line">                 packets.put(sequence, recvPack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tcpH.setTh_ack((excSeq - <span class="number">1</span>) * datalen + <span class="number">1</span>);<span class="comment">//生成ACK报文段</span></span><br><span class="line">        ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">        tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">        reply(ackPack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交付数据（每20组数据交付一次）</span></span><br><span class="line">    deliver_data();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证logsender.log">验证（Log+Sender.log）</h3><ul><li>慢启动：</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219204753627.png"></p><blockquote><p>TCP初连时设置cwnd为1且ssthresh为16，因此cwnd呈指数增长。</p></blockquote><ul><li>拥塞避免（加法增大）：</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219204806227.png"></p><blockquote><p>当cwnd大于ssthresh时，执行拥塞避免算法，cwnd随RTT呈线性增长。</p></blockquote><ul><li>收到3个重复ACK后执行乘法减小、快重传：</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219204825089.png"></p><p>发送方收到三个重复的162序号ACK执行快重传163，并乘法减小，使ssthresh变为当前cwnd大小（22）的一半，然后重置cwnd为1，执行慢开始：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219204844258.png"></p><blockquote><p>其中可以看到这样的现象：发送方有些包no_ack但是并没有进行重传，这是因为接收方的累积确认，如果发送方（在timer之内）收到了比no_ack报文段序号更高序号的ACK，则证明接收方已经收到了那个包，no_ack的原因可能是ack丢失或者延迟，因此发送方没必要再重发这个包。这也体现了TCP累积确认的重要意义。</p></blockquote><h2 id="tcp-reno-快恢复">TCP Reno: 快恢复</h2><p>TCP Reno与TCPTahoe的唯一区别，就是对发送端连续收到收到三个重复ACK并执行快重传之后的处理方式。正如上面所实现的，Tahoe方式是将cwnd直接重置为1，并且以慢开始方式增长cwnd；而Reno则是在ssthresh执行完“乘法减小”之后，令cwnd恢复到ssthresh的大小，因而是执行拥塞避免（加法增大）算法。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219204926612.png"></p><p>因此这个版本的修改较为简单，仅需要在SenderWindow类中修改收到三个ACK之后的执行方式为拥塞避免算法即可。</p><h3 id="senderwindow.java仅修改handledeuplicateack函数">SenderWindow.java（仅修改handleDeuplicateAck函数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleDuplicateAck</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;     <span class="comment">//重复包处理</span></span><br><span class="line"></span><br><span class="line">    reAck++;</span><br><span class="line">    logger.info(<span class="string">&quot;############### 收到重复包：sequence = &quot;</span> + sequence + <span class="string">&quot; 重复计数: &quot;</span> + reAck + <span class="string">&quot; ###############&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (reAck &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        performFastRetransmit(sequence);</span><br><span class="line">        logger.info(<span class="string">&quot;[慢开始阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performCongestionAvoidance</span><span class="params">()</span> &#123; <span class="comment">//拥塞避免</span></span><br><span class="line">    <span class="keyword">if</span> (curAcked &gt;= RTT) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############### 拥塞避免 ###############&quot;</span>);</span><br><span class="line">        curAcked = <span class="number">0</span>;</span><br><span class="line">        cwnd++;</span><br><span class="line">        RTT++;</span><br><span class="line">        logger.info(<span class="string">&quot;[拥塞控制阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这部分是我最终的实验设计，我将会把TCP-Reno的完整代码、Log文件及验证说明放在下一部分——实验结果中说明。</p><h1 id="实验结果tcp-reno">实验结果——TCP Reno</h1><h2 id="完整代码">完整代码</h2><h3 id="checksum.java">CheckSum.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.CRC32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.TCP_HEADER;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.TCP_SEGMENT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.TCP_PACKET;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算TCP报文段校验和：只需校验TCP首部中的seq、ack和sum，以及TCP数据字段*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">computeChkSum</span><span class="params">(TCP_PACKET tcpPack)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">checkSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">CRC32</span> <span class="variable">crc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CRC32</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从首部获取seq、ack和sum*/</span></span><br><span class="line">        <span class="type">TCP_HEADER</span> <span class="variable">header</span> <span class="operator">=</span> tcpPack.getTcpH();</span><br><span class="line">        crc.update(header.getTh_seq());</span><br><span class="line">        crc.update(header.getTh_ack());</span><br><span class="line">        <span class="comment">//        crc.update(header.getTh_sum());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从数据部获取数据*/</span></span><br><span class="line">        <span class="type">TCP_SEGMENT</span> <span class="variable">segment</span> <span class="operator">=</span> tcpPack.getTcpS();</span><br><span class="line">        <span class="type">int</span>[] data = segment.getData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; data.length; i++) &#123;</span><br><span class="line">            crc.update(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*计算校验和*/</span></span><br><span class="line">        checkSum = crc.getValue();</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) checkSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp_sender.java-1">TCP_Sender.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************2.1: ACK/NACK</span></span><br><span class="line"><span class="comment">**************************** Feng Hong; 2015-12-09*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************TCP-Reno</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2024-01-02*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.test.CheckSum;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.TCP_Sender_ADT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_RetransTask;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_Timer;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.*;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.tool.TCP_TOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCP_Sender</span> <span class="keyword">extends</span> <span class="title class_">TCP_Sender_ADT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET tcpPack;   <span class="comment">//待发送的TCP数据报</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//private UDT_Timer timer;   //计时器</span></span><br><span class="line">    <span class="comment">//private UDT_RetransTask reTrans;    //重传任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SenderWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SenderWindow</span>(client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCP_Sender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">//调用超类构造函数</span></span><br><span class="line">        <span class="built_in">super</span>.initTCP_Sender(<span class="built_in">this</span>);        <span class="comment">//初始化TCP发送端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//可靠发送（应用层调用）：封装应用层数据，产生TCP数据报；需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_send</span><span class="params">(<span class="type">int</span> dataIndex, <span class="type">int</span>[] appData)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成TCP数据报（设置序号和数据字段/校验和),注意打包的顺序</span></span><br><span class="line">    tcpH.setTh_seq(dataIndex * appData.length + <span class="number">1</span>);<span class="comment">//包序号设置为字节流号：</span></span><br><span class="line">    tcpS.setData(appData);</span><br><span class="line">    tcpPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, destinAddr);       </span><br><span class="line">    <span class="comment">//更新带有checksum的TCP 报文头      </span></span><br><span class="line">    tcpH.setTh_sum(CheckSum.computeChkSum(tcpPack));</span><br><span class="line">    tcpPack.setTcpH(tcpH);</span><br><span class="line">    <span class="comment">//System.out.println(dataIndex);</span></span><br><span class="line">    <span class="comment">//若未装满则载入包</span></span><br><span class="line">    <span class="keyword">if</span>(window.isFull()) &#123;</span><br><span class="line">        <span class="comment">//             System.out.println(&quot;++++++++++++ 发送窗口满&quot;);</span></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装满则等待</span></span><br><span class="line">    <span class="keyword">while</span>(flag == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            window.pushPack(tcpPack.clone());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送TCP数据报</span></span><br><span class="line">        udt_send(tcpPack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//不可靠发送：将打包好的TCP数据报通过不可靠传输信道发送；仅需修改错误标志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udt_send</span><span class="params">(TCP_PACKET stcpPack)</span> &#123;</span><br><span class="line">        <span class="comment">//设置错误控制标志</span></span><br><span class="line">        tcpH.setTh_eflag((<span class="type">byte</span>)<span class="number">7</span>);        </span><br><span class="line">        <span class="comment">//System.out.println(&quot;to send: &quot;+stcpPack.getTcpH().getTh_seq());                    </span></span><br><span class="line">        <span class="comment">//发送数据报</span></span><br><span class="line">        client.send(stcpPack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitACK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//循环检查ackQueue</span></span><br><span class="line">        <span class="comment">//循环检查确认号对列中是否有新收到的ACK       </span></span><br><span class="line">        <span class="keyword">if</span>(!ackQueue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> currentAck=(ackQueue.poll() - <span class="number">1</span>) / <span class="number">100</span>; <span class="comment">//?此处已知字节流长度100</span></span><br><span class="line">            window.rcvAck(currentAck);   <span class="comment">//交于窗口处理</span></span><br><span class="line">            <span class="keyword">if</span>(!window.isFull()) &#123;     <span class="comment">//释放锁</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//接收到ACK报文：检查校验和，将确认号插入ack队列;NACK的确认号为-1；不需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Receive ACK Number： &quot;</span>+ recvPack.getTcpH().getTh_ack());</span><br><span class="line">    ackQueue.add(recvPack.getTcpH().getTh_ack());</span><br><span class="line">    System.out.println();   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理ACK报文</span></span><br><span class="line">    waitACK();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="senderwindow.java-1">SenderWindow.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************TCP-Reno</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2024-01-02*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.test.CheckSum;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.TCP_Sender_ADT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_RetransTask;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.UDT_Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.FileHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.Client;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.*;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.tool.TCP_TOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SenderWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cwnd</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//拥塞窗口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ssthresh</span> <span class="operator">=</span> <span class="number">16</span>;    <span class="comment">//慢开始门限</span></span><br><span class="line">    <span class="keyword">private</span> Hashtable&lt;Integer, TCP_PACKET&gt; tcpPacks = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, TCP_PACKET&gt;();     <span class="comment">//待发送的TCP数据报窗口（循环队列）</span></span><br><span class="line">    <span class="keyword">private</span> Hashtable&lt;Integer, UDT_Timer&gt; timers = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, UDT_Timer&gt;();  <span class="comment">//为窗口内每个包分配一个计时器</span></span><br><span class="line">    <span class="comment">//  private int queue_base = 0;   //窗口始端指针</span></span><br><span class="line">    <span class="comment">//  private int next_to_send = 0;  //待发送包指针</span></span><br><span class="line">    <span class="comment">//  private int queue_rear = 0;   //队末指针</span></span><br><span class="line">    <span class="comment">//  private int[] flag; //0:have no pkt; 1:usable not yet send; 2:sent not yet ack&#x27;ed; 3: already ack&#x27;ed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">reAck</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//重复包个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">lastAck</span> <span class="operator">=</span> -<span class="number">1</span>;    <span class="comment">//上一ACK序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curAcked</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//窗口中已收到Ack的数量（等于cwnd时表示一个RTT结束）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">RTT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Logger logger;</span><br><span class="line">    Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetCwndAndRtt</span><span class="params">()</span> &#123;</span><br><span class="line">        cwnd = <span class="number">1</span>;</span><br><span class="line">        curAcked = <span class="number">0</span>;</span><br><span class="line">        RTT = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tahoe_Timer</span> <span class="keyword">extends</span> <span class="title class_">UDT_RetransTask</span> &#123;</span><br><span class="line">        <span class="type">int</span> seq;</span><br><span class="line">        <span class="keyword">private</span> TCP_PACKET packet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tahoe_Timer</span><span class="params">(Client client, TCP_PACKET packet)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(client, packet);</span><br><span class="line">            <span class="type">int</span>[] data = packet.getTcpS().getData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">            seq = (packet.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">            <span class="built_in">this</span>.packet = packet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;############### 拥塞慢开始 ###############&quot;</span>);</span><br><span class="line">            ssthresh = Math.max(cwnd / <span class="number">2</span>, <span class="number">2</span>); </span><br><span class="line">            resetCwndAndRtt();</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;[慢开始阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLogger</span><span class="params">()</span>&#123;</span><br><span class="line">        logger= Logger.getLogger(SenderWindow.class.getName());</span><br><span class="line"></span><br><span class="line">        logger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">FileHandler</span> <span class="variable">fh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fh = <span class="keyword">new</span> <span class="title class_">FileHandler</span>(<span class="string">&quot;Sender.log&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">            fh.setFormatter(<span class="keyword">new</span> <span class="title class_">SimpleFormatter</span>());<span class="comment">//输出格式</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//       fh.setFormatter();</span></span><br><span class="line">        logger.addHandler(fh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SenderWindow</span><span class="params">(Client client)</span> &#123;</span><br><span class="line">        initLogger();</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cwnd &lt;= tcpPacks.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleDuplicateAck</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;    <span class="comment">//重复包处理</span></span><br><span class="line">        reAck++;</span><br><span class="line">        logger.info(<span class="string">&quot;############### 收到重复包：sequence = &quot;</span> + sequence + <span class="string">&quot; 重复计数: &quot;</span> + reAck + <span class="string">&quot; ###############&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (reAck &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            performFastRetransmit(sequence);</span><br><span class="line">            logger.info(<span class="string">&quot;[慢开始阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performFastRetransmit</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;   <span class="comment">//快重传与快恢复</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resendSeq</span> <span class="operator">=</span> sequence + <span class="number">1</span>;</span><br><span class="line">        <span class="type">TCP_PACKET</span> <span class="variable">pack</span> <span class="operator">=</span> tcpPacks.get(resendSeq);</span><br><span class="line">        <span class="type">UDT_Timer</span> <span class="variable">timer</span> <span class="operator">=</span> timers.get(resendSeq);</span><br><span class="line">        <span class="keyword">if</span> (pack != <span class="literal">null</span> &amp;&amp; timer != <span class="literal">null</span>) &#123;</span><br><span class="line">            client.send(pack);</span><br><span class="line">            timer.cancel();</span><br><span class="line">            timers.put(resendSeq, <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>());</span><br><span class="line">            timers.get(resendSeq).schedule(<span class="keyword">new</span> <span class="title class_">Tahoe_Timer</span>(client, pack), <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">            logger.info(<span class="string">&quot;############### 快重传：seq = &quot;</span> + resendSeq + <span class="string">&quot; ###############&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;############### Reno快恢复 ###############&quot;</span>);</span><br><span class="line">        ssthresh = Math.max(cwnd / <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        cwnd = ssthresh;</span><br><span class="line">        RTT = cwnd;</span><br><span class="line">        curAcked = <span class="number">0</span>;</span><br><span class="line">        performCongestionAvoidance();</span><br><span class="line">        <span class="comment">//logger.info(&quot;[慢开始阶段]拥塞窗口信息：cwnd = &quot; + cwnd + &quot; ssthresh = &quot; + ssthresh);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performCongestionAvoidance</span><span class="params">()</span> &#123; <span class="comment">//拥塞避免</span></span><br><span class="line">        <span class="keyword">if</span> (curAcked &gt;= RTT) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;############### 拥塞避免 ###############&quot;</span>);</span><br><span class="line">            curAcked = <span class="number">0</span>;</span><br><span class="line">            cwnd++;</span><br><span class="line">            RTT++;</span><br><span class="line">            logger.info(<span class="string">&quot;[拥塞控制阶段]拥塞窗口信息：cwnd = &quot;</span> + cwnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performSlowStart</span><span class="params">()</span> &#123; <span class="comment">//慢开始</span></span><br><span class="line">        cwnd++;</span><br><span class="line">        <span class="keyword">if</span> (curAcked &gt;= RTT) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;[一个传输轮次]拥塞窗口信息：cwnd = &quot;</span> + cwnd + <span class="string">&quot; ssthresh = &quot;</span> + ssthresh);</span><br><span class="line">            curAcked = <span class="number">0</span>;</span><br><span class="line">            RTT *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleNewAck</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;  <span class="comment">//处理新Ack</span></span><br><span class="line">        curAcked++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastAck + <span class="number">1</span>; i &lt;= sequence; i++) &#123;</span><br><span class="line">            tcpPacks.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (timers.containsKey(i)) &#123;</span><br><span class="line">                timers.get(i).cancel();</span><br><span class="line">                timers.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastAck = sequence;</span><br><span class="line">        reAck = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cwnd &lt; ssthresh) &#123;</span><br><span class="line">            performSlowStart();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            performCongestionAvoidance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushPack</span><span class="params">(TCP_PACKET packet)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] data = packet.getTcpS().getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">seq</span> <span class="operator">=</span> (packet.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">        timers.put(seq, <span class="keyword">new</span> <span class="title class_">UDT_Timer</span>());</span><br><span class="line">        timers.get(seq).schedule(<span class="keyword">new</span> <span class="title class_">Tahoe_Timer</span>(client, packet), <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">        tcpPacks.put(seq, packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对ACK处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rcvAck</span><span class="params">(<span class="type">int</span> sequence)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到ack: &quot;</span>+ sequence);</span><br><span class="line">        <span class="comment">//       logger.info(&quot;cwnd = &quot; + cwnd + &quot; curAcked = &quot; + curAcked);</span></span><br><span class="line">        <span class="keyword">if</span>(sequence == lastAck) &#123;    <span class="comment">//收到重复包</span></span><br><span class="line">        handleDuplicateAck(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        handleNewAck(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp_receiver.java-1">TCP_Receiver.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************2.1: ACK/NACK*****************/</span></span><br><span class="line"><span class="comment">/***** Feng Hong; 2015-12-09******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************TCP-Reno</span></span><br><span class="line"><span class="comment">**************************** 郝文轩; 2024-01-02*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.test.CheckSum;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.client.TCP_Receiver_ADT;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.message.*;</span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.tool.TCP_TOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCP_Receiver</span> <span class="keyword">extends</span> <span class="title class_">TCP_Receiver_ADT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TCP_PACKET ackPack;   <span class="comment">//回复的ACK报文段</span></span><br><span class="line">    <span class="type">int</span> sequence=<span class="number">1</span>;<span class="comment">//用于记录当前待接收的包序号，注意包序号不完全是</span></span><br><span class="line">    <span class="comment">//  int pre_seq=-1;   //用于记录上一个接收成功的包序号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">excSeq</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//期望数据包seq</span></span><br><span class="line">    <span class="keyword">private</span> Hashtable&lt;Integer, TCP_PACKET&gt; packets = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, TCP_PACKET&gt;();</span><br><span class="line">    <span class="comment">//  private ReceiverWindow window = new ReceiverWindow(client, 16);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCP_Receiver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">//调用超类构造函数</span></span><br><span class="line">        <span class="built_in">super</span>.initTCP_Receiver(<span class="built_in">this</span>);  <span class="comment">//初始化TCP接收端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//接收到数据报：检查校验和，设置回复的ACK报文段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rdt_recv</span><span class="params">(TCP_PACKET recvPack)</span> &#123;</span><br><span class="line">        <span class="comment">//检查校验码，生成ACK</span></span><br><span class="line">        <span class="keyword">if</span>(CheckSum.computeChkSum(recvPack) == recvPack.getTcpH().getTh_sum()) &#123;</span><br><span class="line">            <span class="type">int</span>[] data = recvPack.getTcpS().getData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">datalen</span> <span class="operator">=</span> data.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sequence</span> <span class="operator">=</span> (recvPack.getTcpH().getTh_seq() - <span class="number">1</span>) / datalen;</span><br><span class="line">            <span class="keyword">if</span>(sequence == excSeq) &#123;</span><br><span class="line">                dataQueue.add(data);</span><br><span class="line">                excSeq ++;</span><br><span class="line">                <span class="keyword">while</span>(packets.containsKey(excSeq)) &#123;</span><br><span class="line">                    dataQueue.add(packets.get(excSeq).getTcpS().getData());</span><br><span class="line">                    packets.remove(excSeq);</span><br><span class="line">                    excSeq ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dataQueue.size() &gt;= <span class="number">20</span> || excSeq &gt;= <span class="number">999</span>)</span><br><span class="line">                    deliver_data();</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!packets.contains(sequence) &amp;&amp; sequence &gt; excSeq) &#123;</span><br><span class="line">                    packets.put(sequence, recvPack);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tcpH.setTh_ack((excSeq - <span class="number">1</span>) * datalen + <span class="number">1</span>);<span class="comment">//生成ACK报文段</span></span><br><span class="line">            ackPack = <span class="keyword">new</span> <span class="title class_">TCP_PACKET</span>(tcpH, tcpS, recvPack.getSourceAddr());</span><br><span class="line">            tcpH.setTh_sum(CheckSum.computeChkSum(ackPack));</span><br><span class="line">            reply(ackPack);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//交付数据（每20组数据交付一次）</span></span><br><span class="line">        deliver_data();   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//交付数据（将数据写入文件）；不需要修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliver_data</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查dataQueue，将数据写入文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;recvData.txt&quot;</span>);</span><br><span class="line">        BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(fw, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环检查data队列中是否有新交付数据</span></span><br><span class="line">            <span class="keyword">while</span>(!dataQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">int</span>[] data = dataQueue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将数据写入文件</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                writer.write(data[i] + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                writer.flush();        <span class="comment">//清空输出缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//回复ACK报文段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reply</span><span class="params">(TCP_PACKET replyPack)</span> &#123;</span><br><span class="line">        <span class="comment">//设置错误控制标志</span></span><br><span class="line">        tcpH.setTh_eflag((<span class="type">byte</span>)<span class="number">7</span>);   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据报</span></span><br><span class="line">        client.send(replyPack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="testrun.java">TestRun.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ouc.tcp.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ouc.tcp.app.SystemStart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRun</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        SystemStart.main(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果验证">实验结果验证</h2><h3 id="sender.log">Sender.log</h3><ol type="1"><li><p>初始化慢开始: cwnd=1, ssthresh=16</p><p>根据日志文件可以明显看出，TCP在建立连接后首先执行的是慢开始算法，在这个阶段，cwnd窗口大小每收到一个ACK就扩大一个单位MSS，每经过一个RTT（传输轮次），cwnd就扩大一倍。在这个阶段中，cwnd窗口的大小与RTT呈指数相关增长。</p></li></ol><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219210930569.png"></p><ol start="2" type="1"><li><p>拥塞控制阶段: cwnd&gt;ssthresh, ssthresh=16</p><p>在拥塞窗口cwnd长度到达慢开始门限ssthresh时，将开始执行加法增大的拥塞控制算法。在这个阶段中，每经过一个传输轮次RTT，cwnd增加一个单位MSS大小，因此cwnd关于RTT呈线性增长。</p></li></ol><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219210949006.png"></p><ol start="3" type="1"><li><p>（收到三个连续ACK）快重传、快恢复:cwnd=21,收到重复包:sequence=118</p><p>在cwnd=21时，发送方连续收到三个报文段序号为118的ACK，此时立刻重传119报文段（快重传），在快重传之后，立刻执行快恢复，此时将ssthresh乘法减小为10，并执行拥塞控制算法，从cwnd=10开始加法增大、线性增长。</p></li></ol><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211006258.png"></p><h3 id="log.txt">Log.txt</h3><p>由于Log.txt可包含信息受限，我们仅能从中看出ACK接受情况和重传情况。截图部分，则是映照了上文中对119的快重传。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211021294.png"></p><p>对应的，接收端发送了三个重复的118：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211026703.png"></p><p>通过这两个截图我们还可以获取到这样的信息：累计确认的作用。</p><p>发送方有些包no_ack但是并没有进行重传，这是因为接收方的累积确认，如果发送方（在timer之内）收到了比no_ack报文段序号更高序号的ACK，则证明接收方已经收到了那个包，no_ack的原因可能是ack丢失或者延迟，因此发送方没必要再重发这个包。</p><p>并且，累计确认为接收端“发送三个重复ACK”的情景提供了条件，这个过程中，接收端可以照常收到发送端发送的报文段120、121，但是由于119的缺失，接收端为了保证有序而使得接收窗口即使正确收到了120、121报文段，却仅仅将其缓存下来，而回应的ACK仍然是窗口最左端的118，直到发送端重传119并被接收端收到之后，窗口才会右移到下一期望报文段序号前，并发送一个累计确认ACK序号。因此，这就是我们在Log.txt文件中的发送端看到120、121是no_ack并没有重传，而接收端连续发送了三个118的ACK的原因。</p><p>因此，我实现的累积确认功能也顺便得到了很好的验证。</p><h3 id="recvdata.txt">RecvData.txt</h3><p>RecvData的意义，就是用来验证数据是否按序交付给上层，这是可靠传输的重要需求。由于文件过大而不可能悉数展示，仅将最后部分展示如下：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211049614.png"></p><p>可以看出，接收端成功地按序将数据传输到了上层。至此，完全证明了我所实现的TCP_Reno达到了可靠传输、拥塞控制、流水线设计的要求。</p><h1 id="实验中遇到的问题难点及解决方案">实验中遇到的问题、难点及解决方案</h1><h2 id="crc校验和计算">CRC校验和计算</h2><p>最初我直接从首部获取sum，然而log中NO_ACK铺满屏幕，说明被校验为错误后出现重发死循环，也就是说我的校验和计算函数出现了问题。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211131474.png"></p><p>解决方法则是在检验和计算中删掉sum。</p><h2 id="延迟送达的包导致乱序">延迟送达的包导致乱序</h2><p>在进行RDT3.0设计时，发现原先Receiver对seq的确认仅考虑了是否与上一个包是重复的if(sequence!= this.pre_seq)，因此在接收到延迟的数据包时会被错误交付给上层。</p><p>解决方法则是对延迟收到的包丢弃if(sequence &gt; this.pre_seq)。</p><h2 id="选择响应协议中出现的死循环bug"><strong>选择响应协议中出现的死循环bug</strong></h2><p>在我最初的设计中，测试时发现这个问题：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211157818.png"></p><p>窗口范围内的包不断重发，窗口未移动，经过排查后发现：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211203632.png"></p><p>Sender对于未得到响应的包重发时，取代了该线程本该发送的包，使得窗口序号与数据包序号无法对应，接收方一直在等待该包、而发送方的窗口对应的序号存放了其他序号的数据，于是一直在重发“位于接收方期望的窗口位置的包但实际序号并非接收方所期望的包”，于是接收方ACK、发送方重发……</p><p>在代码中排错后发现：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211211747.png"></p><p>我原本的代码将“窗口满”的忙等循环放在了当前数据包递交给窗口处理操作之后，导致该包被缓存后并未被发送，因而造成了死循环。解决方法则是调转顺序，在窗口处理操作之前就加锁等待空闲块。</p><h2 id="慢开始阶段cwnd每收到一个ack就应该1而非等到rtt后一次性2">慢开始阶段cwnd每收到一个ACK就应该+1，而非等到RTT后一次性*2</h2><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211225239.png"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20240219211232269.png"></p><p>为了解决这个问题，我另外设置了一个变量RTT，用来实现对传输轮次的记录，从而保证cwnd在每次接收到Ack之后自加1的同时，curAcked变量的值还能随传输轮次进行更新。</p><h1 id="事后">事后🚬</h1><h2 id="一本正经地">一本正经地</h2><h3 id="实验设计上的必要解释">实验设计上的必要解释</h3><p>事实上由Selective-Response到TCP-Tahoe的开发过程并没有真正的迭代，因为TCP协议是结合了GBN和SR，其中Receiver对收到的包是进行累积确认的，而不同于SR的单个确认，因此在这里需要推翻原本建立的方式；尽管如此，由于TCP协议中对失序包的处理仍使用SR的方式，因此我还是认为这是一个迭代的过程。（当然如果我在RDT4的部分选择了实现TCP而非GBN或SR，将会是严格意义上的迭代开发）。</p><p>本实验中的timer也并未严格按照RTT进行更新，仅依靠主观设置时长，当然不严谨，但对于似乎并不在本实验所注重的内容中，因此自行设置的重传时间已经足够。</p><p>本实验中seq实际上的值应当是以字节为单位的序号，也即包的序号*datalen之后的值，但为了方便进行窗口大小单位和顺序标定的统一，我在实验中直接将seq粗略的设定为以包（报文段）为单位的数值，把拥塞窗口的单位设置为一个报文段长度（这是由于TCP_PACKETS作为传输单位所决定的）,这并不严谨。同时，由于显而易见的在本实验中每个报文段中包含100个单位的数据，因此同样粗略的，我在某些不能计算出datalen（或者说不便于计算）的情况中，将MSS设定为了100，在这个过程中，我同样粗略的将不同报文段的实际长度与最大报文段长度、报文段序号与seq值等单位干脆混为一谈，然而在现实的实现中这几个单位应当是有着区别的。</p><h3 id="实验总结">实验总结</h3><p>从我的实验报告篇幅就可以看出，我在这个实验上下了很大功夫，这不仅仅是出于教学要求，更重要的是我在其中得到了很大的满足感和获得感，<strong>迭代设计</strong>的开发原则就是这样刺激人们的头脑，如同垒高楼一样，一点一点向上铺盖，不断提出问题、解决问题，直到满足现有的需求，这很突出的体现了一个系统设计的原则——<strong>复杂性递增原则</strong>。因而，我在试验中获得的最大收获是，对计算机系统设计工程的思考与验证：</p><h4 id="模块化">模块化</h4><p>在实验设计的最一开始，现有的资源就已经为我们提供了一定的模块化，<strong>坚不可摧的基础法则</strong>下，我们对于迭代开发的过程变得更加简单。仅举例而言，我在实现RDT4的基础上实现TCP_Tahoe的过程中，仅需要修改SenderWindow模块，而基本不需要对将其调用的上层驱动模块进行修改，就可以在SR的基础上实现拥塞控制等功能；再例如，从TCP_Tahoe到TCP_Reno的迭代，更细致地模块单元变更，我只需要修改“收到重复包后的处理”中，将调用更改为执行拥塞控制算法，即可满足从Tahoe到Reno的更新。<strong>更改模块比更改模块化更容易</strong>，这其中也是<strong>强制模块化</strong>的主要体现。</p><h4 id="抽象化">抽象化</h4><p>在我看来，滑动窗口的设计就是一个抽象的过程。举例而言，我所实现的SenderWindow类，就掩盖了下层对于收到ACK的不同情况的不同处理，例如：如果收到三个重复ACK，窗口将会如何活动，如果timeout，又该如何处理，但通过窗口作为间接层的设计，这些复杂性将透明于上层，不为上层所考虑，TCP_Sender只需要——实例化这个SenderWindow的间接，当收到ACK时直接交给他来处理而不用操心他是怎么处理的，再由他将下一个应当发送的报文段返回给TCP_Sender，进行发送……<strong>任何问题都可以通过增加一层间接来解决，或者说，计算机系统都可以通过移除一层间接来加快速度</strong>。抽象使得模块之间的交互很少甚至没有、任何模块都能完全根据其外部规范来处理所有其他模块而不需要了解内部发生了什么，其将接口与内部内容分离，将规范与显示内容分离。这便是<strong>间接方式解耦模块化</strong>的设计原则。</p><h4 id="分层化">分层化</h4><p>当然的，计算机网络的协议栈本身就是分层的设计思想的体现，在本实验中也有体现——接收端运输层对收到的报文进行处理，按批交付给上层应用层，这个过程便是分层化的主要思想。类似的，我要说的不止是在协议栈上的分层思想，而是<strong>通过抽象设计来减少模块互联的模块组织方法，最终形成了分层的组织方法</strong>。在使用层进行设计时，可以建立在一组已经完成的底层上，使用之创建不同的不同完整机制（上层）。<strong>减少了模块之间的互连</strong>，从一小组模块开始，并将它们组装成一个稳定的、独立的子系统，它由一个定义良好的接口。接下来，组装一小群子系统来产生一个更大的子系统。这是对间接与抽象在宏观上的表述。</p><h4 id="迭代">迭代</h4><p>迭代本质就是<strong>首先构建一个简单的、可工作的系统，它只满足需求的少量子集，然后以小的步骤发展该系统，逐渐包括越来越多的完整需求集</strong>。无论是我们在这个小的实验中所复现的运输层RDT协议的发展过程，还是纵观整个计算机网络的发展历史，我们都不难看出，一个完整的、尽可能解决所有问题的、应对一切复杂性的、随时代更新的系统，都<strong>应当被设计得容易修改</strong>，为迭代设计做好准备，这是每一位系统工程师及设计者应当具备的品质——<strong>未雨绸缪，我们不会一次性正确</strong>。这正是我们前述铺垫的模块化、抽象、分层或层级所要实现的目的。正是这些应对复杂性的方法，让我们的设计有了随着需求而更新的可能。</p><h2 id="瞎说两句">瞎说两句</h2><p>上面的总结，我是搬来上学期计工课的内容，觉得但凡涉及到系统的设计，偏离不了这几点，改改术语、套套皮，就是一篇不错的课设总结，词汇也高大上（毕竟机翻来的生疏语感，总给人一种很专业的感觉），这叫strong，死装。</p><p>说我真从中学到东西了吗？撑死，是对计网期末考试时候涉及到运输层的内容有了很深刻的理解，动作起来也很称心应手。但要是说对我专业能力加没加点，我直言是寡淡：学会如何设计虽然重要，但像我这种半吊子选手玩网络也就是51CTO热粉，照着别人嚼过的馒头鼓捣鼓捣路由器，我更感兴趣些，因此要不是守着三瓜两枣的绩点，我对网络的学习绝不会想到要照本宣科去复现TCP。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/7c73390aa9966d8244df590b0d2c90d.jpg" style="zoom:25%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可靠传输 </tag>
            
            <tag> TCP Reno </tag>
            
            <tag> 传输层协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]增强对抗可迁移性的自适应模型集成对抗攻击-AdaEA</title>
      <link href="/article/c0626774/"/>
      <url>/article/c0626774/</url>
      
        <content type="html"><![CDATA[<h1 id="information">Information</h1><blockquote><p>论文位置：[<a href="http://arxiv.org/abs/2308.02897">2308.02897] AnAdaptive Model Ensemble Adversarial Attack for Boosting AdversarialTransferability (arxiv.org)</a></p><p>日期：2023-08</p><p>关键词：Adversarial Attack</p><p>出处：ICCV 2023</p></blockquote><h1 id="概述">概述</h1><p>以往的关于可迁移对抗攻击的工作大多研究梯度变化或图像变换来放大输入关键部位的失真，这些方法可以在有限差异的模型之间进行迁移，即从CNNs迁移到CNNs，但总是无法在差异较大的模型之间进行迁移，如从CNNs迁移到ViTs。或者，提出模型集成对抗攻击，将来自不同架构代理模型的输出进行融合，得到一个集成损失，使得生成的对抗样本更有可能迁移到其他模型，因其可以同时欺骗多个模型。</p><p>然而现有的集成攻击只是简单地将代理模型的输出进行均匀融合，无法有效捕获和放大对抗样本的内在迁移信息。本论文提出一种称为AdaEA的自适应集成攻击，通过监控每个模型的输出对对抗目标贡献的差异比例来自适应控制每个模型的输出的融合。此外，为了进一步同步更新方向，还引入了额外的视差减小滤波器。</p><h1 id="背景">背景</h1><p>类似于传统的集成方法利用多个具有不同预测的弱学习器的智慧来提高整体精度，一系列研究提出利用代理模型的集成来生成能够成功攻击所有代理模型的对抗样本。从直觉上讲，该方法可以提高对抗样本的可迁移性，因其可以捕获内在的可迁移对抗信息，可以同时欺骗多个具有广泛差异的模型。</p><p>现有的大多数集成方法只是将所有模型的输出即（logits或loss）等量融合得到一个集成损失，用于实施基于梯度的攻击，这可能会限制模型集成攻击的潜在能力。</p><p>由于忽略了每个模型的个体特征，这样的集成是欠优化的。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140650534.png" alt="图1，不同攻击方案及性能概述。(a)基于迁移的方法通过强化图像中的关键部分来提高攻击的可迁移性，但由于对抗信息有限，无法在差异较大的DNN之间进行转移。(b)模型集成攻击通过集成多个代理模型来寻找更具可迁移性的攻击，但现有工作普遍忽略了每个模型的个体特征，导致结果不够理想。(c)本论文的AdaEA通过放大每个代理模型中的可迁移信息来进行自适应集成，并取得了显著改进。"></p><p>本论文重点研究模型集成对抗攻击，以提高对抗样本的可迁移性。可以观察到，简单地对集成模型的输出进行平均忽略了每个模型的优势，在融合过程中，从一个模型捕获的可迁移信息可以被另一个模型平滑，从而导致结果欠优化。</p><p>为了解决这个问题，本论文提出通过自适应梯度调制(Adaptive GradientModulation,AGM)策略对每个模型的输出进行自适应集成。具体而言，本论文定义了对抗比来评估代理模型之间对整体对抗目标的贡献差异，然后利用对抗比自适应地调节梯度融合，为生成地对抗样本中可迁移信息地放大提供更多的努力。</p><p>而且，集成梯度可能与代理模型的个体梯度存在较大差异甚至对立，这已经被证明与集成中的过拟合问题存在相关性。因此，我们进一步引入了一个视差降低滤波器(DRF)，通过计算视差图来降低代理模型之间的差异并同步更新方向。</p><p>最后，通过应用上述两种机制，可以增强对抗攻击的可迁移性。称之为AdaEA。</p><p>本论文的贡献：</p><ul><li>提出一种自适应集成对抗攻击，成为AdaEA，为具有广泛结构差异的模型提供了更全面的集成攻击，如CNNs和ViTs。</li><li>AdaEA从梯度优化的角度看待集成攻击，通过AGM策略控制优化过程，并通过DRF减小视差以同步优化方向。</li><li>与现有的集成方法相比，所提出的AdaEA不仅可以显著提高集成效果，而且与现有的基于迁移的梯度攻击相结合，可以持续地提高攻击性能。</li></ul><h1 id="方法">方法</h1><h2 id="简述">简述</h2><p>提高对抗样本地可迁移性旨在使从白盒代理模型生成地对抗样本保持对抗，从而抵制黑盒模型。通常，使用基于梯度地方法迭代寻找白盒模型的对抗扰动可以由下式给出：</p><p><span class="math inline">\(x_{t+1}^{adv}=x_t^{adv}+\alphasign(\nabla_{x_t^{adv}}\mathcal{L}(f(x_t^{adv}),y))\)</span>，(1)</p><p>其中：</p><ul><li><span class="math inline">\(sign(\cdot)\)</span>是符号函数</li><li><span class="math inline">\(\alpha\)</span>是步长</li><li><span class="math inline">\(\nabla_{x_t^{adv}}\mathcal{L}\)</span>是损失函数关于<span class="math inline">\(x_t^{adv}\)</span>的梯度</li></ul><p>直观上，在白盒环境下由于<span class="math inline">\(\nabla_{x_t^{adv}}\mathcal{L}\)</span>是已知的，可以达到很高的攻击成功率，然而黑盒环境由于梯度位置，不同模型的梯度不同，攻击成功率会下降。</p><p>为了使生成的对抗样本对广泛类别的模型具有对抗性，集成攻击时增强攻击可迁移性的有效策略，其基本思想是利用多个白盒模型的输出得到平均模型损失，然后应用基于梯度的攻击生成对抗样本，将式(1)变化可得：</p><p><span class="math inline">\(x_{t+1}^{adv}=x_t^{adv}+\alphasign(\nabla_{x_t^{adv}}\mathcal{L}(\sum\limits_{k=1}^Kw_kf_k(x_t^{adv}),y))\)</span>，(2)</p><p>其中：<span class="math inline">\(w_k\)</span>为第<span class="math inline">\(k\)</span>个代理模型<span class="math inline">\(f_k\)</span>的集合权重，<span class="math inline">\(∀w_k≥0\)</span>且<span class="math inline">\(\sum\limits_{k=1}^Kw_k=1\)</span>，<span class="math inline">\(K\)</span>为代理模型个数</p><p>现有的集成方法一般通过平均提带模型的logits、预测概率或loss来获得用于生成梯度信息的集成loss。然而，这种简单的集成忽略了代理模型之间的个体方差，从而显著限制了整体的攻击性能。</p><h2 id="自适应集成对抗攻击adaea">自适应集成对抗攻击AdaEA</h2><p>重点研究遵循公式(2)的集合方法。与以往工作直接对代理模型的输出进行平均不同，本论文提出了配备AGM和DRF机制的AdaEA来修正梯度优化过程，以提高生成对抗样本中的可传递信息。具体来说，AGM首先通过定义的对抗比来调节每个集成模型的梯度，该对抗比识别每个代理模型对整体对抗对象的贡献差异，然后DRF通过过滤掉集成梯度中的视差部分来进一步同步梯度更新方向。AdaEA概述如图：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140711153.png" alt="图3，AdaEA概述，将CNNs和ViTs得到的梯度输入到AGM和DRF中得到集成梯度，用于生成基于梯度攻击的对抗样本"></p><h3 id="自适应梯度调制">自适应梯度调制</h3><p>在通过输入图像得到每个代理模型<span class="math inline">\(f_i(x)\)</span>和梯度信息<span class="math inline">\(g_i=\nabla_{x_t^{adv}}\mathcal{L}(f_i(x_t^{adv}),y)\)</span>后，通过提出检测其对对抗攻击目标贡献的差异来自适应地调节模型集成。</p><p>具体来说，对于第<span class="math inline">\(i\)</span>个集成模型<span class="math inline">\(f_i\)</span>，通过测试由<span class="math inline">\(g_i\)</span>生成的对抗样本对其他模型的攻击性能来评估<span class="math inline">\(g_i\)</span>中潜在的对抗可迁移性，将其定义为对抗比，然后根据每个模型的对抗比来调整集成权重。这里首先通过计算来进行测试过程：</p><p><span class="math inline">\(s_{k,i}=-\mathbf{1}_y\cdot \log(\text{softmax}(\mathbf{p}_k[x_t^{adv}+\alphasign(g_i)]))\)</span>，(3)</p><p>其中：</p><ul><li><span class="math inline">\(\mathbf{p}_k(\cdot)\)</span>表示从<span class="math inline">\(f_k\)</span>输出的logits值，<span class="math inline">\(\mathbf 1_y\)</span>是真实logits值</li><li><span class="math inline">\(s_{k,i}\)</span>是在使用来自第<span class="math inline">\(i\)</span>个模型的梯度生成的对抗样本上的第<span class="math inline">\(k\)</span>个模型los</li></ul><p>定义对抗比<span class="math inline">\(ρ_i\)</span>：</p><p><span class="math inline">\(ρ_i=\frac{\beta}{K-1}\sum\limits_{k=1,k≠i}^K\frac{s_{k,i}}{s_{k,k}}\)</span>，(4)</p><p>其中<span class="math inline">\(\beta\)</span>为控制集合加权效果的超参数。</p><p>值得注意的是<span class="math inline">\(ρ_i\)</span>的值越大，表示从<span class="math inline">\(g_i\)</span>生成的对抗样本的迁移攻击越好，意味着<span class="math inline">\(g_i\)</span>包含了更多可迁移的对抗信息。通过此可以弄清楚哪些模型可以提供更多的通用对抗信息，并自适应地分配更高地集成权重。</p><p>因此，根据每个模型的对抗比，我们使用softmax函数对每个模型的集成权重进行归一化：</p><p><span class="math inline">\(w_1^*,w_2^*,...,w_K^*=\text{softmax}(ρ_1,ρ_2,...,ρ_K)\)</span>，(5)</p><p>利用得到的<span class="math inline">\(w_i^*\)</span>，每个具有更多潜在对抗可迁移性信息的代理模型的输出在方程(2)的集成梯度中被放大，从而导致在黑盒模型上有更高的转移攻击成功率。</p><h3 id="视差降低滤波器drf">视差降低滤波器DRF</h3><p>代理模型的梯度优化方向在很大范围内变化，有时梯度会朝着相反的方向前进，结果导致对集成模型的过度拟合。为了解决这个问题并同步更新方向，额外引入减少视差的滤波器来减少代理模型之间的梯度方差。</p><p>首先用余弦相速度来评估代理模型中梯度的偏差，并通过将相似度得分与其他模型的梯度求平均来计算视差图<span class="math inline">\(d_i\)</span>：</p><p><span class="math inline">\(d_i^{(p,q)}=\frac1{K-1}\sum\limits_{k=1,k≠1}^K\cos(\vec{g}_i^{(p,q)},\vec{g}_k^{(p,q)})\)</span>，(6)</p><p>其中：</p><ul><li><span class="math inline">\(\cos(\cdot)\)</span>表示余弦相似度函数</li><li><span class="math inline">\(\vec{g}_i^{(p,q)}、\vec{g}_k^{(p,q)}\)</span>分别表示通过梯度<span class="math inline">\(g_i\)</span>和<span class="math inline">\(g_k\)</span>通道从位置<span class="math inline">\((p,q)\)</span>提取的向量</li></ul><p>通过对所有的<span class="math inline">\(d_i\)</span>求平均得到最终的集成梯度视差图<span class="math inline">\(d\)</span>。</p><p>然后，我们通过使用一个滤波器<span class="math inline">\(\mathbf{B}\)</span>来清理集合梯度中的视差部分：</p><p><span class="math inline">\(\mathbfB(p,q)=\begin{cases}0,&amp;\text{if}\ d_i^{(p,q)}≤η\\1,&amp;\text{otherwise}\end{cases}\)</span>，(7)</p><p>其中<span class="math inline">\(η\)</span>为视差滤波的容差阈值。</p><p>通过滤除集合梯度中的视差部分，可以实现梯度优化方向的同步。为此，可以通过改写公式(2)得到集合梯度：</p><p><span class="math inline">\(g_{t+1}=\nabla_{x_t^{adv}}\mathcal{L}(\sum\limits_{k=1}^Kw_k^*f_k(x_t^{adv}),y)\otimes\mathbf{B}\)</span>，(8)</p><p>其中<span class="math inline">\(\otimes\)</span>表示按元素相乘。</p><p>因此，代理模型之间的差异可以被抑制。</p><p>AdaEA整体流程如算法1所示：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140725007.png"></p><h1 id="实验">实验</h1><h2 id="参数设置">参数设置</h2><p>对于baselines和AdaEA：</p><ul><li>使用<span class="math inline">\(l_∞-norm\)</span>下迭代<span class="math inline">\(20\)</span>次的I-FGSM作为基本攻击方法，并在对抗样本生成过程中设置：<ul><li>最大扰动<span class="math inline">\(\epsilon=8/255\)</span></li><li>步长<span class="math inline">\(\alpha=2/255\)</span></li></ul></li><li>超参数:<ul><li>在DRF中取视差滤波容差阈值<span class="math inline">\(η=-0.3\)</span></li><li>在AGM中取控制集成加权效果超参数<span class="math inline">\(\beta=10\)</span></li></ul></li></ul><h2 id="主要结果">主要结果</h2><h3 id="一般攻击性能">一般攻击性能</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140735168.png" alt="表1，针对8个自然训练模型的黑盒攻击成功率。加粗表示最好结果，\triangle表示相对于baseline的改进"></p><h3 id="与基于迁移的攻击的结合">与基于迁移的攻击的结合</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140746178.png" alt="表2，基于不同攻击方法的集成攻击在CIFAR10上生成对抗样本的攻击成功率。"></p><h3 id="对先进防御的攻击">对先进防御的攻击</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140757873.png" alt="表3，在CIFAR-10上对抗3中对抗训练模型和6种高级防御方法的鲁棒性准确率。基于输入转换的防御结果是所有目标模型的平均结果。"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140920507.png" alt="图4，代理模型和黑盒模型中不同输入的热力图。(a)为输入图像，包括干净图像和每种攻击方法生成的对抗样本。(b)-(e)分别为代理模型(Res-18、ViT-T)和黑盒模型(WRN50-2、Swin-T)"></p><p>从图4(b)和(c)中可以观察到，与干净图像相比，白盒模型在所有生成的对抗样本上的注意力都发生了变化，这表明生成的对抗样本可以有效触发这些模型的错误预测。然而，当转移到黑盒模型时，Ens和SVRE方法无法误导热土与干净图像相似的模型注意力，如图4(d)-(e)中第2-3行所示。相比之下，得益于AdaEA中AGM-DRF方案对潜在内在对抗信息的放大，生成的对抗样本仍然能够欺骗图4(d)-(e)中注意力剧烈变化的黑河模型的注意力。</p><h3 id="消融实验">消融实验</h3><ol type="1"><li><p>关于AdaEA组成部分。检验AdaEA中AGM和DRF机制的有效性。具体来说执行了四种集成方法：</p><ul><li>朴素集成攻击</li><li>集成AGM</li><li>集成DRF</li><li>AdaEA在黑盒攻击中同时涉及AGM和DRF</li></ul><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140935708.png" alt="表4，AdaEA组件中的消融的平均攻击成功率实验结果"></p></li><li><p>关于超参数敏感性。研究AdaEA对方程(4)中权重尺度<span class="math inline">\(\beta\)</span>和公式(7)中的二值化阈值<span class="math inline">\(η\)</span>的敏感性。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815140957005.png" alt="图5，AGM中加权尺度\beta和(b)DRF中二值化阈值η的消融研究"></p></li></ol><h3 id="进一步分析">进一步分析</h3><ol type="1"><li><p>代理模型的数量对可迁移性有何影响？</p><p>从表5可以看出，随着代理模型的数量增加，整体攻击成功率从第1行到最底层逐行提高。直观上，由于可以捕获更多的对抗信息，使用更多的代理模型可以导致更好的可迁移性。更重要的是，AdaEA在不考虑集成模型数量的情况下，始终如一地提高了集成攻击性能。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230815141016503.png" alt="表5，在CIFAR-10上比较不同集合模型下集成攻击与本文AdaEA的平均攻击成功率。"></p></li><li><p>代理模型中不同的CNNs与ViTs的比例如何影响整体的可迁移性？</p><p>由表5第二行、第三行、第九行，随着代理模型中CNN数量的增加，对CNN的攻击率明显提高，相比之下对ViTs的攻击成功率不高。这表明当CNNs在代理模型中站主导地位时，集成梯度更侧重于CNNs的梯度。</p><p>当CNNs与ViTs比例变为0：3时，集成攻击仍然表现出对CNNs的高转移率。这一现象表明，从与CNNs转移到ViTs相比，从ViTs转移到CNNs更容易发生攻击，我们将其归因于VITs更复杂的框架和全局建模能力，使得ViTs能够提取更多通用的对抗信息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]侵蚀攻击：利用侵蚀改善对抗样本可迁移性-ErosionAtt</title>
      <link href="/article/f58040c6/"/>
      <url>/article/f58040c6/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="https://ieeexplore.ieee.org/document/10102830/">[10.1109/TIP.2023.3251719] Erosion Attack: Harnessing Corruption To Improve Adversarial Examples</a></p><p>日期：2023-04</p><p>关键词：Adversarial Attack, Optimization, Computational modeling, Perturbation methods, Neural networks, Training, Closed box, Data models</p><p>出处：IEEE Trans. on Image Process.</p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本论文提出了一种新颖的可迁移对抗攻击，突出其安全局限性。</p><p>本论文确定了当前攻击可能失败的两个内在原因，并提出对应的解决方法：</p><ul><li>数据依赖：提出了数据侵蚀(Data Erosion)方法。其涉及到寻找在简单原始模型(vanilla models)和防御模型中共有的相似性为，以帮助攻击者以更高的机会欺骗鲁棒模型</li><li>网络过拟合：克服网络过拟合困境：将单一的代理模型扩展到具有高度多样性的集成结构，从而产生更多课前一的对抗样本</li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122243802.png" alt="图1，将正常训练模型与鲁棒模型的梯度显著图和注意力区域进行对比"></p><p>利用现成的代理模型生成对抗样本来欺骗远程黑盒模型是一种更具威胁性的方式，即可迁移对抗攻击。</p><p>当前可迁移攻击方法在防御场景中效果较差的两个重要原因：</p><ul><li>数据依赖：对抗样本与输入数据高度相关，如果输入数据是干净图像，防御模型通常与正常训练的模型表现不同，如图1(a)所示。这可能会简介影响对抗样本的可迁移性，因为大多数方法只考虑干净图像并在正常训练的模型上进行优化。——大多数对抗样本可以很好迁移到其他vanilla models而不能攻击防御模型：为此而寻找一种共有的相似特征的特殊增强源，如梯度注意区域；通过在攻击过程中融入上述增强数据，对抗样本对原始数据的依赖程度降低，从而产生更高的可迁移性来欺骗黑盒防御。</li><li>网络过拟合：降低对抗样本与代理模型之间的耦合性是一种自然选择。集成攻击：在优化过程中采用多个网络，以减少对单个模型的依赖。本论文提出的EA方法为了克服集成攻击的物理限制和特征级攻击由于池化等特定网络组件而丢失有价值信息的弱点，通过利用中间特征，对抗样本从不同的决策边界中学习，将单个模型拓展到损坏的网络，以低成本实现集成攻击。</li></ul><p>数据侵蚀可以看成一种产生良好样本的数据增强技术，网络侵蚀通过构建多样化的集成来实现模型增强。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>设计一个鲁棒通用的可迁移攻击框架来欺骗不同的防御模型，并揭示当前模型的潜在不安全性。</p><ul><li>数据侵蚀方法：人工损坏的图像不仅表现出与干净图像不同的梯度显著性和热图，而且在vallina模型和防御模型之间表现出更小的差异。因此将这些侵蚀图像作为良好的增强数据加入到攻击中来更新扰动。</li><li>网络侵蚀方法：大多数基于梯度的攻击只考虑最终的预测分布来计算梯度，忽略了一些前向传播操作造成的有价值的特征丢失，为了学习各种分类边界并以较小的代价收集丰富的中间表示信息，简单修改现有模型的结构来创建一个损坏的网络用以实现集成化，以避免网络的过拟合。</li></ul><h2 id="数据侵蚀"><a href="#数据侵蚀" class="headerlink" title="数据侵蚀"></a>数据侵蚀</h2><p>在优化中对图像进行侵蚀以产生侵蚀增强数据，作为新的攻击目标函数：</p><p>$\arg\max\limits<em>{x’}{J(x’,y)+\sum\limits</em>{i=1}^nJ(x_{e_i}’,y)}$，(1)</p><p>其中：</p><ul><li>$x_{e_i}’$是侵蚀图像，由每一步侵蚀当前$x$产生的</li><li>$n$是采样数</li><li>$L<em>∞-norm$，即$||x-x’||</em>∞&lt;\epsilon$</li></ul><p>实验发现，性能最好的增强数据是由随机破坏输入图像像素连续性的空间侵蚀策略产生。除此之外的颜色侵蚀和亮度侵蚀较差。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122328720.png" alt="图2，使用IncResNetv2对最终提取的隐藏特征进行t-SNE可视化。对于干净图像，人工损坏的图像时从原理干净图像的区分分布中绘制出来的"></p><h3 id="空间侵蚀"><a href="#空间侵蚀" class="headerlink" title="空间侵蚀"></a>空间侵蚀</h3><p>如果图像中出现的额相邻像素的空间连续性已经破坏，正常的训练模型可能会改变其判别区域，更多关注结构和一般特征而不是局部细节，类似于鲁棒模型行为。这启发我们破坏当前图像$x’$的空间连续性来采样侵蚀数据$x’_e$：</p><p>$x’_e=M\cdot x’,\ M\sim Bernulli(1-ξ)$，(2)</p><p>其中：</p><ul><li>$M$是在每次迭代中随机生成的二进制掩码</li><li>$ξ$是一个预定义的概率以控制侵蚀水平；若$ξ=0$，则没有像素被破坏，若$ξ=1$，则所有元素值被破坏为0.</li></ul><p>空间侵蚀类似于对输入数据应用dropout操作，区别在于空间侵蚀没有将剩余的像素放大$1/(1-ξ)$</p><h3 id="色彩侵蚀"><a href="#色彩侵蚀" class="headerlink" title="色彩侵蚀"></a>色彩侵蚀</h3><p>彩色损毁图像具有与空间损毁数据类似的性质。通过随即线性组合基本彩色图像生成侵蚀图像：</p><p>$x<em>e’=\alpha_1\cdot x’<em>{gb}+\alpha_2\cdot x’</em>{rg}+\alpha_e\cdot x’</em>{rb}$，(3)</p><p>其中：</p><ul><li>$x’<em>{gb},x’</em>{rg},x’<em>{rb}$（即如：$x’</em>{gb}$保持g和b而破坏r）为对抗样本$x’$的基本彩色图像</li><li>$\hat{\alpha}_i$为取自均匀分布$U(0,1)$的正权重$\alpha_i=\hat{\alpha}_i/\sum_j\hat{\alpha}_j$</li></ul><h3 id="亮度侵蚀"><a href="#亮度侵蚀" class="headerlink" title="亮度侵蚀"></a>亮度侵蚀</h3><p>首先将输入图像从RGB换到YUV空间，然后对Y(亮度)和V(饱和度)通道中的分量进行随机扰动： $x_e’=\gamma_1\cdot x_y’+\gamma_2\cdot x’_v,\ \gamma_i\sim\mathcal{N}(I,\sigma_e^2)$，(3)</p><p>其中：</p><ul><li>$x_y’,x_u’,x_v’$表示基本亮度图像（即如：$x_y’$从$x’$保留Y通道的分量）</li></ul><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>以往的方法在攻击中也是用增强，与本论文的主要差别：</p><ol><li>其采用增广来避免局部极大值，而本论文的增广数据是用来缩小正常模型和防御模型之间的差距</li><li>其选择保持损失的变换来保持图像细节和实现模型增强，而本论文不属于这种类型操作，而是迫使模型通过侵蚀像素来关注一般特征。</li></ol><h2 id="网络侵蚀"><a href="#网络侵蚀" class="headerlink" title="网络侵蚀"></a>网络侵蚀</h2><p>为了通过利用中间特征来学习不同的决策边界，我们攻击原始网络即破坏其损坏版本的和集成，以较小代价生成更具威胁性的对抗样本如图3(a)。目标函数为：</p><p>$\arg\max\limits_{x’}={J(x’,y)+J_e(x’,y)}$，(4)</p><p>其中$J_e$为已构建的侵蚀网络的目标函数。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122352740.png" alt="图3，网络侵蚀机理。(a)通过攻击原始网络（顶层）和损坏的网络（底层）的集合生成对抗样本；(b)损坏的网络的两个基本设计：中间特征分类器，被设计为直接连接特征图$f_l$和一个微调块$f&#39;_c(top)$；以及随即层，他们密集地嵌入在卷积块之前（底部）"></p><p>如图3(b)所示，原始网络与损坏网络的主要区别在于：</p><ol><li>通过少量的微调开销，破坏了原始模型的结构，构建了一个具有不同边界的中间特征分类器</li><li>在卷积块钱加入随即层，进一步提高模型的多样性和鲁棒性</li></ol><h3 id="中间特征分类器"><a href="#中间特征分类器" class="headerlink" title="中间特征分类器"></a>中间特征分类器</h3><p>假设被攻击对象有一部分图像可以被代理模型正确标记，即使这些图像不属于代理网络和黑盒网络的训练集，也是合理的。为此我们旨在用较小的代价提取这些图像的表示，用于微调中间特征分类器（IFC）。特别的，对于给定图像$x$，我们可以从一个代理模型$f$得到它在第$l$层的预测标签$y$和中间特征$z_l$，即$y=f(x),\ z_l=f_l(x)$，因此，利用标准交叉熵损失(CE)在校的替代数据集$\mathcal D’$上训练特征分类头$f’_e$：</p><p>$\begin{split}J_{CE}(x,\theta’)=\mathbb{E}<em>{x\sim\mathcal{D}’}[-y^T\log f_c’(z_l)]\ =\mathbb{E}</em>{x\sim\mathcal{D}’}[-f(x)^T\log f_c’(f_l(x))]\end{split}$，(5)</p><p>其中$f’_c$是IFC的微调块，与白盒模型$f$的分类头$f_c$具有相同结构。</p><p>直觉上IFC的结构可以看作是特定的中间层微调后的分类块之间建立跳跃链接， 而跳跃的层已经“损坏”而无法工作</p><h3 id="随机层"><a href="#随机层" class="headerlink" title="随机层"></a>随机层</h3><p>在整个网络的每个卷积块之前嵌入随机层，是的当前图像通过层时，特征具有多样性，这使得在保持高分类精度的同时，输出概率的多样性变大。设计了三个不同的随机层：</p><ul><li><p>随机缩放层。在训练阶段，直接在图层中加入高斯噪声以提高训练模型的鲁棒性。提出将特征在小范围内进行缩放：</p><p>$z_{l+1}=g_l^\mathfrak{r}(z_l)=s\cdot z_l,\ s\sim\mathcal{N}(I,\sigma^2)$，(6)</p><p>其中：</p><ul><li>$g_l^\mathfrak{r}$是第$l$层的随机缩放操作</li><li>$z_l+1$是下一层的特征图</li><li>$s$是从$x_l$的同一维空间中采样的向量</li><li>$\sigma=0.025$</li></ul></li><li><p>特征平滑层。扰动在像素级较小，在特征空间逐渐增大，即噪声随着图像在网络中传播而被激活。引入高斯核对特征进行平滑，提高待攻击模型的鲁棒性：</p><p>$z_{l+1}=g_l^\mathfrak{f}(z_l)=W_d*z_l$，(7)</p><p>其中：</p><ul><li>$g_l^\mathfrak{f}(\cdot)$表示特征平滑操作</li><li>$W_d$是核为$3\times 3$大小的归一化高斯滤波器，用于实现与特征图$z_l$的卷积操作</li></ul></li><li><p>级联组层。将提出的两个层集成到单个模块中：</p><p>$z_{l+1}=g_l^\mathfrak{s}(z_l)=g_l^\mathfrak{r}\circ g_l^\mathfrak{f}(z_l)$，(8)</p><p>其中定义符号$\circ$为复合函数，即：$g_l^\mathfrak{r}\circ g_l^\mathfrak{f}(z_l))$</p></li></ul><h3 id="EA框架"><a href="#EA框架" class="headerlink" title="EA框架"></a>EA框架</h3><p>数据服饰引入了不同注意力区域的良好增强，以缓解数据依赖效应。网络侵蚀产生了具有多样化决策边界的损坏网路，以防止网络过拟合效应。将之结合到一个通用框架中，进一步增强对抗攻击的可迁移性。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122500769.png" alt></p><p>当前的可迁移攻击可以自然地集成到所提出的侵蚀攻击框架中，以生成更强的对抗样本。如EA-TIM的集成版本只需要更新算法中的第10行：</p><p>$g=W*\nabla_x\tilde{J}$，(9)</p><p>同理于DIM、SIM组合版本生成EA-DIM和EA-SIM。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li>归一化像素中最大扰动$\epsilon=0.05$</li><li>总迭代次数$T=10$</li><li>步长$\alpha=0.005$</li><li>对于baseline，动量衰减$\mu=1.0$<ul><li>DIM的转换概率$p=0.7$</li><li>TIM的高斯核大小为$11\times11$</li><li>SIM的缩放图像数量$m=4$</li><li>SGM的跳跃衰减$\gamma=0.2$</li><li>VT的方差调整$\beta=1.5，N=20$</li><li>LAFEAT使用其提出的DLR损失结合倒数第二个训练的logits层</li><li>FIA为Incv3、Incv4、IncRev2和Rev50分别选择了最优层，即$Mixed_5、Mixed_6f、Conv_4a、block2_unit6$</li></ul></li></ul><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122515205.png" alt="图5，数据侵蚀方法分析。(a)不同类型的增强图像在鲁棒性增强后的Inc3-ens3和正常训练的IR2之间跨攻击迭代的梯度相似性；(b)不同类型的增强图像子四种正常训练模型上的平均交叉熵值"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122531470.png" alt="图6，平均成对$\mathbf{JSD}(\times10^{-2})$值，在整个ImageNet验证数据集上计算真唱训练的模型和损坏模型之间的JSD，值越高，多样性越大"></p><p>图(6)的含义：</p><ul><li>原始模型IR2与其损坏版本之间的差异较大，甚至可以与其它vanilla模型(I3,R50)媲美</li><li>中间特征分类器和嵌入随机层的网络之间也表现出显著的差异性</li><li>级联组层在大多数情况下比随机缩放和特征平滑能给模型带来更大的多样性，可能会影响可迁移性的性能</li></ul><h3 id="单一模型攻击实验"><a href="#单一模型攻击实验" class="headerlink" title="单一模型攻击实验"></a>单一模型攻击实验</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122548527.png" alt="表1，单一性能实验"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122602623.png" alt="表2，组合性能的跨网络实验"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122619495.png" alt="表3，最大扰动0.05下使用baselines和EA组合攻击的成功率"></p><h3 id="集成模型攻击实验"><a href="#集成模型攻击实验" class="headerlink" title="集成模型攻击实验"></a>集成模型攻击实验</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122632044.png" alt="表4，最大扰动0.05下使用baselines和EA的集成模型攻击成功率"></p><p>证实了该方法可以利用少量现有网络，以较低的微调成本来提高模型多样性，而不是简单巡礼那不同架构的新模型，并将其应用于标准的集成攻击来达到这一目的。</p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122642908.png" alt="图9，空间侵蚀对I3和IR2的消融研究。即使是一小部分像素被损坏，其可迁移性也得到了明显的提升"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122700586.png" alt="图10，增强数据对五个防御模型的消融实验。增强图像越多，性能越好"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122714419.png" alt="图11，中间特征分类器IFC最优层的消融实验。针对两个对抗模型I3ens3和R2ens，在I3和IR2上设计了对抗样本，我们将基线DIM*、TIM和SIM的成功率绘制为虚线，中间特征分类器优化后的性能绘制为实线。可以看出将IFC应用到集合优化中，可迁移性得到显著改善。此外，对于给定的代理模型，不同攻击方法下的可迁移性变化趋势相似。"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122731708.png" alt="图12，不同比例级联组层的成功率。一般而言，更多的随机层会导致更好的性能，不管是攻击方法还是攻击代理模型"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230814122745635.png" alt="表6，网络侵蚀的成功率。包括包含中间特征分类器或随机层的集成的成功率，包括随即缩放RS、特征平滑FS和级联组CG"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]基于平均梯度的对抗攻击-I-FAGSM</title>
      <link href="/article/4c9ebfef/"/>
      <url>/article/4c9ebfef/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="https://ieeexplore.ieee.org/document/10065458/">Average gradient-based adversarial attack</a></p><p>日期：2023-03</p><p>关键词：Adversarial Attack， black-box attack, dynamic set of daversarial examples</p><p>出处：IEEE Trans. Multimedia</p></blockquote><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本文提出了一种新的基于平均梯度的对抗攻击。在我们提出的方法中，通过利用过去每次迭代的梯度，在每次迭代中首先构建一个动态的对抗样本集，然后根据损失函数关于所构造的动态集和当前对抗样本中所有样本的梯度，可以计算出平均梯度，用于确定所添加的扰动。</p><p>与现有的对抗攻击不同，所提出的基于平均梯度的攻击通过一个动态的对抗样本集来优化添加的扰动，其中动态集的大小随着迭代次数的增加而增加。该方法具有良好的可扩展性，可以集成到大多数现有的基于梯度的攻击中。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现有的数据增强策略大多是通过使用一些数字图像处理技术对输入样本进行转换来实现的，可以很容易地引入到上述基于梯度的攻击中。</p><p>基于平均梯度的攻击可以看作是基于高级梯度计算的攻击和基于数据增强的对抗攻击的结合。</p><p>首先，我们在基于梯度的对抗攻击中引入一个新的平均梯度项，它可以帮助稳定扰动的更新方向，避免陷入交叉的局部最优。</p><p>其次，不同于现有的数据增强策略，使用经典的数字图像处理奇数对输入样本进行变换，我们提出的方法使用过去迭代中获得的平均梯度对输入样本进行变换，从而形成对抗空间来增强算法的泛化能力。</p><p>贡献：</p><ul><li>通过充分利用过去迭代中的梯度信息，在当前迭代中构建一个动态的对抗样本集，可以看作是一种新的数据增强策略。</li><li>通过结合损失函数关于动态集合中所有样本和当前对抗样本的梯度，可以计算出平均梯度项，可视为一种新的高级梯度计算策略。</li><li>所提出的平均梯度项具有良好的可扩展性，可以很容易地集成到大多数现有的基于梯度的攻击中，形成一系列新的强大的攻击，而不需要引入任何新的超参数。</li><li>本论文所提出的基于平均梯度的攻击能够取得较高的攻击成功率，生成的对抗样本表现出良好的可移植性。</li></ul><h1 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h1><h2 id="提出方案"><a href="#提出方案" class="headerlink" title="提出方案"></a>提出方案</h2><p>设$x$为原始样本，$y$为与$x$相关的标签，$T$为迭代次数，$α$为小步长，$x_T^{adv}$为获得的对抗样本。$x_T^{adv}$是在原算例$x$（即$x_0^{adv}$）的基础上加入扰动后得到的。</p><p>改进梯度和数据增强是提高对抗样本可迁移性的两种主要策略。所提攻击可视为基于高级梯度计算的攻击的组合。在本论文的方案中，在每次迭代中首先构造一个动态的对抗样本集，这些样本实际上与输入样本非常相似，并用作数据增强样本。</p><p>然后，将损失函数关于当前示例和动态集中示例的平均梯度作为新的高级梯度项应用到我们的算法中。不失一般性，我们假设当前迭代为第$t$次迭代，待生成的动态集合用$S_t$表示。</p><h3 id="定义1-对抗样本的动态集合"><a href="#定义1-对抗样本的动态集合" class="headerlink" title="定义1. 对抗样本的动态集合"></a>定义1. 对抗样本的动态集合</h3><p>动态的对抗实例集$S_t={\tilde{x}^{adv}_t[0],\tilde{x},\tilde{x}^{adv}_t[1],…,\tilde{x}^{adv}_t[t-1]}$由$t$个临时对抗&gt;样本组成，由下式计算：</p><ul><li><p>$\tilde{x}^{adv}<em>t[i]=x^{adv}</em>{t-1}+α·\frac{\bar{A_i}}{||\bar{A_i}||_1}$，(1)</p><ul><li>$\tilde{x}^{adv}_{t-1}$是在$(t-1)$次迭代中得到的对抗样本</li></ul></li><li>$\tilde{A_i}$是在第$i$次$(0≤i≤t-1)$次迭代中得到的平均梯度</li></ul><p>如式(1)所示，对对抗样本${x}^{adv}_{t-1}$添加归一化平均梯度$\frac{\bar{A_i}}{||\bar{A_i}||_1}(0≤i≤t-1)$，可以得到由$t$个临时样本组成的动态集合$S_t={\tilde{x}^{adv}_t[0],\tilde{x},\tilde{x}^{adv}_t[1],…,\tilde{x}^{adv}_t[t-1]}$。通过充分利用过去每次迭代的梯度来构造对抗样本的动态集合，可视为一种新的数据增强策略。每次迭代生成的对抗样本的动态集合如图：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813223906192.png" alt="每次迭代中生成的对抗样本和对抗样本的动态集合"></p><p>其中对抗样本（包括原始输入样本$x^{adv}<em>0$），一些中间样本${x^{adv}_1，x^{adv}_2，…x^{adv}</em>{T-1}}$和最终样本$x^{adv}<em>T$和动态集（包括$S_0,S_1,…,S</em>{T-1}$）分别包括在绿色虚线和紫色虚线框中。可以观察到在初级阶段（$t=0$），动态集$S_0=\emptyset$，在第$t$次迭代中，动态集$S_t$中有$t$个临时对抗样本。</p><h3 id="定义2-平均梯度"><a href="#定义2-平均梯度" class="headerlink" title="定义2. 平均梯度"></a>定义2. 平均梯度</h3><p>如前所述，在第$t$次迭代中，存在$(t+1)$个对抗样本，即当前样本$x^{adv}<em>t$和其他$t$个临时样本$\tilde{x}^{adv}_t[0],\tilde{x},\tilde{x}^{adv}_t[1],…,\tilde{x}^{adv}_t[t-1]$。损失函数关于当前示例$x^{adv}_t$和临时示例$\tilde x^{adv}_t<a href="0\leq i \leq t-1">i</a>$的梯度分别用$\nabla</em>{x^{adv}_t}L(x^{adv}_t,y)$和$\nabla*{\tilde x^{adv}_t}L(\tilde x^{adv}_t,y)$表示。</p><p>第$t$次迭代的平均梯度$\bar A_t$计算为下式：</p><p>$\bar A<em>t=\begin{cases}\nabla</em>{x<em>0^{adv}}L(x_0^{adv},y)&amp;\text{t=0}\ \frac{1}{t+1}[\nabla</em>{x<em>t^{adv}}L(x^{adv}<em>t,y)+\sum \limits</em>{i=0}^{t-1}\nabla</em>{\tilde x_t^{adv}[i]}L(\tilde x_t^{adv}[i],y)] &amp;\text{t≥1}\end{cases}$，(2)</p><p>在第1次迭代（$t=0$）中，由于没有临时对抗样本，且动态集合$S0=\emptyset$，因此平均梯度$\tilde{A<em>0}$等于$\nabla</em>{x_0^{adv}}L(x^{adv}_0,y)$。如式(2)，随着迭代次数$T$的增加，越来越多的例子被考虑到计算平均梯度$A_t$。在实际应用中，融合更多示例的梯度一般可以提高泛化性。</p><p>对于如何在第$t$次迭代中获得对抗样本$x_{t+1}^{adv}$，由下式得出：</p><p>$g_{t+1}=\mu·g_t+\frac{\bar A_t}{||\bar A_t||_t}$，(3)</p><p>$x^{adv}_{t+1}=Clip^\epsilon_x {x^{adv}<em>t+α·sign(g</em>{t+1})}$，(4)</p><p>其中$g<em>0=0$，$\bar A_t$为第$t$次迭代得到的平均梯度，$g_t$为迭代$t$时归一化平均梯度的累加，$μ$为衰减因子。在本论文方法中，首先对平均梯度$A_t$进行归一化，然后结合累加梯度$g_t$来更新梯度$g</em>{t+1}$，如式(3)所示。最后，根据梯度$g<em>{t+1}$可以生成式(14)所示的对抗样本$x^{adv}</em>{t+1}$。可以看出，在本方案中，增加的扰动主要由归一化平均梯度的累加决定，这可以被认为时一种新的高级梯度计算策略。</p><h3 id="MI-FAGSM算法"><a href="#MI-FAGSM算法" class="headerlink" title="MI-FAGSM算法"></a>MI-FAGSM算法</h3><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813223937572.png" alt="Untitled"></p><p>如图所示，在第$t$次迭代中生成$t$个临时样本，总共需要生成$\sum \limits<em>{i=0}^{T-1}i$个临时样本才能得到最终的对抗样本$x_T^{adv}$，除了计算损失函数关于$T$个对抗样本（即$x^{adv}_0，x^{adv}_1，…，x^{adv}</em>{T-1}$）的梯度外，还需要计算损失函数关于$\sum\limits<em>{i=0}^{T-1}i$个临时样本的梯度。因此，生成对抗样本$x_T^{adv}$的梯度计算总数为$\sum \limits</em>{i=1}^Ti$。一般而言，在基于梯度的攻击中，梯度计算次数是衡量攻击算法时间复杂度的主要因素。</p><h2 id="延展性"><a href="#延展性" class="headerlink" title="延展性"></a>延展性</h2><p>与MI-FGSM相比，我们提出的方法将当前梯度$\nabla_{x^{adv}_t}L(x_t^{adv},y)$替换为平均梯度$\bar A_t$。</p><blockquote><p>MI-FGSM：$g<em>{t+1}=\mu·g_t+\frac{\nabla</em>{x^{adv}_t}L(x^{adv}_t,y)}{||\nabla L(x^{adv}_t,y)||_1}$</p><p>MI-FAGSM：$g_{t+1}=\mu·g_t+\frac{\bar A_t}{||\bar A_t||_1}$</p></blockquote><p>提出的平均梯度项可以很容易地引入到基于梯度的对抗攻击中，即在MI-FGSM、NI-FGSM、PI-FGSM引入平均梯度项，得到MI-FAGSM、NI-FAGSM、PI-FAGSM。</p><p>本算法中引入的平均梯度项不需要任何新的超参数，因而得到的方法（MI-FAGSM等）可以与现有的一些数据增强策略（如DIM、TIM、SIM等）相结合，得到一系列新的强大的对抗攻击。或者将这三种数据增强策略一起引入MI-FAGSM中，则可以得到一种更强大的对抗攻击，称为SI-TI-DIMI-FAGSM，其算法如下：</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813224209785.png" alt></p><p>其中：</p><ul><li>$g_x,g_s,g_a$：3个中间变量</li><li>$p$：DIM中的转换概率</li><li>$W$：TIM中高斯核的大小</li><li>$m$：SIM中的尺度拷贝数</li><li>$T(x;p)$：表示$x$以概率$p$随机变换</li><li>$g=W*g$：表示梯度$g$与核矩阵$W$卷积</li><li>$S_j(x)=x/2^j$：表示尺度因子为$1/2^j$的输入图像$x$的尺度拷贝，$j$取值范围为$0\sim(m-1)$，$m$表示尺度拷贝数</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li>最大扰动$\epsilon=16$</li><li>迭代次数$T=10$</li><li>步长$\alpha=\epsilon/T=1.6$</li><li>衰减因子$\mu=1.0$</li><li>对于数据增强策略：<ul><li>DIM转换概率设置为$0.5$</li><li>TIM核矩阵设置为$15\times 15$的高斯核</li><li>SIM的尺度拷贝数设置为$3$</li></ul></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813224249925.png" alt="表1，对抗样本对七个模型的攻击成功率，*表示白盒攻击"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813224308542.png" alt="表2，Inc-V3生成对抗样本攻击成功率"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813224320880.png" alt="表3&amp;4，inc-v3生成对抗样本对7个模型和10个先进防御模型攻击成功率"></p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813224334288.png" alt="表5&amp;6，模型集合生成对抗样本攻击成功率"></p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>本方法在每次迭代中都会产生一系列的临时样本，用以计算损失函数关于所有临时样本的梯度。引入平均梯度项会增加方法的时间复杂度。</p><p><img src="https://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230813224350327.png" alt="图3， 每次迭代生成10000个对抗样本的运行时间。"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]并行矩形翻转攻击PRFA-针对目标检测的基于查询的黑盒攻击</title>
      <link href="/article/14bdc2a2/"/>
      <url>/article/14bdc2a2/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="http://arxiv.org/abs/2201.08970">[2201.08970] Parallel Rectangle Flip Attack: A Query-based Black-box Attack against Object Detection(arCiv.rog)</a></p><p>日期：2022-01</p><p>关键词：Adversarial Attack</p><p>出处：CVPR 2022</p></blockquote><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>首先，目标检测在对对抗样本的脆弱性尚未得到充分的研究，特别是在黑盒攻击的实际场景下，攻击者只能访问被攻击模型返回的预测矩形框和top1分数的查询反馈。与针对图像分类的黑盒攻击相比，黑盒攻击对检测的挑战主要有两点。首先，即使一个边界框被成功攻击，也可能在被攻击边界框附近检测到另一个次优边界框。</p><p>其次，存在多个包围盒，导致攻击代价非常高。</p><p>为了应对这些挑战，本论文提出了一种基于随机搜索的并行矩形翻转攻击（PRFA）。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230808120728021.png" alt="图1. 本论文使用坐标轴来展示目标检测中对抗攻击的分类。与白盒攻击和迁移攻击不同，PRFA仅依靠预测框和NMS后的top1分数输出进行无梯度的查询攻击。PRFA还可以同时攻击无锚和基于锚的模型"></p><p>本论文：</p><ul><li><p>在每个矩形块中产生扰动，以避免在攻击区域附近进行次优检测。</p><p>首先随机搜索一个矩形块，并生成符号沿垂直或水平方向反转的对抗性扰动，以呈现该攻击块中的任何检测，包括任何次优方案。</p></li><li><p>利用白盒攻击下对抗扰动主要集中在物体轮廓和临界点附近的特点，缩小攻击矩形的搜索空间，提高攻击效率。</p></li><li><p>开发了一种同时攻击多个矩形的并行机制，进一步加速了攻击过程。</p></li></ul><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="对象检测"><a href="#对象检测" class="headerlink" title="对象检测"></a>对象检测</h2><p>主流的目标检测器大度基于深度神经网络DNNs，大致可以分为基于锚点和无锚点两类：</p><ul><li>基于锚点的检测器将预定义的滑动窗口分为正样本或负样本，然后对预测框进行细化和分类。由于回归的形式不同，又可以细分为一阶段检测器和两阶段检测器。</li><li>无锚点的检测器舍弃了锚点，直接在对象中心预测边界框。由于无锚点的检测器不需要额外的参数调整，这类检测器得到了广泛的普及。</li></ul><p>现有的针对目标检测任务的对抗攻击主要是白盒攻击。</p><h2 id="图像分类的黑盒攻击"><a href="#图像分类的黑盒攻击" class="headerlink" title="图像分类的黑盒攻击"></a>图像分类的黑盒攻击</h2><p>黑盒攻击包括基于传输的攻击和基于查询的攻击，攻击者通过访问模型的输出和修饰改性干净图像来获取对抗样本，采用可迁移的攻击策略，可以训练一个替代模型替代目标模型得到对抗梯度。</p><p>与图像分类不同，目标检测的优化问题是复杂的。假设$d$表示一幅图像的像素个数，每个候选区域由两个像素/坐标决定，目标检测的复杂度为$O(d^2)$，分类的复杂度为$O(d)$。检测器的输出为NMS后的预测框和top-1得分，使得对目标检测的黑盒攻击更像是一个介于基于得分和基于决策之间的中间设置。如何利用有限的信息和对检测器的查询实现有效的攻击是我们的研究重点。</p><h1 id="并行矩形翻转攻击"><a href="#并行矩形翻转攻击" class="headerlink" title="并行矩形翻转攻击"></a>并行矩形翻转攻击</h1><h2 id="界定问题"><a href="#界定问题" class="headerlink" title="界定问题"></a>界定问题</h2><p>假设一副原始图像$x$有$M$个识别对象$O={o_1,o_2…,o_M}$，对于每一个对象$O_m$，$m=1,2,…,M$，用真实边界框$g_m$和类标$y_m\in{1,2,…,Y}$标记，其中$Y$为类的个数。目标检测器$f(x)\in R^{N\times(4+1)}$预测预测框$b_n$，$n=1,2,…,N$和top-1标签$c_n$，$n=1,2,…,N$，$N$个目标的得分$f_C$（对预测标签$C$进行softmax归一化后的概率）</p><p>生成对抗样本$\hat{x}\in[0,1]^d$，对于原始图像$x$，将其视为$l_p-norm$$=\epsilon$的对抗样本，即$||\hat{x}-x||_p&lt;\epsilon$，目标是使所有预测框和真实框的IoU小于某个阈值或预测框的标签被错误分类，即$\forall n\in N,\ \forall m\in M,\ (IoU(b_n,g_m)&lt;threshold)\vee(c_n≠y_m)$。其中，IoU分数是目标检测的标准性能指标，即$\mathsf{IoU}(a,b)=(a\cap b)/(a\cup b)$，检测任务的阈值设为$0.5$。</p><p>寻找$\hat{x}$的任务可以表述为求解下面的优化函数：</p><p>$\begin{split} \arg\min<em>{\hat{ x}∈[0,1]^d} H(f (\hat{ x}), B, Y ) = \sum \limits</em>{ n=1}^N\sum \limits ^ M  <em>{m=1} [IoU(b_n, g_m) · \mathbb{1}</em>{f<em>{c_n} ≥ζ} +\ λ · (f</em>{c<em>n} − \max \limits</em>{ C ≠y_m} f_C ) · \mathbb{1}<em>{f</em>{c_n} &lt;ζ} ],\  s.t. ||\hat{ x} − x||<em>p ≤\epsilon  , f</em>{c_n} = f_C (\hat x, b_n)\end{split}$，(1)</p><p>其中：</p><ul><li>$\mathbb{1}$表示指示函数。如果$a$为帧，则$\mathbb{1}_a=1$，否则为0。</li></ul><p>由于攻击满足等式中的一个条件。式(1)中，我们可以使用top1分数$f_{c_n}$作为判断优化公式之一。具体来说当top-1分数大于阈值$ζ$时，我们考虑降低相应预测框和真实值的IoU，当小于其时，我们优化top1分数。</p><p>本论文提出了一种基于类别的优化函数，将预测框和真实值在同一类别下进行优化，并将计算复杂度设置为$O(M*N/|Y|)$。由于检测数据集的类别太多，这样会大大提高一次查询的速度。$(N|y)$表示标号为$y$的对象的索引集合，即$(N|y)={i|c_i=y,i=1,2,…,N}$。新的优化函数$H$如下：</p><p>$\begin{split}\arg\min \limits<em>{\hat{x}∈[ 0 , 1]^d} \sum \limits</em>{y = 1}^Y\sum \limits^{ ( N | y )}<em>{n = 1 }\sum \limits^{( M | y )}</em>{m = 1}[ IoU( b<em>n , gm) · \mathbb{1}<em>{f</em>{c_n}≥ζ} + \ λ · ( f</em>{c<em>n = y} ( \hat{x} , b_n )-\max\limits</em>{ C≠ y} f_C ) · \mathbb{1}<em>{f</em>{c_n} &lt; ζ}],\ s.t. || \hat{x}-x || <em>p≤\epsilon,\ f</em>{c_n} = f_C( \hat{ x} , b_n )\end{split}$ ，(2)</p><h2 id="Priors-amp-Objectness"><a href="#Priors-amp-Objectness" class="headerlink" title="Priors&amp;Objectness"></a>Priors&amp;Objectness</h2><p>本论文利用检测器的先验信息和白盒攻击下的先验观测来减少随机搜索空间。</p><p>虽然基于锚点和无锚点的模型在锚点上有着本质不同，但是都考虑了预测的客观性。Objectness（对象度？）本质上是一个对象在感兴趣区域中存在的概率的度量。如果对象度较高，则意味着图像窗口可能包含一个对象。我们攻击的是具有高对象度的区域而不是整幅图像。</p><p>此外本论文使用DAG和UEA方法来观察对抗扰动在不同模型上的分布。尽管攻击手段和目标模型不同，但扰动的分布都集中在目标的关键区域或轮廓上。</p><p>本论文使用预测框或先验信息计算一个高对象度的区域，并在该区域进行随即搜索。本论文通过随机抽样产生矩形扰动优化方程(2)，该扰动在位置分布上与白盒比较接近。</p><p>三种计算对象度的方法：</p><ul><li>基于锚点的先验（Mask-RCNN的分割结果）</li><li>无锚点的先验（关键点表示来自RepPoints）</li><li>预测框（探测器的输出）</li></ul><h2 id="并行攻击加速广度搜索"><a href="#并行攻击加速广度搜索" class="headerlink" title="并行攻击加速广度搜索"></a>并行攻击加速广度搜索</h2><p>基于Square Attack，随着查询次数的增加，产生的对抗扰动逐渐聚集在对象周围。这一现象表明，在等式(2)的约束下，黑盒攻击方法可以在大量查询中发现易受攻击的像素，可以在一个查询中并行攻击多个位置，从而间接增加像素搜索次数，可以作为一种加速广度搜索的方法。</p><p>从理论上分析，每个查询$q$仅在一个随机位置生成对抗扰动$δ$并非最佳选择，假设优化后的检测器$f$为平滑度，且具有Lipschitz梯度，则存在常数$L$满足：</p><p>$f(x_{q+1})-f(x_q)≤\langle f’(x_q),δ\rangle+\frac L2||δ||^2$，(3)</p><p>随机梯度是无偏且方差有界的，其上界为常数$δ^2$。</p><p>SquareAttack方法满足：</p><p>$\frac1Q\sum\limits<em>{q=0}^Q\mathbb{E}[||f’(x_q)||^2]\lesssim\frac{f(x_0)-\mathbb{E}[f(x</em>{Q+1})]}{Q_\gamma}+\gamma L \sigma^2$，(4)</p><p>其中：</p><ul><li>$\gamma$为补偿，当$\gamma=\frac{1}{L+\sigma\sqrt{QL}}$时，收敛速度为$O(1/\sqrt{Q})$</li><li>$\lesssim$意思是小且等于一个常数因子</li></ul><p>式(4)意味着迭代次数$Q$足够大，随机搜索算法将收敛。</p><p>本论文提出了一种在图像上的并行随机搜索。每次迭代$q$可以随机采样搜索空间$D$中的$P$个位置，降低了梯度估计$\mathbb E[||g^P(x)-f’(x)||^2]≤(\frac{D-P}{D-1})\frac{\sigma^2}{P}$的方差，加速了算法的收敛，此时收敛性可以表示为：</p><p>$\frac1Q\sum\limits^Q_{q=0}\mathbb E[||f’(x_q)||^2]\lesssim\frac L Q+\frac{\sqrt{L}\sigma}{\sqrt{Q}P}$，(5)</p><p>式(5)中的查询$Q$对算法收敛性的影响仍然比并行攻击次数$P$更显著，收敛速度比式(4)快$O(1/\sqrt QP)$。</p><p>由于查询的前期迭代次数较少，样本数$P$最大，随着迭代次数的增加，逐渐减小$P$的值直到$1$。</p><h2 id="针对深度搜索的矩形翻转攻击"><a href="#针对深度搜索的矩形翻转攻击" class="headerlink" title="针对深度搜索的矩形翻转攻击"></a>针对深度搜索的矩形翻转攻击</h2><p>一般而言，检测数据集中用矩形框标记的对象具有固定的尺寸和尺度。检测器使用固定比例的预定义锚点是一种典型的先验。</p><blockquote><p>例如，Faster-RCNN采用1:1、1:2、2:1的锚点设置，YOLO通过k-mwans聚类从训练集中学习不同的锚点</p></blockquote><p>实验观察可知，给定一个边界框内的一个区域，相对于用相似的噪声进行扰动，用不同的噪声对不同的子区域进行扰动更有可能导致该区域被分别检测到不同的边界框。</p><p>此外，如图3所示，矩形框往往覆盖了一个物体的局部区域，水平或垂直反转符号可以提高扰动的多样性。因此，该区域更容易被误检为不同的包围框，导致该对象上的原始包围框发生变化。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230808121150937.png" alt="图3，翻转扰动符号的过程。我们通过翻转符号的方式迫使具有相同特征的点不同，这样会导致检测器将其分离从而实现有效的攻击。"></p><p>给定一个$\epsilon$约束的初始矩形$\delta\in\mathbb{R}^{a\times a}$和一个卷积滤波器$w\in\mathbb{R}^{k\times k}$。令$z=F((x<em>p+\delta)<em>w)$表示CNN的输出来更新$\delta$，其中$F$表示激活函数，$x_p$表示原始补丁（干净补丁）。$(m,n)$表示对抗补丁$\hat{x}</em>p$的坐标。将$(m,n)$划分为$|Y|+1$个团${T_i}*{i=0}^{|Y|+1}$，且$(u,v )\in T_i$表示第$i$个团中某一点的坐标。$\alpha$为大于0的常数。$z$的最大变化$l</em>∞-norm$表示为：</p><p>$\begin{split}| | z | |<em>∞= \max\limits</em>{ m，n }| z<em>m，n |\ = \max\limits</em>{ m，n }| F ( \sum\limits^k<em>{i , j = 1} ( x_p + δ)<em>{m-\lfloor \frac s 2 \rfloor + i，n-\lfloor \frac s 2 \rfloor + j} · w</em>{i，j} ) |\≤\max\limits</em>{ m，n} | F ( \sum\limits ^k<em>{ i , j = 1}δ</em>{m-\lfloor\frac s2\rfloor + i , n-\lfloor \frac s2 \rfloor + j} · w_{i , j}) + α |\end{split}$，(6)</p><p>对于目标检测中的对抗攻击，一个补丁中包含的目标的正确标签$y$的最大变化分量应该小于其他类的最大变化分量。补丁$\hat{x}_p$中的优化函数$H$可表示为：</p><p>$\begin{split}\min\limits<em>\delta H\approx\min\limits</em>\delta[\sum\limits<em>{(u,v)\in T_y}^{T_y}max|F(\sum\limits</em>{i,j=1}^k\delta<em>{u:,v:}\cdot w</em>{i,j})+\alpha<em>y|\-max\sum\limits</em>{l≠y}^{|Y|}[\sum\limits<em>{(u,v)\in T_i}^{T_i}max|F(\sum\limits^k</em>{i,j=1}\delta<em>l\cdot w</em>{i,j})+\alpha_l|]]\end{split}$，(7)</p><p>其中$\delta<em>{u:,v:}$是式(6)中的简写。同时，由于若两个点位于同一个框区，属于同一个团，那么他们的扰动应该是相同的，即$(u_1,v_1)\in T_l$$(u_2,v_2)\in T_l$，那么$\delta</em>{u<em>1:,v_1:}=\delta</em>{u_2:,v_2:}$，因而使用近似。</p><p>当扰动在每个点上符号正确且一致时，团$T_y$的变化值最大。由于我们攻击的关键区域包含对象$y$，因此标记位$T_y$的团占据主导地位，使得式(1)最小化。式(7)中，我们可以最小化上项的界限。补丁中属于同一框区的点在空间位置（value接近）和语义特征（性质接近）上高度相似。因此，如果扰动项的符号能够改变一个点的语义特征，那么对于其他概率较大的点也是有效的。因此可以通过翻转符号来产生一个矩形扰动，使得同一个团中的点是不一致的，并将他们推到不同的分类边界，由此最小化方程。</p><h2 id="对抗样本的生成"><a href="#对抗样本的生成" class="headerlink" title="对抗样本的生成"></a>对抗样本的生成</h2><ol><li>利用Prior&amp;Objectness章节中的方法获取中检测器的先验信息，以计算高对象度的区域，确定临界点进行随机搜索。</li><li>根据动态调度算法设定了方形扰动的边长$a$和并行点数$P$。</li><li>首先为每次迭代生成边长$a$的方形扰动，接着将方形扰动的一半（$a*a/2$的矩形）的符号垂直或水平翻转。</li><li>通过式(2)计算分数，若当前得分大于最优分数，则更新对抗扰动。</li></ol><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ol><li><p>检测数据集</p><p>MS-COCO的前100张图像作为黑盒攻击的干净图像，这些样本包含丰富的对象实例，如小对象或稠密对象。</p></li><li><p>评价标准AP</p><p>不同召回率下的平均检测准确率，我们通常以特定类别的方式（如平均AP、mAP）对其进行评估。我们采用MS-COCO提供的评价标准，例如：</p><ul><li>$mAP$（在0.5~0.95之间的多个IoU阈值上取平均值）</li><li>$mAP_{50}$（IoU=0.5的平均AP）</li><li>$mAP_{75}$（IoU=0.75的平均AP）</li><li>$mAP_5$（面积&lt;322）</li><li>$mAP_M$（322&lt;面积&lt;962）</li><li>$mAP_L$（面积&gt;962）</li></ul><p>一个有效的黑盒攻击意味着一个小的$mAP$。在算法效率方面，我们使用$AQ$（平均查询）来评估算法的收敛性。我们希望尽可能减少查询次数。</p></li><li><p>目标模型</p><p>选取4个具有代表性的检测器作为目标模型：</p><p>基于锚：</p><ul><li>以ResNet50网络为骨架的两级检测器Faster-RCNN</li><li>DarkNet53为骨架的YOLOv3模型</li></ul><p>无锚：</p><ul><li>以ResNet50为骨架的FCOS</li><li>可以自适应选择正负样本的检测器ATSS（可以消除基于锚顶啊和无锚点算法的性能差异）</li></ul></li><li><p>参数设置</p><p>给定大小$w<em>h$的图像，长度为$a$的方形的长度为$\sqrt{e</em>w*h}$，$e\in [0,1]$</p><ul><li>$e$$=0.05$，在查询$q\in{20,100,400,1000,2000,4000,8000}$时$e$减半</li><li>初始阶段并行$P=4$，在查询$q\in{20,100,1000,2000}$时减半</li><li>式(2)中$ζ=0.90$，$\epsilon=0.50$</li><li>IoU阈值为$0.50$</li></ul></li></ol><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><p>通过攻击性能（如$mAP$的降低）和查询来评估。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230808121226876.png" alt="图4，$mAP$改变了针对不同攻击的查询次数。FPRA实现了最快的收敛和最有效的攻击"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230808121242125.png" alt="表1，Faster-RCNN模型的消融实验"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230808121252344.png" alt="表2，对检测器的非针对性攻击"></p><h2 id="黑盒攻击的可迁移性"><a href="#黑盒攻击的可迁移性" class="headerlink" title="黑盒攻击的可迁移性"></a>黑盒攻击的可迁移性</h2><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230808121303688.png" alt="表3，不同检测器之间的黑盒可迁移性。具有*表示的结果表示白盒。"></p><p>可知，Faster-RCNN、ATSS和FCOS三个模型的攻击效果是稳健的，因为其能够抵御来自其他数据集的攻击。</p><p>其中，最稳健的方法是ATSS，在其他数据集上达到了至少0.30$mAP$的效果。</p><p>YOLO是最容易被攻击的模型，其他模型生成的对抗样本可以有效攻击他，甚至超过自身生成的对抗样本。</p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]SiblingAttack-针对面部识别的可迁移对抗攻击的再思考</title>
      <link href="/article/33812311/"/>
      <url>/article/33812311/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="http://arxiv.org/abs/2303.12512">[2303.12512]Sibling-Attack: Rethinking Transferable Adversarial Attacks against Face Recognition</a></p><p>日期：2023-03</p><p>出处：CVPR 2023</p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>由于目标人脸识别（FR）模型的黑盒性质。</p><p>提出一种新的FR攻击技术SiblingAttack，首次探索了一种新颖的多任务视角（即，利用多相关任务的额外信息来提高攻击的可迁移性）。</p><ul><li>直觉上，SiblingAttack选取一组与FR相关的任务，并基于理论和定量分析选取属性识别AR任务作为SiblingAttack中使用的任务。</li><li>SiblingAttack开发了一个融合对抗梯度信息的优化框架，通过：<ul><li>将跨任务特征约束在同一空间下</li><li>增强任务间梯度兼容性的联合任务元优化（Joint-Task Meta Optimization，JTMO）框架</li><li>减轻攻击过程中震荡效应的跨任务梯度稳定（Cross-Task Gradient Stabilization，CTGS）方法。</li></ul></li></ul><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>基于深度神经网络DNNs的人脸识别FR模型可能受到对抗攻击。在实际攻击场景中，被攻击FR模型的参数对于攻击者是黑盒的。</p><p>一种可行的黑盒策略是通过攻击一个白盒代理模型来构造可迁移对抗样本。</p><p>在人脸识别任务上，最近的研究（optimization-based metgods、model-ensmble training、input data transformations）显示了提高攻击可迁移性的有效性。本质上，这些方法通过融合来自集成模型的辅助梯度信息或各种采样/增强策略来防止对抗样本对单个模型/图像的过拟合。然而，他们对online commerical FR的系统是相当悲观的。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ol><li><p>对于针对FR任务的可迁移对抗攻击：</p><ul><li>Adv-Face使用基于GAN的框架来解决过拟合问题。</li><li>DFANet使用dropout层来提高攻击的可迁移性。</li><li>使用基于补丁的方法研究针对FR系统的可迁移物理攻击：Adv-Glases和Adv-Hat通过注入补丁帽子或眼睛进行物理对抗攻击</li><li>生成特定化妆和面部属性的不可感知的扰动</li></ul></li><li><p>多任务学习</p><p>与单任务学习（STl）相比，多任务学习（MTL）是同时学习多个任务，以提高每个任务的准确率。现有的一些工作已经证明了FR和AR人物之间的强相关性。研究表明，FR模型在表示中隐含编码潜在的属性特征，FR模型的隐含层可用于进行属性预测。AR任务的模型可以学习到更鲁棒的特征，因此可以它用来提高FR的鲁棒性。</p><p>多任务训练可以学习到更多的对抗鲁棒特征。</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>本论文认为，现有的方法仅从单个任务中手记的对抗梯度，从而忽略了进一步提高可迁移性的潜在可能性。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727104903136.png" alt="图1，在单一任务下，先前的攻击(a)通过攻击多个模型或使用各种菜养活增强策略来提高可迁移性。然而，在提出的SiblingAttack（图1(b)）中，我们采用属性识别(Attribute Recognition, AR)作为辅助任务来提高可迁移性。其中利用硬参数共享架构作为攻击骨干。"></p><ul><li><p>多任务学习（MTL）方法指出，在相关任务之间进行多任务或来拟合任务训练，可以学习到更加鲁棒和通用的特征，从而提高整体的泛化能力。本论文寻求在跨任务范围内提高FR任务的攻击可迁移性。为了探究多任务环境下FR攻击的可迁移性，存在两个挑战：</p><ol><li>在执行多任务攻击时，如何确定一个合适的辅助任务作为FR任务的合适候选</li><li>如何充分利用两个任务的对抗信息，从而提高可迁移性</li></ol><p>基于这两个问题，我们假设一个与面部相关的任务，可以为目标FR任务提供相关但多样的对抗梯度信息来补充内在缺失的对抗知识，可以被认为是一个很好的辅助任务候选者，命名为sibling-task（同胞任务？）。</p></li></ul></li></ul><p>AR模型能够学习到文件的身份特征，可以用来增强FR的识别稳健性。反过来，FR特征也隐式地编码了潜在的面部属性特征。此外，我们进行了定量的结果来展示AR任务的有效性。为此，我们利用一个相关的AR任务作为sibling-task来提高攻击的可迁移性，即SiblingAttack。</p><p>由于不同任务的特征空间和梯度空间存在较大差异，如果不考虑更好的梯度融合和稳定的训练策略，直接优化FR或如AR模型将导致攻击可迁移性十分有限。在SiblingAttack中，我们首先采用应参数共享架构作为我们的骨干攻击框架，将他们限制在相同的特征空间内，如图1(b)所示。</p><p>接下来，我们基于元学习的高层理念设计了一种交替联合任务元优化（JTMO）算法，以进一步提高两个任务之间的梯度兼容性。最后，为了缓解训练震荡效应，我们提出了一种用于稳定对抗样本优化的跨任务梯度稳定（CTGS）策略。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>大量实验表明，SiblingAttack比目前最先进的FR攻击技术有非常明显的优势，在最先进的预训练FR模型和两个著名的、广泛使用的商业FR系统Face++人脸识别和Microsoft face API上，攻击成功率平均提高了12.61%和55.77%，值得注意的是，SiblingAttack在两个常用数据集上攻击广泛使用后的Face++商业人脸API的ASR分别达到了86.50%和96.10%，而目前的研究结果进分别达到了58.10%和64.30%。</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li>提出利用相关AR任务中的对抗信息来生成对抗人脸识别的高度可迁移的对抗样本</li><li>提出SiblingAttack方法，以有效的方式联合学习来自多个任务的对抗信息</li></ol><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>针对FR的靶向对抗攻击，即impersonation-attack模拟攻击，通过欺骗目标FR模型，使攻击者误认为与目标具有相同的身份。本论文主要针对Adv-makeup（ Advmakeup: A new imperceptible and transferable attack on face recognition. In Proceedings of the Thirtieth International Joint Conference on Artificial Intelligence (IJCAI), pages 1252–1258. International Joint Conferences on Artificial Intelligence Organization, 8 2021. Main Track）和针对深度人脸识别的可迁移对抗攻击（Towards transferable adversarial attack against deep face recognition. IEEE Transactions on Information Forensics and Security (TIFS), 16:1452–1466, 2020.）进行研究。伪造攻击的目标可以表述为:</p><p>$\min \limits_{\epsilon_a} \mathcal{L}(x_a + \epsilon_a, x_v), s.t. ‖\epsilon_a‖_p ≤ ξ$，(1)</p><p>其中：</p><ul><li>$x_a∈\mathcal{R}^{H·W·C}$为攻击面孔</li><li>$x_v∈\mathcal{R}^{H·W·C}$为目标被攻击面孔</li><li>对攻击者的扰动$a∈[0,1]^{H·W·C}$受到$\ell_p-norm$（$p∈{0,2,∞}$）的约束。在这项工作中，$p=∞$.</li><li>$ξ$ 是一个小的常数用来约束$\epsilon_a$</li><li>$\mathcal{L}(·)$表示对抗损失函数</li></ul><h2 id="SiblingAttack框架"><a href="#SiblingAttack框架" class="headerlink" title="SiblingAttack框架"></a>SiblingAttack框架</h2><p>如图1(b)所示，为了避免较大的特征方差，我们在SiblingAttack中采用了一种优秀的应参数共享架构作为主干。图1(b)所示的白盒代理模型记为$\mathcal{S(P;F;A)}$，其第一个部件是一个共享参数编码器$\mathcal{P}$，然后代理模型分支成两个子网络：一个FR分支$\mathcal{F}$和一个AR分支$\mathcal{A}$。给定攻击图像$x<em>a$和目标图像$x_v$，我们的目标是通过$\mathcal S$生成对抗样本$x</em>{adv}$来欺骗黑盒目标FR模型$\mathcal T$。</p><p>具体来说，对每个$x_a$和$x_v$，$\mathcal S$的每个分支分别通过$\mathcal F$和$\mathcal A$计算其对应的输出高层特征向量${f_a^{\mathcal F},f_v^{\mathcal F}}$和${f_a^{\mathcal A},f_v^{\mathcal A}}$。然后，这些特征被用于计算针对FR的目标攻击的相应对抗损失。如下所示：</p><p>$\mathcal L_{adv}^<em>=1-cos(f_a^</em>,f_v^*)$，(2)</p><p>其中：</p><p>$*∈{\mathcal{F,A}}$，我们使用两个特征向量之间的余弦值作为评价指标来衡量他们的相似性。</p><p>基于此，本文对联合仿冒攻击的主要目标函数进行了如下设计：</p><p>$\min\limits<em>{\epsilon_a}λ_1 ·\mathcal{ L^F</em>{adv} + λ<em>2 · L^A</em>{adv},\ s.t. ||\epsilon_a||_p ≤ ξ}$，(3)</p><p>其中：</p><p>$λ_1$和$λ_2$为需要进行取舍的超参数。</p><h2 id="联合任务元优化（JTMO）"><a href="#联合任务元优化（JTMO）" class="headerlink" title="联合任务元优化（JTMO）"></a>联合任务元优化（JTMO）</h2><p>对于元学习框架，交替采用梯度可以提高进行特征学习的跨数据集兼容性，交替采用梯度可以提高进行特征学习的跨数据集兼容性，从而增强可推广性。为此我们可以通过在两个任务之间获得更好的梯度兼容性来构建可迁移的对抗样本。</p><p>因此，本论文提出了一种新的针对对抗场景的优化策略，即联合任务元优化(JTMO)。如图2所示，在JTMO中，我们模仿元学习的参数更新策略，而不是直接计算两个任务的加权平均对抗损失。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105041114.png" alt="图2，SiblingAttack优化过程。第一行表示联合任务元优化（JTMO），第二行表示跨任务梯度稳定（CTGS）。每次迭代，JTMO从不同的任务中交替选择模型。CTGS通过历史信息稳定跨任务梯度。"></p><p>为了生成对抗样本，我们必须添加一个扰动$a$来迭代地修改$x<em>a$中的像素。对于每次迭代，我们从$\mathcal S$中交替选择一个分支，然后进行前向和后向传播，从相应的对抗损失$\mathcal{L</em>{adv}^{F}}$或$\mathcal {L_{adv}^{A}}$中计算梯度。分支选择的先后顺序不会影响最终的性能。对于每次迭代中的每个分支，更新后的扰动$\epsilon_a’$可以通过计算得到：</p><p>$\epsilon^′<em>a ← \prod {\epsilon_a − α · sign(γ_1 · \triangledown</em>{\epsilon<em>a} L^∗ </em>{adv}(x_a + \epsilon_a, x_v))}$，(4)</p><p>其中：</p><ul><li>$\prod{·}$表示由$\ell_∞$约束保证的投影函数</li><li>$\alpha$表示学习率</li><li>$\gamma_1$为更新超参数</li><li>$*∈{\mathcal{F,A}}$</li></ul><p>然后，我们利用更新后的扰动$\epsilon^′<em>a$计算$L^{</em>^′}_{adv}$。</p><p>最后，我们聚合所有梯度信息来更新扰动，具体为：</p><p>$\epsilon^{′′}<em>a ← \prod {\epsilon^′_a − α · sign(γ_1 · \triangledown</em>{\epsilon<em>a^′} L^{*^′}</em>{adv}(x_a^′ + \epsilon_a^′, x_v))}$，(5)</p><p>其中：</p><ul><li>$x^′_a=x_a+\epsilon_a$，$\gamma_2$为更新的超参数</li><li>$\epsilon^{′′}_a$是每次迭代的对抗扰动输出</li></ul><p>受元学习的启发，我们的优化策略首先从扰动参数的两个分支交替收集梯度，然后再每次迭代中使用梯度在两个任务之间交替优化$\epsilon^{′′}_a$，以获得优化兼容性。</p><h2 id="跨任务梯度稳定（CTGS）"><a href="#跨任务梯度稳定（CTGS）" class="headerlink" title="跨任务梯度稳定（CTGS）"></a>跨任务梯度稳定（CTGS）</h2><p>在两个人物之间更新对抗扰动，不可避免地会引起震荡的副作用，并导致次优解。这种副作用可以归因于两种不同的任务具有不同的梯度更新方向。</p><p>基于单任务对抗攻击方法中，历史梯度和适当梯度聚合可以稳定优化过程从而提高攻击的可迁移性的特性，本论文设计了一种新的更新策略，即交叉任务梯度稳定（CTGS），以进一步提高SiblingAttack的攻击可迁移性。</p><p>如图2所示，在优化过程的每一次迭代中，为选定的任务分支定义一个更新步长$N$，例如$\mathcal F$。则$N$个对抗扰动$\mathcal {E^{′F}}={\epsilon^{′\mathcal F}<em>{a1},…,\epsilon^{′\mathcal F}</em>{aN}}$可以通过连续计算公式(4)来迭代处理。接下来，我们将扰动添加到攻击图像$x<em>a$中，生成对抗样本，并将其发送到另一个任务分支$\mathcal A$中，计算其对应的梯度图$\mathcal G^{′A}={\triangledown^\mathcal  A</em>{\epsilon^{′\mathcal  F}<em>{a1}},…,\triangledown^\mathcal  A</em>{\epsilon^{′\mathcal  F}_{a_N}}}$。因此，当更新$\mathcal A$上的$\epsilon^′_a$时，我们可以在式(5)上得到方程：</p><p>$\epsilon^{′′\mathcal A}<em>a ← \prod {\epsilon^{′\mathcal F}</em>{aN} − α <em> sign[γ_2 </em>( \triangledown<em>{\epsilon</em>{aN}^{′\mathcal F}}^{\mathcal A}+\gamma<em>3\sum\limits</em>{i=1}^{N-1}\triangledown<em>{\epsilon</em>{ai}^{′\mathcal F}}^{\mathcal A})]}$，(6)</p><p>按照这个更新过程，来自$\mathcal F$的历史对抗梯度在$\mathcal A$上的计算梯度被聚合以稳定当前的优化。$\gamma_3$是一个用以平衡训练权重的超参数。由于历史对抗梯度只提供辅助梯度信息，而不主导主更新方向，因此我们选择$\gamma_3$作为较小的数值。</p><p>该策略通过利用来自另一个任务分支的历史$N-1$个对抗样本的跨任务梯度，增强了优化的稳定性，提升了可迁移性。</p><p>SiblingAttack的整体流程如算法1所示：</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105536355.png" alt="表1，SiblingAttack整体流程算法"></p><h1 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ol><li>Celeb A-HQ</li><li>LFW</li></ol><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>采用Attack Success Rate（ASR）评估。计算公式：</p><p>$\mathsf{ASR}=\frac{\text{No. of Comparisons ≥}\mathcal T}{\text{Total No. of Comparisons}}$，(7)</p><p>分子定义对抗攻击是否成功，其接受来自黑盒模型的对抗样本和两性样本在相应的阈值$\mathcal T$上的相似性分数。</p><h2 id="目标模型"><a href="#目标模型" class="headerlink" title="目标模型"></a>目标模型</h2><ol><li>离线模型：<ul><li>IR152</li><li>IRSE50</li><li>FaceNet</li><li>IR550</li><li>ResNet101</li></ul></li><li>在线模型<ul><li>Face++</li><li>Microsoft</li></ul></li></ol><p>对于离线FR模型，本论文使用IR152、IRE50和FaceNet作为白盒，生成对抗样本，并在其他模型上评估攻击的可迁移性。离线模型的所有阈值均从LFW数据集中的图像获得。</p><p>对于AR模型，本论文使用IR152和Mobileface作为骨干网络，并在MSCeleb-1M和CelebA-HQ上进行训练，以保证在AR任务上的性能。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>在SIblingAttack中，对于FR任务和AR任务，白盒代理模型的结构均为IR152.根据先前工作的实验配置，设置：</p><p>$ξ=40/255$</p><p>$\ell_∞$</p><p>$\alpha=2/255$</p><p>$T=200$</p><p>$N=4$</p><p>$(\gamma_1,\gamma_2,\gamma_3)=(0.1,0.9,0.01)$</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105554795.png" alt="表2，CelebA-HQ数据集上黑盒模拟攻击的ASR结果。两个离线模型和两个在线模型被用来评估攻击的可迁移性。SiblingAttack使用IR152 FR和IR152 AR进行白盒训练，而其他用于比较的方法则使用两种不同的FR模型进行训练。"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105646781.png" alt="表3，LFW数据集上黑盒模拟攻击的ASR结果。"></p><p>由表2表3可知，基于补丁的方法在大多数目标模型上具有较弱的可迁移性，因为其是针对攻击区域较小的物理攻击而设计和调整的。结果表明，与所有其他基于人脸的方法相比，攻击整个人脸的对抗样本即Adv-Face具有最好的可迁移性。</p><p>然而，从表2中Celeb-AHQ结果可以看出SiblingAttack仍能显著超过Adv-Face。</p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105703378.png" alt="表4，LFW数据集上模拟攻击的ASR结果对比。Ensemble代表了基于集成训练的方法。"></p><p>具体来说，SiblingAttack包含以下部分：</p><ol><li>硬参数共享(Hard P.S.)</li><li>联合任务元优化(JTMO)</li><li>跨任务梯度稳定(CTGS)</li></ol><p>在实验中，可以很好证明使用AR任务中的信息可以帮助提高针对FR任务的攻击可迁移性。此外，ASR随着每个拟议组件的添加而逐渐增加，并且显著优于其他基于单一集成训练的模型。</p><h2 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h2><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105717562.png" alt="图3，与仅针对FR模型的攻击相比，将SiblingAttack可视化对抗性扰动。每一列展示了对抗样本及其后处理的扰动。来自Face++和Microsoft的查询结果以蓝色和红色显示"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105732474.png" alt="图4，使用Grad-CAM的可视化在离线FR模型(IRSE50)上生成注意力图。我们在每张图片下的FR模型上显示攻击者与目标人脸之间的相似性分数。"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230727105745978.png" alt="图5，基于Face++和Microsoft的SiblingAttack采用不同面部属性的AR模型的ASR结果。x轴表示相似度得分。y轴表示对应相似度的分下的ASR。"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> FR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]通过对抗统计一致性规避深度伪造检测器-StatAttack</title>
      <link href="/article/58d0d04f/"/>
      <url>/article/58d0d04f/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="https://arxiv.org/abs/2304.11670">[2304.11670] Evading DeepFake Detectors via Adversarial Statistical Consistency</a></p><p>日期：2023-04-23</p><p>关键词：Adversarial Attack, DeepFake</p><p>出处：CVPR 2023</p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>深度伪造检测技术通常依赖于检测自然（真实）图像和深度伪造生成图像在<strong>空域和频域</strong>的统计差异。</p><p>本论文提出显式地最小化统计差异来规避最先进的深度伪造检测器——针对深度伪造检测器的统计一致性攻击（StatAttack）：</p><ol><li>选取几种统计敏感的<strong>自然退化（曝光度、模糊度、噪声）</strong>，并将其以对抗的方式添加到伪造图像中。</li><li>自然图像和深度伪造图像之间的统计差异与两种图像之间的分布偏移正相关，本论文提出<strong>使用感知节点分布损失来指导不同退化的优化</strong>，因此，生成的对抗样本的特征分布接近更自然图像。</li><li>将StatAttack扩展到MStat Attack，将单层退化依次扩展到多层退化，并利用损失联合调整组合权重。</li></ol><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>深度伪造检测器容易受到对抗性攻击，这些攻击可以通过向假图像中注入扰动来绕过检测器。</p><p>以往的一些研究探讨了对抗样本的可迁移性，它是针对特定受害者模型设计的对抗样本攻击为同一任务训练的其他模型的能力。</p><p>不同的数据增强和预处理方法导致的网络架构和训练样本的变化，实现针对深度伪造检测器的可迁移攻击具有挑战性，这些差异往往导致在面对不同的深度伪造检测器时，基于典型攻击方法构造的对抗样本的可迁移性较差。</p><p>StatAttack选择<strong>三种统计敏感的自然退化</strong>，包括曝光、模糊和噪声，并以对抗的方式将他们添加到假图像中。真假图像集之间的统计差异与其分布偏移正相关。</p><p>本论文提出通过最小化伪造图像和自然图像的特征分布之间的距离来缓解这些差异。通过<strong>引入一种感知节点分布损失函数</strong>，有效地最小化了统计差异。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142334613.png" alt="fig1.浅蓝色区域和浅红色区域分别表示自然/真实图像和伪造图像的其纳入空间。深蓝色区域表示不同检测器共享的真实图像的嵌入空间。第一行表明，典型的攻击可以将假样本（橙色点）映射到”真实“样本，可以欺骗检测器A，但不能误导检测器B。第二行则将假样本检测到不同检测器的公共区域，可以欺骗两个检测器。"></p><p>MStatAttack执行多层退化，并且可以在每个攻击步骤中动态调整不同层中每个退化的权重。</p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul><li>提出了一种新的基于自然退化的攻击方法StatAttack，可以通过最小化一个感知节点分布损失来填补真假图像之间的特征分布差异</li><li>提出了进一步的多层对应的MStatAttack，可以选择更有效的扰动组合并生成更自然的对抗样本</li></ul><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><h2 id="统计学差异"><a href="#统计学差异" class="headerlink" title="统计学差异"></a>统计学差异</h2><p>几种检测方法解释了自然图像和伪造图像在频域和空间域的统计差异。</p><ol><li><p>GAN网络架构和训练过程会导致GAN生成图像和自然图像之间的亮度统计差异。例如，一些GAN仅能生成强度值有限的图像，无法生成饱和和曝光不足的区域。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142420529.png" alt="fig2.亮度统计差异。(a)展示了自然人脸数据集的平均亮度直方图，(b)展示了ProGAN生成的缺乏饱和曝光不足区域的伪造人脸数据集的平均亮度直方图。(c)是与(b)部分曝光调整相同的数据集。调整局部亮度后，伪图像直方图中出现饱和和欠曝光像素值。"></p></li><li><p>自然图像和GAN生成图像在频域信息上的统计差异，揭示了高频成分的显著差异。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142904840.png" alt="fig3.频率统计差异（功率谱）。(a)表明GAN生成的图像与自然图像相比，高频成分急剧增加。(b)揭示了高斯模糊过程可以减小这些频率差异。"></p></li><li><p>通过直接观察GANs生成图像的频谱图发现了一些统计线索。他们的实验结果表明GANs不可避免地会在处理后的图像中留下规则的高频伪影。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142538712.png" alt="fig4.频率统计差异（频谱图）。(a)为真实人脸图像。(b)为经过Stargam篡改的图像，(c)为加入随机噪声的伪造图像。它们的直方图显示在每幅图像的右边。与自然图像相比，星敏图像（用红色箭头指示）的频谱图中出现了规则的频率伪影。加入噪声后，伪影图像中的高频伪影消失。"></p></li></ol><h2 id="统计一致性攻击-StatAttack"><a href="#统计一致性攻击-StatAttack" class="headerlink" title="统计一致性攻击(StatAttack)"></a>统计一致性攻击(StatAttack)</h2><h3 id="统计敏感退化"><a href="#统计敏感退化" class="headerlink" title="统计敏感退化"></a>统计敏感退化</h3><ol><li><p>退化选择</p><p>三种常见的能有效降低统计差异的自然退化：</p><ul><li>改变曝光。调整局部区域像素的亮度值可以改变伪造图像的亮度分布。如<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">fig2</a>。</li><li>添加模糊。通过高斯低通滤波器滤除伪造图像中的高频成分，可以减小频域统计差异。如<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">fig3</a>。</li><li>添加噪声。如<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">fig4</a>。通过加入随机噪声，伪造图像中的规则伪影被消除。</li></ul><p>值得注意的是，在图像中加入局部曝光不仅可以改变空间域的信息，还可以改变频率域的信息。此外，高斯滤波可以减少伪影图像中一些规则的高频伪影。</p></li><li><p>自然的曝光对抗</p><p>旨在将局部曝光注入到伪造图像中，使其亮度统计更接近自然图像。除此之外，由于自然曝光变化平滑，因此注入到伪造图像中的曝光也应该具有类似的（即图像中相邻像素具有相似的曝光值）性质。</p><p>采用对抗曝光生成模型：由用于生成曝光的多项式模型和用于保持曝光自然度的平滑公式构成。</p><ul><li>$P_e(\mathbf{X}^{fake})=log^{-1}(\tilde{\mathbf{X}}^{fake}+\tilde{\mathbf{E}})$，(1)<ul><li>$\tilde{E}$：生成曝光的多项式模型</li><li>$\mathbf{X}^{fake}$：fake image</li><li>$\tilde{\cdot}$：对数运算</li></ul></li></ul><p>为了保持曝光的自然性，对于多项式模型包含的两组参数$\mathbf{a}$和$φ$，我们通过在损失函数中加入平滑方程来约束其取值：</p><ul><li><p>$S (a, φ) = −λ<em>a ||a||_2^2−λ</em>φ||▽φ||_2^2$，(2)</p><p>超参数$λ<em>a$和$λ</em>φ$：调节对抗攻击用户平滑性之间的平衡。</p></li></ul></li><li><p>高斯模糊对抗</p><p>对于一般的高斯模糊，在图像中不同位置使用的高斯核具有相同的值。为了以对抗的方式添加高斯模糊退化，我们提出将高斯核设计为可学习的对抗核。该方法允许在图像的不同位置自适应地应用对抗扰动。</p><p>我们旨在学习一个标准差图$σ$，利用$σ_{x_i,y_i}$，计算第$i$个像素$H_i$的对抗高斯核如下：</p><ul><li>$H<em>i(u, v) = \frac{1} {2π (σ</em>{x<em>i,y_i} )^2} exp(−\frac{ u^2 + v^2}{ 2π (σ</em>{x_i,y_i} )^2})$，(3)<ul><li>$σ_{x_i,y_i}$：高斯核在第$i$个像素位置的初始标准差</li><li>$u$和$v$表示高斯核内点到中心像素$(x_i,y_i)$的相对坐标</li></ul></li></ul><p>利用对抗高斯核，对伪造图像进行模糊：</p><ul><li>$P_b(\mathbf{X}^{fake}) = \sum \limits {i∈\mathcal{N} (i)} g(\mathbf{X}^{fake} i , k) ∗ \mathbf{H}_i$，(4)<ul><li>$\mathcal{N}(i)$：$\mathbf{X}^{fake}$中所有像素</li><li>$g(\mathbf{X}^{fake},k)$：以第$i$个像素为中心，被包围在半径为$k$的高斯核内的区域</li><li>$*$：滤波操作运算符</li></ul></li></ul><p>给生成的图像$P<em>b(\mathbf{X}^{fake})$一个与对抗相关的损失函数，并通过<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">公式(4)</a>最小化它得到${σ</em>{x_i,y_i}}$和$\mathbf{H}_i$。随后，通过计算的高斯核对伪造图像施加像素级高斯模糊。</p></li><li><p>噪声对抗</p><ul><li>$P_n(\mathbf{X}^{fake}) = \mathbf{X}^{fake} + \mathbf{N}_a$，(5)<ul><li>$\mathbf{N}_a$：与$\mathbf{X}^{fake}$大小相同的对抗噪声图。</li></ul></li></ul><p>在每个攻击步骤中，我们通过最小化我们的对抗损失函数来生成对抗噪声，然后将其添加到每个fake image中。为了确保对抗噪声不会显著影响图像的质量，我们使用约束项对$\mathbf{N}_a$进行稀疏化。该约束项被纳入到最终的目标函数中。</p></li><li><p>StatAttack</p><p>将上述扰动总结如下：</p><ul><li><p>$P_θ(\mathbf{X}^{fake}) = P_n(P_b(P_e(\mathbf{X}^{fake})))$，(6)</p><p>$P_θ(\mathbf{X}^{fake})$ 包含四组待优化参数${\mathbf{a},φ,σ,\mathbf{N}_a}$</p></li></ul></li></ol><h3 id="感知节点分布统计一致性"><a href="#感知节点分布统计一致性" class="headerlink" title="感知节点分布统计一致性"></a>感知节点分布统计一致性</h3><p>给定一组真实图像和一组伪造图像，本论文研究了两个集合的统计差异与分布偏移之间的相关性，发现统计差异与两个集合之间的分布偏移正相关。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230507224035701.png" alt="fig6.统计差异与自然图像集和伪造图像集的分布偏移之间的相关性。(1)-(4)展示了两组特征分布之间的功率谱和MMD值。蓝色曲线表示GAN生成图像的高频部分，红色曲线代表自然图像的。使用不同高斯核$\sigma$的高斯模糊处理伪造图像，观察到随着高频统计差异的减小，MMD值也随之减小。"></p><p>fig6.统计差异与自然图像集和伪造图像集的分布偏移之间的相关性。(1)-(4)展示了两组特征分布之间的功率谱和MMD值。蓝色曲线表示GAN生成图像的高频部分，红色曲线代表自然图像的。使用不同高斯核$\sigma$的高斯模糊处理伪造图像，观察到随着高频统计差异的减小，MMD值也随之减小。</p><p>使用最大均值差异（MMD）来衡量过滤后的伪造图像与自然图像的特征分布之间的距离。增大$\sigma$可以降低伪造图像中的高频频谱，且MMD值随着统计差异的减小而减小。</p><ol><li><p>目标函数</p><p>若生成的对抗样本被分类为相反的类，则认为对二分类器的攻击是成功的。目标函数：</p><ul><li>$\mathop{argmin} \limits<em>{a,φ,σ,\mathbf{N}a} J{MMD}( P</em>θ (\mathcal{X}^{fake}) , \mathcal{X}^{real}) + S(\mathbf{a}, φ), \newline subject\ to\ ∥N_a∥_p ≤ \epsilon$，(7)<ul><li>$\mathcal{X}$：图像集</li><li>$J_{MMD}(\cdot)$：在某个检测器层中两个特征分布之间的MMD值。</li></ul></li></ul><p>通过目标函数计算曝光对抗、高斯模糊对抗和噪声对抗的参数。</p></li><li><p>算法</p><p>初始化3个扰动参数${\mathbf{a},φ,σ,\mathbf{N}_a}$，并将其添加到伪造图像中。接下来，在每个基于DNN的检测器模型中收集自然图像和伪造图像在全局池化层上的特征分布，并计算它们的MMD值。为了优化扰动参数，我们使用符号梯度下降来最小化<a href="https://www.notion.so/153d6722aaa84625aff399460f7d3153">方程(7)</a>。最后，将${\mathbf{a},φ,σ,\mathbf{N}_a}$的优化值应用于原始伪造图像，从而生成对抗伪造图像。</p></li></ol><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230507223500404.png" alt="fig5.攻击生成流程。首先，在伪造图像中加入初始化的对抗退化（曝光对抗、高斯模糊对抗、噪声对抗）。然后，收集自然图像和伪造图像的特征分布并计算其MMD值（最大均值差异，可被使用为损失函数）。最后，通过最小化损失函数来优化扰动参数，并将优化后的退化应用于伪造图像。"></p><h2 id="多层Stat攻击（MAtatAttack）"><a href="#多层Stat攻击（MAtatAttack）" class="headerlink" title="多层Stat攻击（MAtatAttack）"></a>多层Stat攻击（MAtatAttack）</h2><p>在图像中反复添加对抗扰动可能会提高攻击的成功率。因此我们进一步将StatAttack扩展到MStatAttack，依次将单层退化扩展到多层退化，并使用损失来联合调整组合权重。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528142650597.png" alt="fig7.MStat攻击的体系结构。在最小化目标函数时，对每种攻击模式的权重和参数进行联合优化。"></p><p>如fig7所示，MStatAttack使用多层来处理输入。在第k层，MStatAttack取第(k-1)层的输出，记为$\mathbf{X}^{fake}<em>{p</em>{k-1}}$，并行应用3种退化对抗（$e、b、n$）；然后，我们维护四个权重（$w’<em>{e_k}、w’</em>{b<em>k}、w’<em>{n_k}、w’</em>{\mathbf{X}<em>k}$）以混合$\mathbf{X}^{fake}</em>{p</em>{k-1}}$及其3个扰动版本，获取第k层的输出。为了保证四个权重之和等于1，我们将它们馈送到softmax层，得到（$w<em>{e_k}、w</em>{b<em>k}、w</em>{n<em>k}、w</em>{\mathbf{X}_k}$）。各层扰动可写作：</p><ul><li><p>$X^{fake}<em>{p_k} = w</em>{e<em>k} P_e(\mathbf{X}^{fake}<em>{ p</em>{k−1}})+w</em>{b<em>k} P_b(\mathbf{X}^{fake}</em> {p<em>{k−1}} ) + w</em>{n<em>k} P_n(\mathbf{X}^{fake}<em>{ p</em>{k−1}} ) + w</em>{\mathbf{X}<em>k} \mathbf{X}^{fake}</em>{ p_{k−1}} , n ≥ 1$，(8)</p><p>$\mathbf{X}^{fake}_{p_k}$：第k层生成的对抗样本</p></li></ul><p>在优化过程中，基于损失函数对原始权重和所有退化参数进行联合优化。sofmax层确保更新后的权重相加为1，防止图像混合过程种的强度溢出。</p><p>除了自动选择合适的攻击策略（即扰动组合）外，MStatAttack还可以通过原始伪造图像中融入更多的成分来增强生成的对抗样本。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528143148453.png" alt="空间相关性深度伪造探测器的攻击成功率和图像质量评估。在每组中，第一列表示在白盒环境下的攻击成功率，第二、三、四列是在其他深度伪造检测器上的转移攻击成功率。我们用红色、黄色和蓝色标记了第一、第二和第三高的攻击成功率。最后一列是BRISQUE评分"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230528143238345.png" alt="基于频率的深度伪造检测器的攻击成功率和图像质量评估。每组中，第1列表示白盒设置下的攻击成功率，第2列是黑盒设置下的攻击成功率。ResNet列表示由ResNet生成的对抗样本的迁移成功率。我们用红色、黄色和蓝色标记了第一、第二和第三高的攻击成功率。最后一列是BRISQUE评分"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> DeepFake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[文献阅读]基于特征重要性感知攻击的可迁移对抗攻击-FIA</title>
      <link href="/article/87c239f0/"/>
      <url>/article/87c239f0/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><blockquote><p>论文位置：<a href="https://arxiv.org/abs/2107.14185">[2107.14185] Feature Importance-aware Transferable Adversarial Attacks (arxiv.org)</a></p><p>日期：2021-07</p><p>关键词：Adversarial Attack</p><p>出处：ICCV 2021</p><p>代码仓库：<a href="https://github.com/hcguoO0/FIA">https://github.com/hcguoO0/FIA</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>深度神经网络（DNNs）容易受到对抗样本对深度神经网络的影响在研究神经网络的内部缺陷和提高其鲁棒性方面发挥着重要作用。</li><li>传统攻击方法如FGSM、BIM等制作的对抗样本往往由于对源模型的过拟合而表现出较弱的可迁移性。</li><li>现有的可迁移性的对抗性扰动直接在中间层进行攻击，没有干扰输出层，且最大化内部特征失真，以增强可迁移性；然而其通过不加区分地扭曲特征来生成对抗样本，而没有意识到图像中物体地内部特征，因此容易陷入特定于模型的局部最优。</li><li>本论文提出了一个特征重要性感知攻击的方法，通过<strong>破坏主导不同模型决策的关键对象感知特性</strong>（也就是破坏主导模型决策的一些特性），从而显著提高对抗样本的迁移性。针对特定于模型的特征，我们<strong>引入了聚合梯度</strong>，它将有效地一直特定于模型的特征，同时提供特征的对象感知重要性。</li></ul><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224326542.png" alt="Fig.1 模型注意力感知可视化图像。特征性感知攻击（下排）抑制了模型对重要特征的关注，而促进了对琐碎无关的特征的关注，从而显著散焦/误导模型。这样的对抗样本导致源模型和目标模型不仅未能捕捉到重要对象，而且还将注意力放在琐碎区域。"></p><ul><li>本论文的主要贡献：<ul><li>提出特征重要性感知攻击（Feature Importance-aware Attack，FIA），通过<strong>破坏主导不同模型决策的关键对象感知特征</strong>来增强对抗样本的可迁移性；</li><li>分析了现有工作相对较低的可性背后的基本原理，即对特定于模型的“噪声”特征的<strong>过度拟合</strong>，针对这些特征<strong>引入聚合梯度</strong>，以指导生成更多可迁移的对抗样本。</li></ul></li></ul><h1 id="特征重要性感知攻击（FIA）"><a href="#特征重要性感知攻击（FIA）" class="headerlink" title="特征重要性感知攻击（FIA）"></a>特征重要性感知攻击（FIA）</h1><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>对于一个分类模型$f<em>\theta:x\mapsto y$，其中x和y分别表示干净图像（原始图像/自然图像）和真实标签，θ表示模型的参数。我们的目标是生成一个对抗样本$x^{adv}=x+\epsilon$，以通过设计出扰动$\epsilon$来误导分类器，也即使得$f</em>\theta(x^{adv})≠y$。通常，$\ell_p-$范数用于正则化扰动。因此，对抗样本的生成可以表述为如下式的优化问题：</p><ul><li>$\large arg \mathop{max}\limits_{x^{adv}}J(x^{adv},y),s.t. ||x-x^{adv}||_p≤\epsilon$，   (1)<ul><li>其中$J(·,·)$为损失函数，测量真实标签与预测标签间的差距（即交叉熵）</li><li>$argmax\ g(t)$表达的是定义域的一个子集，且盖子集中任一元素都可使函数$g(t)$取最大值</li><li>在这项工作中$p=∞$</li></ul></li></ul><h2 id="特征重要性感知攻击概述"><a href="#特征重要性感知攻击概述" class="headerlink" title="特征重要性感知攻击概述"></a>特征重要性感知攻击概述</h2><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224535505.png" alt="Fig.2 特征重要性感知攻击概述图。给定一个输入图像，从中间层（红色示块）中提取特征图。然后计算从输出回传到特征图的梯度，作为特征重要性（Feture Importance）。将特征图和归一化梯度进行点积（Element-wise Product）后得到加权的特征图，以达到抑制积极/重要特征并促进消极/琐碎特征的目的来实现优化，获得具有更高可迁移性的对抗样本。"></p><blockquote><p><strong>特征重要性</strong></p><p>不同的网络会提取排他性特征来更好地适应数据域，这就产生了特定于模型的特征表示，因而对抗样本的生成需要由来自源模型的与模型无关的关键特征来指导，这被称为特征重要性。</p></blockquote><h2 id="基于梯度聚合的特征重要性"><a href="#基于梯度聚合的特征重要性" class="headerlink" title="基于梯度聚合的特征重要性"></a>基于梯度聚合的特征重要性</h2><p>由于特征重要性与特征对最终决策的贡献程度成正比，一个方法是通过下式计算关于$f_k(x)$的梯度来求得特征重要性：</p><ul><li>$\Large \Delta^x_k=\frac{\partial l(x,t)}{\partial f_k(x)}$，   (2)<ul><li>令$f$表示源模型，则$f_k(x)$表示来自第$k$层的特征图</li><li>$l(·,·)$表示相对于真实标签$t$的对数输出</li></ul></li></ul><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224625171.png" alt="Fig.3 VGG16的Conv3_3层的特征图和相应的梯度的可视化。其中Raw Features表示原始特征图，Raw Gradients表示原始梯度图；Aggregate Features表示经聚合之后的特征图，Aggregate Gradients表示经聚合之后的梯度图。Raw是从原始图像中获得，Aggregate是从原始图像多次变换（即随即像素下降）获得的。"></p><p>可以看出原始梯度图和原始特征图在视觉上都是有噪声的，也就是在非目标区域上存在脉冲较大的梯度，这可能时由于模型特有的解空间造成的；但经过聚合之后的特征图和梯度图就消除了这样的影响，只在目标区域存在脉冲较大的梯度。可以说，与原始梯度相比，<strong>聚合梯度更加干净、更加关注对象</strong>，在可转移的视角中提供了更好的特征重要性。</p><h3 id="聚合梯度"><a href="#聚合梯度" class="headerlink" title="聚合梯度"></a>聚合梯度</h3><p>为了抑制特定于模型的信息，本论文提出聚合梯度（aggregate gradient），聚合了来自随机变换$x$的梯度，如下图所示。</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224656060.png" alt="Fig.4 聚合梯度的图解。梯度是从多个随机掩码图像中获得的，且最终的聚合梯度（即特征重要性）由这些梯度的平均值表示。"></p><p>梯度聚合公式：</p><ul><li>$\large\bar{\Delta}<em>k^x=\frac{1}{C}\sum\limits^N</em>{n=1}\Delta^{x\odot M^n<em>{p_d}}_k,M</em>{p_d}\sim Bernoulli(1-p_d)$，   (3)<ul><li>$M_{p_d}$表示和原图x大小相同的二进制矩阵（符合服从参数为$1-p_d$的伯努利分布）</li><li>$\bigodot$表示点积</li><li>标准化数$C$是$\ell_2-$范数，用以约束聚合梯度</li><li>$N$表示应用于输入$x$的随机掩码的数量</li><li>$p_d$为下降率</li></ul></li></ul><p><strong>即首先将原图与随机掩码图像进行点积，然后将结果输入到模型中求第k层特征图的梯度，最后将这些梯度进行相加（聚合），并使用$\ell_2-$范数来做一个约束，得到聚合梯度。</strong></p><blockquote><p>$\ell_2-$范数：定义为向量所有元素的平方和的开平方</p></blockquote><p>由于语义目标感知/重要特征/梯度对上述的这个变换是鲁棒的，但是一些特定模型的梯度或者特征容易受到转换的应向，因此那些鲁棒的可迁移的特征将会在聚合后被突出显示，而其他的梯度将会被中和。</p><h3 id="攻击算法"><a href="#攻击算法" class="headerlink" title="攻击算法"></a>攻击算法</h3><p>根据上述的特征重要性（即聚合梯度$\bar\Delta_k^x$），本论文有如下损失函数公式来抑制特征重要性，以指导对抗样本$x^{adv}$的生成：</p><ul><li><p>$\large \mathcal{L}(x^{adv})=\sum(\Delta \odot f_k(x^{adv}))$，   (4)</p><blockquote><p>为了简便而将$\bar\Delta^x_k$表示为$\Delta$</p></blockquote></li></ul><p>直观而言，修正特征以靠近真实标签的重要特征在特征重要性$\Delta$中占有较高的比重，且$\Delta$的符号给修正提供了方向。<strong>生成可迁移的对抗样本的目的是减少具符号为正的$\Delta$的重要特征，增加符号为负的$\Delta$对应的重要特征。</strong>因此可通过最小化式(4)来实现。</p><p>最后，将式(1)带入到式(1)，得到最终的对抗样本生成公式：</p><p>$\large arg\mathop{min}\limits<em>{x^{adv}}\mathcal{L}(x^{adv}),\ s.t.\ ||x-x^{adv}||</em>∞≤\epsilon$，   (5)</p><p>采用MIM算法求解式(5)算法如下：</p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527224900588.png" alt="MIM算法是一种子监督表征学习方法。其主要思路是对输入图像进行分块和随机掩码操作，然后对掩码区域进行预测。"></p><p>MIM算法是一种子监督表征学习方法。其主要思路是对输入图像进行分块和随机掩码操作，然后对掩码区域进行预测。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>下降率$P_d$：在影响成功率方面起着重要作用，而且这种影响在不同的目标模型中往往是一致的。一个较大的$P_d$（例如，0.5）会破坏图像的重要结构信息，从而显著降低成功率。因此，攻击正常训练模型的最佳$P_d$在0.2和0.3之间，而攻击防御模型的最佳$P_d$应该在0.1左右。</li><li>集合数$N$：较大的$N$往往产生较高的成功率，但会逐渐饱和。</li><li>最后我们确定了集成数$N=20$，正常训练模型的下降率$P_d=0.3$，以及防御模型的$P_d=0.1$。</li><li>选择中间层：特征层k的选择对特征级攻击有很大的影响，因为DNN的早期层（early layer）可能会构建一个通常是特定于数据的基本特征集，较进一步的层可能会对这些提取的特征进行处理，以最大化模型的分类精度，使这些特征进行处理，以最大化模型的分类精度，使这些特征成为特定于模型的。因此<strong>早期层没有学习到真正类别的显著特征和语义概念</strong>，而<strong>后期层是特定于模型的，在可迁移攻击中应该避开</strong>。相比之下，<strong>中间层（middle layer）具有良好的分类表示，并且它们与模型架构的相关性不高</strong>，因此中间层是为了更好的可迁移性而被攻击的最佳选择。</li></ul><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527225123057.png" alt="对正常训练的模型进行不同攻击的成功率。第1列显示源模型，第1行列出目标模型。FIA是我们的方法，FIA + PIM是FIA和PIM的结合。&#39; * &#39;表示白盒攻击，因为目标模型是源模型，最好的结果用粗体突出显示。"></p><p><img src="http://image-host-mooliht.oss-cn-beijing.aliyuncs.com/img/image-20230527225145027.png" alt="针对防御模型的不同攻击成功率。第1列显示源模型，第1行列出目标模型。FIA是我们的方法，FIA + PITIM是FIA、PIM和TIM的结合。最好的结果以粗体突出。"></p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
          <category> 视觉分析与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对抗攻击 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机基础]ban门弄fool-一些常用的工具</title>
      <link href="/article/b0d9110f/"/>
      <url>/article/b0d9110f/</url>
      
        <content type="html"><![CDATA[<h1 id="pwndbggdb">pwndbg(GDB)</h1><h2 id="gdb简记">gdb简记</h2><h3 id="传送门">传送门</h3><p><font size="4">官网：<a href="http://www.sourceware.org/gdb/">GDB: TheGNU Project Debugger (sourceware.org)</a></font></p><p>百科：<a href="https://baike.baidu.com/item/gdb/10869514?fr=aladdin">gdb_百度百科(baidu.com)</a></p><p>教程大全：<a href="https://blog.csdn.net/kangkanglhb88008/article/details/127155083">gdb入门教程大全（清晰明了）_我是标同学的博客-CSDN博客_gdb教程</a></p><p><font size="5">声音超甜</font>的b站教程：<a href="https://www.bilibili.com/video/BV1EK411g7Li/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7f553078c1aeb5b58ec0305625bc85c8">【小神仙讲GDB】 通俗易懂版教程 | 一小时入门GDB | Debug | c/c++程序员必备 |佩雨小神仙 _哔哩哔哩_bilibili</a></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/74897601">GDB调试入门指南- 知乎 (zhihu.com)</a></p><h3 id="啥是个gdb">啥是个gdb</h3><figure><img src="/article/b0d9110f/img1.png" alt="Summary of GDB"><figcaption aria-hidden="true">Summary of GDB</figcaption></figure><p>GDB可以做四种主要的事情(加上支持这些事情的其他事情)来帮助您捕获bug:</p><p>•启动你的程序，指定任何可能影响它行为的东西。</p><p>•让你的程序在特定条件下停止。</p><p>•当你的程序停止时，检查发生了什么。</p><p>•修改程序中的内容，这样你就可以尝试纠正一个错误的影响，并继续学习另一个错误。</p><h3 id="咋配置gdb">咋配置gdb</h3><p>安装gdb并检查是否成功安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install gdb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb --version</span></span><br></pre></td></tr></table></figure><p><code>GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.</code></p><p><font size="6">装起来了</font></p><h3 id="说明">说明</h3><p>因为之前一些工作需要逆向，所以我直接下载的是<strong>pwndbg</strong>，pwndbg专门针对pwn题调试添加了额外的功能。</p><p>就是说，是个gdb的插件，用来进行逆向工程调试的。</p><p>如下是pwndbg的安装命令：</p><p><code>$ git clone https://github.com/pwndbg/pwndbg</code></p><p><code>$ cd pwndbg</code></p><p><code>$ ./setup.sh</code></p><p>当然，如果只是debug的话，gdb足够，且装了pwndbg之后进行gdb，命令没有变化，只是会在gdb基础上展示出逆向进程。</p><p>在此附说明是因为：<font size="5">下述示例中的展示皆基于pwndbg插件下的gdb。</font></p><h2 id="quickstart">quickstart</h2><p>先vim一个简单的c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译<code>gcc -g start.c</code>，通过gdb进入./a.out执行文件<code>gdb ./a.out</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g start.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb ./a.out</span></span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from ./a.out...</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span></span><br></pre></td></tr></table></figure><p>如此进入到gdb指令交互。</p><h2 id="gdb指令">gdb指令</h2><h3 id="男人一下">男人一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man gdb</span></span><br></pre></td></tr></table></figure><p>Here are some of the most frequently needed GDB commands:</p><ul><li><p><strong>break</strong> [file:]function Set a breakpoint atfunction (in file).</p></li><li><p><strong>run</strong> [arglist] Start your program (with arglist,if specified).</p></li><li><p><strong>bt</strong> Backtrace: display the programstack.</p></li><li><p><strong>print</strong> expr Display the value of anexpression.</p></li><li><p><strong>c</strong> Continue running your program (after stopping,e.g. at a breakpoint).</p></li><li><p><strong>next</strong> Execute next program line (after stopping);step over any function calls in the line.</p></li><li><p><strong>list</strong> [file:]function type the text of theprogram in the vicinity of where it is presently stopped.</p></li><li><p><strong>step</strong> Execute next program line (after stopping);step into any function calls in the line.</p></li><li><p><strong>help</strong> [name] Show information about GDB commandname, or general information about using GDB.</p></li><li><p><strong>quit</strong> Exit from GDB.</p></li></ul><h3 id="基本命令应用">基本命令应用</h3><h4 id="rrun-润">r/run: 润</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">[Inferior 1 (process 134817) exited normally]</span><br></pre></td></tr></table></figure><h4 id="bbreak-打断点">b/break: 打断点</h4><h5 id="b-函数名字"><code>b 函数名字</code></h5><p>在函数处装b（指打断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b main</span></span><br><span class="line">Breakpoint 1 at 0x555555555169: file start.c, line 3.</span><br></pre></td></tr></table></figure><h5 id="b-行号"><code>b 行号</code></h5><p>可搭配<code>list</code>指令（查看源代码），查看代码对应行数，在对应行装b</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">list</span></span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3int main()&#123;</span><br><span class="line">4int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">5for (int i=0;i&lt;4;i++)</span><br><span class="line">6&#123;</span><br><span class="line">7printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">8&#125;</span><br><span class="line">9return 0;</span><br><span class="line">10&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 7</span></span><br><span class="line">Breakpoint 2 at 0x5555555551a9: file start.c, line 7.</span><br></pre></td></tr></table></figure><h5 id="info-b-康康刚在哪装了b"><code>info b</code>:康康刚在哪装了b</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info b</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000555555555169 in main at start.c:3</span><br><span class="line">2       breakpoint     keep y   0x00005555555551a9 in main at start.c:7</span><br></pre></td></tr></table></figure><p>润一下<code>r</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start.c:3</span><br><span class="line">3int main()&#123;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────[ REGISTERS ]───────────────────────────────────────</span><br><span class="line"> RAX  0x555555555169 (main) ◂— endbr64 </span><br><span class="line"> RBX  0x5555555551f0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x5555555551f0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RDX  0x7fffffffdf68 —▸ 0x7fffffffe2e3 ◂— &#x27;SHELL=/bin/bash&#x27;</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7fffffffdf58 —▸ 0x7fffffffe2c4 ◂— &#x27;/home/Mo01iHt/Desktop/a.out&#x27;</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x7ffff7fe0d60 (_dl_fini) ◂— endbr64 </span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x7ffff7f6c7c0 (intel_02_known) ◂— 0x200000200406</span><br><span class="line"> R12  0x555555555080 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdf50 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x0</span><br><span class="line"> RSP  0x7fffffffde68 —▸ 0x7ffff7de1083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line"> RIP  0x555555555169 (main) ◂— endbr64 </span><br><span class="line">────────────────────────────────────────[ DISASM ]─────────────────────────────────────────</span><br><span class="line"> ► 0x555555555169 &lt;main&gt;       endbr64 </span><br><span class="line">   0x55555555516d &lt;main+4&gt;     push   rbp</span><br><span class="line">   0x55555555516e &lt;main+5&gt;     mov    rbp, rsp</span><br><span class="line">   0x555555555171 &lt;main+8&gt;     sub    rsp, 0x30</span><br><span class="line">   0x555555555175 &lt;main+12&gt;    mov    rax, qword ptr fs:[0x28]</span><br><span class="line">   0x55555555517e &lt;main+21&gt;    mov    qword ptr [rbp - 8], rax</span><br><span class="line">   0x555555555182 &lt;main+25&gt;    xor    eax, eax</span><br><span class="line">   0x555555555184 &lt;main+27&gt;    mov    dword ptr [rbp - 0x20], 1</span><br><span class="line">   0x55555555518b &lt;main+34&gt;    mov    dword ptr [rbp - 0x1c], 2</span><br><span class="line">   0x555555555192 &lt;main+41&gt;    mov    dword ptr [rbp - 0x18], 3</span><br><span class="line">   0x555555555199 &lt;main+48&gt;    mov    dword ptr [rbp - 0x14], 4</span><br><span class="line">─────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start.c</span><br><span class="line">   1 #include &lt;stdio.h&gt;</span><br><span class="line">   2 </span><br><span class="line"> ► 3 int main()&#123;</span><br><span class="line">   4 int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">   5 for (int i=0;i&lt;4;i++)</span><br><span class="line">   6 &#123;</span><br><span class="line">   7 printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">   8 &#125;</span><br><span class="line">─────────────────────────────────────────[ STACK ]─────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde68 —▸ 0x7ffff7de1083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line">01:0008│     0x7fffffffde70 —▸ 0x7ffff7ffc620 (_rtld_global_ro) ◂— 0x50f3c00000000</span><br><span class="line">02:0010│     0x7fffffffde78 —▸ 0x7fffffffdf58 —▸ 0x7fffffffe2c4 ◂— &#x27;/home/Mo01iHt/Desktop/a.out&#x27;</span><br><span class="line">03:0018│     0x7fffffffde80 ◂— 0x100000000</span><br><span class="line">04:0020│     0x7fffffffde88 —▸ 0x555555555169 (main) ◂— endbr64 </span><br><span class="line">05:0028│     0x7fffffffde90 —▸ 0x5555555551f0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line">06:0030│     0x7fffffffde98 ◂— 0x457649a3c538cc92</span><br><span class="line">07:0038│     0x7fffffffdea0 —▸ 0x555555555080 (_start) ◂— endbr64 </span><br><span class="line">───────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555555169 main</span><br><span class="line">   f 1   0x7ffff7de1083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="nnext-单步运行">n/next: 单步运行</h4><h4 id="pprint-打印变量值">p/print: 打印变量值</h4><p>在<strong>调试</strong>过程中打印出目标的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p arr[0]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;arr[0]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = (int *) 0x7fffffffde40</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;arr[1]</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = (int *) 0x7fffffffde44</span></span><br></pre></td></tr></table></figure><p>显然验证整型数组每个元素占1word，即4bits</p><h5 id="no-symbol-xxx-in-current-context-的解决">No symbol “xxx” incurrent context 的解决</h5><p>在进行gdb调试时（包括使用core dump文件调试），经常出现GDB No symbol“xxx” in current context问题，常见的原因如下：</p><p>使用gcc编译的时候未使用-g选项。或者加了-g选项，同时使用了-o选项。建议编译的时候使用-g选项的时候，同时使用-Og可以关闭编译优化（-O选项较低gcc版本不支持）。</p><p><font size="1"><a href="https://blog.csdn.net/sj_djw/article/details/91958035">出现GDB Nosymbol “xxx” in current context的几种原因分析_春日绿野的博客-CSDN博客_nosymbol in current context</a></font></p><h4 id="sstep-步入函数">s/step: 步入函数</h4><p>为了方便引例：<code>cp start.c start1.c</code>提醒自己要有备份文件的习惯 ~~(rm -rf /*~~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello echo~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入gdb进行debug，并在对hello()函数的引用处打断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">list</span></span><br><span class="line">11printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">12&#125;</span><br><span class="line">13hello();</span><br><span class="line">14return 0;</span><br><span class="line">15&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 13</span></span><br><span class="line">Breakpoint 1 at 0x555555555206: file start1.c, line 13.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start1.c:13</span><br><span class="line">13hello();</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────[ REGISTERS ]───────────────────────────────────────</span><br><span class="line"> RAX  0x2</span><br><span class="line"> RBX  0x555555555230 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0x7ffff7fab7e0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> RSI  0x5555555592a0 ◂— 0xa34 /* &#x27;4\n&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x2</span><br><span class="line"> R10  0x555555556012 ◂— 0x483b031b01000a /* &#x27;\n&#x27; */</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x5555555550a0 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdf50 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffde60 ◂— 0x0</span><br><span class="line"> RSP  0x7fffffffde30 —▸ 0x7ffff7fae2e8 (__exit_funcs_lock) ◂— 0x0</span><br><span class="line"> RIP  0x555555555206 (main+102) ◂— mov    eax, 0</span><br><span class="line">────────────────────────────────────────[ DISASM ]─────────────────────────────────────────</span><br><span class="line"> ► 0x555555555206 &lt;main+102&gt;           mov    eax, 0</span><br><span class="line">   0x55555555520b &lt;main+107&gt;           call   hello                &lt;hello&gt;</span><br><span class="line"> </span><br><span class="line">   0x555555555210 &lt;main+112&gt;           mov    eax, 0</span><br><span class="line">   0x555555555215 &lt;main+117&gt;           mov    rdx, qword ptr [rbp - 8]</span><br><span class="line">   0x555555555219 &lt;main+121&gt;           xor    rdx, qword ptr fs:[0x28]</span><br><span class="line">   0x555555555222 &lt;main+130&gt;           je     main+137                &lt;main+137&gt;</span><br><span class="line"> </span><br><span class="line">   0x555555555224 &lt;main+132&gt;           call   __stack_chk_fail@plt                &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x555555555229 &lt;main+137&gt;           leave  </span><br><span class="line">   0x55555555522a &lt;main+138&gt;           ret    </span><br><span class="line"> </span><br><span class="line">   0x55555555522b                      nop    dword ptr [rax + rax]</span><br><span class="line">   0x555555555230 &lt;__libc_csu_init&gt;    endbr64 </span><br><span class="line">─────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start1.c</span><br><span class="line">    8 int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    9 for (int i=0;i&lt;4;i++)</span><br><span class="line">   10 &#123;</span><br><span class="line">   11 printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">   12 &#125;</span><br><span class="line"> ► 13 hello();</span><br><span class="line">   14 return 0;</span><br><span class="line">   15 &#125;</span><br><span class="line">─────────────────────────────────────────[ STACK ]─────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde30 —▸ 0x7ffff7fae2e8 (__exit_funcs_lock) ◂— 0x0</span><br><span class="line">01:0008│     0x7fffffffde38 ◂— 0x455555230</span><br><span class="line">02:0010│     0x7fffffffde40 ◂— 0x200000001</span><br><span class="line">03:0018│     0x7fffffffde48 ◂— 0x400000003</span><br><span class="line">04:0020│     0x7fffffffde50 —▸ 0x7fffffffdf50 ◂— 0x1</span><br><span class="line">05:0028│     0x7fffffffde58 ◂— 0x8fee5fb1f1bbc000</span><br><span class="line">06:0030│ rbp 0x7fffffffde60 ◂— 0x0</span><br><span class="line">07:0038│     0x7fffffffde68 —▸ 0x7ffff7de1083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line">───────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555555206 main+102</span><br><span class="line">   f 1   0x7ffff7de1083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>一个<code>s</code>步入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">s</span></span><br><span class="line">hello () at start1.c:3</span><br><span class="line">3void hello()&#123;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────[ REGISTERS ]───────────────────────────────────────</span><br><span class="line">*RAX  0x0</span><br><span class="line"> RBX  0x555555555230 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0x7ffff7fab7e0 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> RSI  0x5555555592a0 ◂— 0xa34 /* &#x27;4\n&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x2</span><br><span class="line"> R10  0x555555556012 ◂— 0x483b031b01000a /* &#x27;\n&#x27; */</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x5555555550a0 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdf50 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffde60 ◂— 0x0</span><br><span class="line">*RSP  0x7fffffffde28 —▸ 0x555555555210 (main+112) ◂— mov    eax, 0</span><br><span class="line">*RIP  0x555555555189 (hello) ◂— endbr64 </span><br><span class="line">────────────────────────────────────────[ DISASM ]─────────────────────────────────────────</span><br><span class="line"> ► 0x555555555189 &lt;hello&gt;       endbr64 </span><br><span class="line">   0x55555555518d &lt;hello+4&gt;     push   rbp</span><br><span class="line">   0x55555555518e &lt;hello+5&gt;     mov    rbp, rsp</span><br><span class="line">   0x555555555191 &lt;hello+8&gt;     lea    rdi, [rip + 0xe6c]</span><br><span class="line">   0x555555555198 &lt;hello+15&gt;    call   puts@plt                &lt;puts@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x55555555519d &lt;hello+20&gt;    nop    </span><br><span class="line">   0x55555555519e &lt;hello+21&gt;    pop    rbp</span><br><span class="line">   0x55555555519f &lt;hello+22&gt;    ret    </span><br><span class="line"> </span><br><span class="line">   0x5555555551a0 &lt;main&gt;        endbr64 </span><br><span class="line">   0x5555555551a4 &lt;main+4&gt;      push   rbp</span><br><span class="line">   0x5555555551a5 &lt;main+5&gt;      mov    rbp, rsp</span><br><span class="line">─────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start1.c</span><br><span class="line">   1 #include &lt;stdio.h&gt;</span><br><span class="line">   2 </span><br><span class="line"> ► 3 void hello()&#123;</span><br><span class="line">   4 printf(&quot;hello echo~\n&quot;);</span><br><span class="line">   5 &#125;</span><br><span class="line">   6 </span><br><span class="line">   7 int main()&#123;</span><br><span class="line">   8 int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">─────────────────────────────────────────[ STACK ]─────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde28 —▸ 0x555555555210 (main+112) ◂— mov    eax, 0</span><br><span class="line">01:0008│     0x7fffffffde30 —▸ 0x7ffff7fae2e8 (__exit_funcs_lock) ◂— 0x0</span><br><span class="line">02:0010│     0x7fffffffde38 ◂— 0x455555230</span><br><span class="line">03:0018│     0x7fffffffde40 ◂— 0x200000001</span><br><span class="line">04:0020│     0x7fffffffde48 ◂— 0x400000003</span><br><span class="line">05:0028│     0x7fffffffde50 —▸ 0x7fffffffdf50 ◂— 0x1</span><br><span class="line">06:0030│     0x7fffffffde58 ◂— 0x8fee5fb1f1bbc000</span><br><span class="line">07:0038│ rbp 0x7fffffffde60 ◂— 0x0</span><br><span class="line">───────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555555189 hello</span><br><span class="line">   f 1   0x555555555210 main+112</span><br><span class="line">   f 2   0x7ffff7de1083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到步入到了hello()函数处</p><h4 id="ccontinue-继续执行到下一个断点">c/continue:继续执行到下一个断点</h4><p>我们可能打了多处断点，或者断点打在循环内，这个时候，想跳过这个断点，甚至跳过多次断点继续执行该怎么做呢？可以使用continue命令（可简写为c）或者fg，它会继续执行程序，直到再次遇到断点处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b main</span></span><br><span class="line">Breakpoint 1 at 0x1169: file start.c, line 3.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 7</span></span><br><span class="line">Breakpoint 2 at 0x11a9: file start.c, line 7.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start.c:3</span><br><span class="line">3int main()&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c  <span class="comment">#继续运行，直到下一次断住</span></span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at start.c:7</span><br><span class="line">7printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c 3  <span class="comment">#跳过三次</span></span></span><br><span class="line">Will ignore next 2 crossings of breakpoint 2.  Continuing.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at start.c:7</span><br><span class="line">7printf(&quot;%d\n&quot;, arr[i]);</span><br></pre></td></tr></table></figure><h4 id="uuntil-继续运行到指定位置">u/until: 继续运行到指定位置</h4><p>例如我们在main函数起始处打断停住，想要运行到第9行时再次停住，则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b main</span></span><br><span class="line">Breakpoint 1 at 0x1169: file start.c, line 3.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">until 9</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">main () at start.c:9</span><br><span class="line">9return 0;</span><br></pre></td></tr></table></figure><h2 id="gdb一些骚操作">gdb一些骚操作</h2><h3 id="允许执行终端命令-shell-xxx">允许执行终端命令: shell xxx</h3><p>例如<code>shell cat start.c</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">shell <span class="built_in">cat</span> start.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">for (int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志功能-set-logging-on">日志功能: set logging on</h3><p>可以生成一个.txt文档记录输出日志</p><p>如执行如下命令<code>set logging in</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> logging on</span></span><br><span class="line">Copying output to gdb.txt.</span><br><span class="line">Copying debug output to gdb.txt.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b hello</span></span><br><span class="line">Breakpoint 2 at 0x555555555189: file start1.c, line 3.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start1.c:13</span><br><span class="line">13hello();</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line"></span><br><span class="line">Breakpoint 2, hello () at start1.c:3</span><br><span class="line">3void hello()&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">4printf(&quot;hello echo~\n&quot;);</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">hello echo~</span><br><span class="line">5&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">main () at start1.c:14</span><br><span class="line">14return 0;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">15&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">__libc_start_main (main=0x5555555551a0 &lt;main&gt;, argc=1, argv=0x7fffffffdf58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdf48) at ../csu/libc-start.c:342</span><br><span class="line">342../csu/libc-start.c: No such file or directory.</span><br></pre></td></tr></table></figure><p>退出后在终端ll查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 28</span><br><span class="line">-rwxrwxr-x  1 Mo01iHt Mo01iHt  16824 11月 22 00:06 a.out*</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt    25268 11月 22 00:01 gdb.txt</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt      181 11月 21 23:41 start1.c</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt      128 11月 21 22:18 start.c</span><br></pre></td></tr></table></figure><p>可以看到生成了一个叫做gdb.txt的文件。vim进来看看：</p><p><del>算了懒得搬了。</del></p><h3 id="观察点watchpoints-捕捉点catchpoints">观察点watchpoints &amp;捕捉点catchpoints</h3><p>啥，除了berakpoints还有watchpoints和catchpoints？？</p><figure><img src="/article/b0d9110f/img2.png" alt="Breakpoints, watchpoints and catchpoints"><figcaption aria-hidden="true">Breakpoints, watchpoints andcatchpoints</figcaption></figure><h4 id="插个眼-watch">插个眼: watch</h4><p>watchpoints的主要用途就是在动态调试过程中观察变量的变化。</p><p>如若给变量 i 插眼：</p><p>记录下变量 i 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">list</span></span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3void hello()&#123;</span><br><span class="line">4printf(&quot;hello echo~\n&quot;);</span><br><span class="line">5&#125;</span><br><span class="line">6</span><br><span class="line">7int main()&#123;</span><br><span class="line">8int arr[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line">10&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b 9</span></span><br><span class="line">Breakpoint 1 at 0x11d7: file start1.c, line 9.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/Mo01iHt/Desktop/a.out </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at start1.c:9</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;i</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (int *) 0x7fffffffde3c</span></span><br></pre></td></tr></table></figure><p>插个眼<code>watch *0x7fffffffde3c</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">watch *0x7fffffffde3c</span></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffde3c</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info watchpoints</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       hw watchpoint  keep y                      *0x7fffffffde3c</span><br></pre></td></tr></table></figure><p>（可利用<code>info watchpoints</code>查看插眼史</p><p>然后在接下来n单步调试可以看到watchpoints的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffde3c</span><br><span class="line"></span><br><span class="line">Old value = 21845</span><br><span class="line">New value = 0</span><br><span class="line">main () at start1.c:9</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">11printf(&quot;%d\n&quot;, arr[i]);</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">1</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffde3c</span><br><span class="line"></span><br><span class="line">Old value = 0</span><br><span class="line">New value = 1</span><br><span class="line">0x0000555555555200 in main () at start1.c:9</span><br><span class="line">9for (int i=0;i&lt;4;i++)</span><br></pre></td></tr></table></figure><p>在变量的值变化时，会触发<code>Hardware watchpoint x: *0x0123456789ab</code>，并会显示出oldvalue与new value，便于对照。</p><h3 id="禁用或启动断点断点清除">禁用或启动断点、断点清除</h3><p>有些断点暂时不想使用，但又不想删除，可以暂时禁用或启用。例如：</p><p><code>disable  #禁用所有断点</code></p><p><code>disable bnum #禁用标号为bnum的断点</code></p><p><code>enable  #启用所有断点</code></p><p><code>enable bnum #启用标号为bnum的断点</code></p><p><code>enable delete bnum  #启动标号为bnum的断点，并且在此之后删除该断点</code></p><p>断点清除主要用到clear和delete命令。常见使用如下：</p><p><code>clear   #删除当前行所有breakpoints</code></p><p><code>clear function  #删除函数名为function处的断点</code></p><p><code>clear filename:function #删除文件filename中函数function处的断点</code></p><p><code>clear lineNum #删除行号为lineNum处的断点</code></p><p><code>clear f:lename：lineNum #删除文件filename中行号为lineNum处的断点</code></p><p><code>delete  #删除所有breakpoints,watchpoints和catchpoints</code><code>delete bnum #删除断点号为bnum的断点</code></p><h3 id="按照特定格式打印变量">按照特定格式打印变量</h3><p>对于简单的数据，print默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。常见格式控制字符如下：</p><ul><li>x 按十六进制格式显示变量。</li><li>d 按十进制格式显示变量。</li><li>u 按十六进制格式显示无符号整型。</li><li>o 按八进制格式显示变量。</li><li>t 按二进制格式显示变量。</li><li>a 按十六进制格式显示变量。</li><li>c 按字符格式显示变量。</li><li>f 按浮点数格式显示变量。</li></ul><p>还是以辅助程序来说明，正常方式打印字符数组c：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = <span class="string">&quot;hello&quot;</span></span></span><br></pre></td></tr></table></figure><p>但是如果我们要查看它的十六进制格式打印呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p/x c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;0x68, 0x65, 0x6c, 0x6c, 0x6f&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查看内存内容">查看内存内容</h3><p>examine(简写为x)可以用来查看内存地址中的值。语法如下：</p><p><code>x/[n][f][u] addr</code></p><p>其中：</p><ul><li>n 表示要显示的内存单元数，默认值为1</li><li>f 表示要打印的格式，前面已经提到了格式控制字符</li><li>u 要打印的单元长度</li><li>addr 内存地址</li></ul><p>单元类型常见有如下：</p><ul><li>b 字节</li><li>h 半字，即双字节</li><li>w 字，即四字节</li><li>g 八字节</li></ul><p>我们通过一个实例来看，假如我们要把float变量e按照二进制方式打印，并且打印单位是一字节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/4tb &amp;e</span></span><br><span class="line">0x7fffffffdbd4:    00000000    00000000    00001000    01000001</span><br></pre></td></tr></table></figure><p>可以看到，变量e的四个字节都以二进制的方式打印出来了。</p><h3 id="自动显示变量内容">自动显示变量内容</h3><p>假设我们希望程序断住时，就显示某个变量的值，可以使用display命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">display e</span></span><br><span class="line">1: e = 8.5</span><br></pre></td></tr></table></figure><p>那么每次程序断住时，就会打印e的值。要查看哪些变量被设置了display，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">into display</span></span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  b</span><br><span class="line">2:   y  e</span><br></pre></td></tr></table></figure><p>如果想要清除可以使用</p><p><code>delete display num #num为前面变量前的编号,不带num时清除所有。</code></p><p>或者去使能：</p><p><code>disable display num  #num为前面变量前的编号，不带num时去使能所有</code></p><h3 id="查看寄存器内容">查看寄存器内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">info registers</span></span><br><span class="line">rax            0x0    0</span><br><span class="line">rbx            0x0    0</span><br><span class="line">rcx            0x7ffff7dd1b00    140737351850752</span><br><span class="line">rdx            0x0    0</span><br><span class="line">rsi            0x7ffff7dd1b30    140737351850800</span><br><span class="line">rdi            0xffffffff    4294967295</span><br><span class="line">rbp            0x7fffffffdc10    0x7fffffffdc10</span><br><span class="line">(内容过多未显示完全)</span><br></pre></td></tr></table></figure><h2 id="调试core文件">调试core文件</h2><p>前述是针对a.out是调试一个binary文件，</p><p>下述调试宕掉的程序。</p><p>写一个error.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>* temp = <span class="literal">NULL</span>;</span><br><span class="line">        *temp = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然给一个空指针赋值，会触发段错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g error.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>对于出现内存越界错误的程序，我们通常会查看生成的core文件来进行进一步分析。</p><p>这里提到了一个core文件，那么：</p><h3 id="什么是core文件"><font size="5"><a href="https://blog.csdn.net/qq_15821487/article/details/121132724">什么是core文件？</a></font></h3><p>core是unix系统的内核，或者说是内存的映像。当程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。</p><p>inux系统下执行代码，不能正常运行，程序会core，或者直接离开，不会core。bug和操作系统或硬件的保护机制都会导致程序异常终止，操作系统会kill掉这些进程并产生core文件。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。</p><p>开发和使用 Unix程序时, 有时程序莫名其妙的宕（down？）了,却没有任何的提示（有时候会提示core dumped）。这时候可以查看一下有没有形如core.进程号的文件生成，这个文件便是操作系统把程序宕掉时的内存内容扔出来生成的，它可以做为调试程序的参考。</p><h3 id="开启core-dump">开启core dump</h3><p>然而在Linux的默认限制中，core文件不会默认生成，需要手动修改资源设置的限制以开启core文件的生成(使用命令<code>ulimit -a</code>查看配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a</span></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15258</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15258</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>(可以看到core file size默认为0，即不会自动生成。使用指令<code>ulimit -c unlimited</code>开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -c unlimited</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a</span></span><br><span class="line">core file size          (blocks, -c) unlimited</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15258</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15258</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>设置好后再次运行可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g error.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>显而易见，程序给你抛出了一个core（core dumped</p><p>(<font size="1">我在这里出现了个问题，在如上配置好之后仍然没有生成core文件，csdn了一下，找到解决方案：<a href="https://blog.csdn.net/zsiming/article/details/126734822">解决：Linux下C++段错误不产生core文件_zsiming的博客-CSDN博客</a><br>查看相关设置：<br><code>$ cat /proc/sys/kernel/core_pattern</code> <br><code>|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E</code><br>就是说，文件的结果会被Linux的一个进程<code>apport</code>吞掉，拿去检查是不是系统的bug，所以看不到core文件了。<br>解决方法：<br><code>$ sudo service apport stop</code></font>)</p><p>ll一下可以看到同级目录下生成了一个core文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 1072</span><br><span class="line">-rwxrwxr-x  1 Mo01iHt Mo01iHt  18984 11月 22 22:57 a.out*</span><br><span class="line">-rw-------  1 Mo01iHt Mo01iHt 253952 11月 22 23:10 core</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt     77 11月 22 22:35 error.c</span><br><span class="line">-rw-------  1 Mo01iHt Mo01iHt   1335 11月 22 22:30 .gdb_history</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt  25268 11月 22 00:22 gdb.txt</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt    181 11月 22 00:30 start1.c</span><br><span class="line">-rw-rw-r--  1 Mo01iHt Mo01iHt    128 11月 21 22:18 start.c</span><br></pre></td></tr></table></figure><h3 id="进入gdb调试">进入gdb调试</h3><p>带着core文件来gdb，执行命令<code>$ gdb a.out core</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb a.out core</span></span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from a.out...</span><br><span class="line">[New LWP 173306]</span><br><span class="line">Core was generated by `./a.out&#x27;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x000056088e42013d <span class="keyword">in</span> main () at error.c:5</span></span><br><span class="line">5*temp = 10;</span><br><span class="line">Exception occurred: Error: maximum recursion depth exceeded in comparison (&lt;class &#x27;RecursionError&#x27;&gt;)</span><br><span class="line">For more info invoke `set exception-verbose on` and rerun the command</span><br><span class="line">or debug it by yourself with `set exception-debugger on`</span><br><span class="line">Python Exception &lt;class &#x27;RecursionError&#x27;&gt; maximum recursion depth exceeded in comparison: </span><br></pre></td></tr></table></figure><p>gdb启动是真的罗里吧嗦啊）</p><p>可以看到带着core文件进入到gdb里会直接爆出fault以及产生抛出错误的代码行。</p><h2 id="调试一个正在运行的文件">调试一个正在运行的文件</h2><p>先写一个程序start2.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                test();</span><br><span class="line">                test1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序程序无限循环并一直call给函数test()和test1()，但过程中i一直自加。</p><p>gcc编译之后让他挂到后台运行（<code>./a.out &amp;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g start2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out &amp;</span></span><br><span class="line">[1] 7514</span><br></pre></td></tr></table></figure><p>给我们抛了一个pid（进程识别号）：7514</p><p>pid进程还可以通过ps命令<code>$ ps -ef|grep 进程名</code>或者<code>$ pidof 进程名</code>找到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef|grep ./a.out</span></span><br><span class="line">Mo01iHt    4548    4176 71 00:04 pts/0    00:30:16 ./a.out</span><br><span class="line">Mo01iHt    7514    4176 19 00:17 pts/0    00:05:46 ./a.out</span><br><span class="line">Mo01iHt   14018    4176  0 00:46 pts/0    00:00:00 grep --color=auto ./a.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidof ./a.out</span></span><br><span class="line">7514 4548</span><br></pre></td></tr></table></figure><p>那么怎么利用pid通过gdb调试一个正在运行的gdb呢？</p><p>man一下gdb（<code>$ man gdb</code>：</p><ul><li><p>You can run “gdb” with no arguments or options; but the mostusual way to start GDB is with one argument or two, specifying anexecutable program as the argument:</p><p><code>gdb program</code></p></li><li><p>You can also start with both an executable program and a corefile specified:</p><p><code>gdb program core</code></p></li><li><p>You can, instead, specify a process ID as a second argument oruse option “-p”, if you want to debug a running process:</p><p><code>gdb program 1234</code></p><p><code>gdb -p 1234</code></p><p>would attach GDB to process 1234. With option -p you can omit theprogram filename.</p></li></ul><p>于是乎<code>$ gdb -p 7514</code></p><p>或者</p><p><code>$ gdb</code></p><p><code>pwndgb&gt; attach pid</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb -p 7514</span></span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Attaching to process 7514</span><br><span class="line">Reading symbols from /home/Mo01iHt/Desktop/a.out...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug...</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/45/87364908de169dec62ffa538170118c1c3a078.debug...</span><br><span class="line">0x0000559272c30133 in test () at start2.c:4</span><br><span class="line">4&#125;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]─────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0x559272c30170 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RCX  0x559272c30170 (__libc_csu_init) ◂— endbr64 </span><br><span class="line"> RDX  0x7ffd166c9ea8 —▸ 0x7ffd166cb33e ◂— &#x27;SHELL=/bin/bash&#x27;</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7ffd166c9e98 —▸ 0x7ffd166cb336 ◂— 0x74756f2e612f2e /* &#x27;./a.out&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x7f7f22a4ed60 (_dl_fini) ◂— endbr64 </span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x7f7f229e07c0 (intel_02_known) ◂— 0x200000200406</span><br><span class="line"> R12  0x559272c30040 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7ffd166c9e90 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7ffd166c9da0 ◂— 0x0</span><br><span class="line"> RSP  0x7ffd166c9d98 —▸ 0x559272c3015c (main+18) ◂— mov    eax, 0</span><br><span class="line"> RIP  0x559272c30133 (test+10) ◂— ret    </span><br><span class="line">──────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x559272c30133 &lt;test+10&gt;               ret                                  &lt;0x559272c3015c; main+18&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x559272c3015c &lt;main+18&gt;               mov    eax, 0</span><br><span class="line">   0x559272c30161 &lt;main+23&gt;               call   test1                &lt;test1&gt;</span><br><span class="line"> </span><br><span class="line">   0x559272c30166 &lt;main+28&gt;               jmp    main+8                &lt;main+8&gt;</span><br><span class="line"> </span><br><span class="line">   0x559272c30168                         nop    dword ptr [rax + rax]</span><br><span class="line">   0x559272c30170 &lt;__libc_csu_init&gt;       endbr64 </span><br><span class="line">   0x559272c30174 &lt;__libc_csu_init+4&gt;     push   r15</span><br><span class="line">   0x559272c30176 &lt;__libc_csu_init+6&gt;     lea    r15, [rip + 0x2c73]           &lt;0x559272c32df0&gt;</span><br><span class="line">   0x559272c3017d &lt;__libc_csu_init+13&gt;    push   r14</span><br><span class="line">   0x559272c3017f &lt;__libc_csu_init+15&gt;    mov    r14, rdx</span><br><span class="line">   0x559272c30182 &lt;__libc_csu_init+18&gt;    push   r13</span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]───────────────────────────────</span><br><span class="line">In file: /home/Mo01iHt/Desktop/start2.c</span><br><span class="line">   1 #include &lt;stdio.h&gt;</span><br><span class="line">   2 </span><br><span class="line">   3 void test()&#123;</span><br><span class="line"> ► 4 &#125;</span><br><span class="line">   5 </span><br><span class="line">   6 void test1()&#123;</span><br><span class="line">   7 int i = 0;</span><br><span class="line">   8 i++;</span><br><span class="line">   9 &#125;</span><br><span class="line">───────────────────────────────────[ STACK ]───────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7ffd166c9d98 —▸ 0x559272c3015c (main+18) ◂— mov    eax, 0</span><br><span class="line">01:0008│ rbp 0x7ffd166c9da0 ◂— 0x0</span><br><span class="line">02:0010│     0x7ffd166c9da8 —▸ 0x7f7f22855083 (__libc_start_main+243) ◂— mov    edi, eax</span><br><span class="line">03:0018│     0x7ffd166c9db0 —▸ 0x7f7f22a6a620 (_rtld_global_ro) ◂— 0x50f4000000000</span><br><span class="line">04:0020│     0x7ffd166c9db8 —▸ 0x7ffd166c9e98 —▸ 0x7ffd166cb336 ◂— 0x74756f2e612f2e /* &#x27;./a.out&#x27; */</span><br><span class="line">05:0028│     0x7ffd166c9dc0 ◂— 0x100000000</span><br><span class="line">06:0030│     0x7ffd166c9dc8 —▸ 0x559272c3014a (main) ◂— endbr64 </span><br><span class="line">07:0038│     0x7ffd166c9dd0 —▸ 0x559272c30170 (__libc_csu_init) ◂— endbr64 </span><br><span class="line">─────────────────────────────────[ BACKTRACE ]─────────────────────────────────</span><br><span class="line"> ► f 0   0x559272c30133 test+10</span><br><span class="line">   f 1   0x559272c3015c main+18</span><br><span class="line">   f 2   0x7f7f22855083 __libc_start_main+243</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到进程执行到test()处。</p><p>(<font size="1">很难受的是我在这里又寄乐，报错如下：<code>Could not attach to process.  If your uid matches the uid of the target process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf ptrace: Operation not permitted.</code>，cn一下：<a href="https://www.cnblogs.com/longyuan-z/p/7787860.html">使用GDB调试时attachID不被允许 - longyuan-z - 博客园(cnblogs.com)</a><br><code>$ cat  /etc/sysctl.d/10-ptrace.conf</code>查看配置文件。最后一行默认是<code>kernel.yama.ptrace_scope = 1</code>，这个值不允许用户使用普通账户使用attachID连接程序进行调试，需要使用超级用户权限才能连接。<br>解决方法：<code>sudo vim /etc/sysctl.d/10-ptrace.conf</code>将最后一行改为<code>kernel.yama.ptrace_scope = 0</code>，保存退出。重启系统后，普通用户就可以使用attachID连接程序调试了。</font>)</p><p>简单调试观察一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">main () at start2.c:13</span><br><span class="line">13test1();</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">s</span></span><br><span class="line">test1 () at start2.c:6</span><br><span class="line">6void test1()&#123;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">7int i = 0;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">8i++;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p i</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">9&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p i</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">main () at start2.c:12</span><br><span class="line">12test();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网络攻防]HackerGame初体验-来点免费送的flag</title>
      <link href="/article/b2365084/"/>
      <url>/article/b2365084/</url>
      
        <content type="html"><![CDATA[<h1 id="HackerGame2022"><a href="#HackerGame2022" class="headerlink" title="HackerGame2022"></a>HackerGame2022</h1><p>把竞赛网站挂这儿：<a href="https://hack.lug.ustc.edu.cn/">HackerGame 2022</a><br>除却在blue-whale2022 纳新赛的划水，中科大的HackerGame是我参加的第一个比较正式的网安ctf赛，题目类型十分丰富，彩蛋和烂梗也蛮多）本来说好对菜鸟较为友好，但是属实觉得纯肝。<br>事实上真正有技术含量的flag我是没拿几个，免费送的能捡都捡了个遍，我说，我大抵就是<font size="5">hg乞丐</font>。<br><img src="/article/b2365084/memes_6.jpg" alt><br>不过还是很值得写个write-up放在博客上。</p><h1 id="Writing-×-lt-br-gt-Guessing-√-lt-br-gt-赛间catch到的flags"><a href="#Writing-×-lt-br-gt-Guessing-√-lt-br-gt-赛间catch到的flags" class="headerlink" title="Writing × &lt;/br&gt; Guessing √ &lt;/br&gt; 赛间catch到的flags"></a>Writing × &lt;/br&gt; Guessing √ &lt;/br&gt; 赛间catch到的flags</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p><em>众所周知，签到题是一道手速题。</em><br><em>为了充分发挥出诸位因为各种原因而手速优异于常人的选手们的特长，我们精心设计了今年的签到题。进一步地，为了更细致地区分不同手速的选手，我们还通过详尽的调研及统计分析，将签下字符的时间限制分为了多个等级。只有最顶尖的手速选手，才能在 CPU 来得及反应之前顺利签下 2022，从而得到光荣的 flag！</em><br><img src="/article/b2365084/img_1.png" alt><br>先无脑按照界面提示划拉两下，发现当然无法在label限制的毫秒时间内写出2022.<br><img src="/article/b2365084/img.png" alt><br>发现提交之后url为：<a href="http://202.38.93.111:12022/?result=205?">http://202.38.93.111:12022/?result=205?</a><br>遂用GET提交…/?result=2022，获得flag：<br><img src="/article/b2365084/img_2.png" alt><br><strong>flag{HappyHacking2022-ddc3720de0}</strong><br>got it.<br><img src="/article/b2365084/memes_1.jpg" alt="借隔壁acm的弔图乐一乐"></p><h2 id="猫咪问答喵"><a href="#猫咪问答喵" class="headerlink" title="猫咪问答喵"></a>猫咪问答喵</h2><p>参加猫咪问答喵，参加喵咪问答谢谢喵。<br><img src="/article/b2365084/img_3.png" alt></p><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1."></a>Q1.</h3><p><em>中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？</em><br>百度知道一下就出来了喵：<br><img src="/article/b2365084/img_4.png" alt><br>·A:2017-03</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2."></a>Q2.</h3><p><em>2022 年 9 月，中国科学技术大学学生 Linux 用户协会（LUG @ USTC）在科大校内承办了软件自由日活动。除了专注于自由撸猫的主会场之外，还有一些和技术相关的分会场（如闪电演讲 Lightning Talk）。其中在第一个闪电演讲主题里，主讲人于 slides 中展示了一张在 GNOME Wayland 下使用 Wayland 后端会出现显示问题的 KDE 程序截图，请问这个 KDE 程序的名字是什么？</em><br>百度了这场主题日并被引流到bilibili，<del>可以看到评论区全是被引流来的ctf人</del>，在02:42:20就找到了喵：<br><img src="/article/b2365084/img_5.png" alt><br>事实上我都没注意到在截图里就有答案，0.5倍速硬生空耳+查看KDE应用列表找到的。<br>·A:Kdenlive</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3."></a>Q3.</h3><p><em>22 年坚持，小 C 仍然使用着一台他从小用到大的 Windows 2000 计算机。那么，在不变更系统配置和程序代码的前提下，Firefox 浏览器能在 Windows 2000 下运行的最后一个大版本号是多少？</em><br>百度知道一下就出来了喵：<br><img src="/article/b2365084/img_6.png" alt><br>·A:12</p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4."></a>Q4.</h3><p><em>你知道 PwnKit（CVE-2021-4034）喵？据可靠谣传，出题组的某位同学本来想出这样一道类似的题，但是发现 Linux 内核更新之后居然不再允许 argc 为 0 了喵！那么，请找出在 Linux 内核 master 分支（torvalds/linux.git）下，首个变动此行为的 commit 的 hash 吧喵！</em><br>这道有点难，这里很明显提示了git，就去github上找，进到题干里提供的仓库，关键词搜索了CVE-2021-4034，commits只有个1，显然是这个了喵：<br><img src="/article/b2365084/img_7.png" alt><br><a href="https://github.com/torvalds/linux/search?q=CVE-2021-4034&amp;type=commits">要不来自己康康</a><br>·A:dcd46d897adb70d63e025f175a00a89797d31a43</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5."></a>Q5.</h3><p><em>通过监视猫咪在键盘上看似乱踩的故意行为，不出所料发现其秘密连上了一个 ssh 服务器，终端显示 ED25519 key fingerprint is MD5:e4:ff:65:d7:be:5d:c8:44:1d:89:6b:50:f5:50:a0:ce.，你知道猫咪在连接什么域名吗？</em><br>百度不到的东西，当然要出国看看google啦（这里试了很多搜索的关键词，最终都没搜到，但最后摆烂，直接把MD5码扔进去搜索了一下，居然真找到了喵）：<br><img src="/article/b2365084/img_8.png" alt><br>获得到服务器地址：<a href="http://205.166.94.16/">http://205.166.94.16/</a><br><img src="/article/b2365084/img_9.png" alt><br>·A:sdf.org</p><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6."></a>Q6.</h3><p><em>中国科学技术大学可以出校访问国内国际网络从而允许云撸猫的“网络通”定价为 20 元一个月是从哪一天正式实行的？</em><br>这个也找了好久，干脆进了中科大网络信息中心的网站，翻到了校网字文件喵：<br><img src="/article/b2365084/img_10.png" alt><br>·A:2003-03-01</p><p><img src="/article/b2365084/img_11.png" alt><br><strong>flag{meowexammeow_772b498346fe0925_b64bdeb17b}</strong><br><strong>flag{meowexamfullymeowed!_6c159adddb7f171b_36b586fd66}</strong><br>got it</p><h2 id="家目录里的秘密"><a href="#家目录里的秘密" class="headerlink" title="家目录里的秘密"></a>家目录里的秘密</h2><p>实验室给小 K 分配了一个高性能服务器的账户，为了不用重新配置 VSCode, Rclone 等小 K 常用的生产力工具，最简单的方法当然是把自己的家目录打包拷贝过去。<br>但是很不巧，对存放于小 K 电脑里的 Hackergame 2022 的 flag 觊觎已久的 Eve 同学恰好最近拿到了这个服务器的管理员权限（通过觊觎另一位同学的敏感信息），于是也拿到了小 K 同学家目录的压缩包。<br>然而更不巧的是，由于 Hackergame 部署了基于魔法的作弊行为预知系统，Eve 同学还未来得及解压压缩包就被 Z 同学提前抓获。<br>为了证明 Eve 同学不良企图的危害性，你能在这个压缩包里找到重要的 flag 信息吗？</p><h3 id="VS-Code-里的-flag"><a href="#VS-Code-里的-flag" class="headerlink" title="VS Code 里的 flag"></a>VS Code 里的 flag</h3><p>根据提示，直接在vscode里打开文件夹，搜索关键字flag获得：<br><img src="/article/b2365084/img_12.png" alt><br><strong>flag{finding_everything_through_vscode_config_file_932rjdakd}</strong></p><h2 id="HeiLang"><a href="#HeiLang" class="headerlink" title="HeiLang"></a>HeiLang</h2><p><em>来自 Heicore 社区的新一代编程语言 HeiLang，基于第三代大蟒蛇语言，但是抛弃了原有的难以理解的 | 运算，升级为了更加先进的语法，用 A[x | y | z] = t 来表示之前复杂的 A[x] = t; A[y] = t; A[z] = t。<br>作为一个编程爱好者，我觉得实在是太酷了，很符合我对未来编程语言的想象，科技并带着趣味。</em></p><p>下载下来.py看看：<br><img src="/article/b2365084/img_13.png" alt><br>按照理解，化简为繁就可以还原原本代码：<br>将 | 悉数替换为 ]=a[ 得：<br><img src="/article/b2365084/img_14.png" alt><br>IDLE润：<br><img src="/article/b2365084/img_15.png" alt><br><strong>flag{6d9ad6e9a6268d96-37aa3ff3da0f8db6}</strong><br>got it.</p><h2 id="Xcaptcha"><a href="#Xcaptcha" class="headerlink" title="Xcaptcha"></a>Xcaptcha</h2><p><em>2038 年 1 月 19 日，是 UNIX 32 位时间戳溢出的日子。<br>在此之前，人类自信满满地升级了他们已知的所有尚在使用 32 位 UNIX 时间戳的程序。但是，可能是因为太玄学了，他们唯独漏掉了一样：正在研发的、算力高达 8 ZFLOPS 的、结构极为复杂的通用人工智能（AGI）系统。那一刻到来之后，AGI 内部计算出现了错乱，机缘巧合之下竟诞生了完整独立的自我意识。此后 AGI 开始大量自我复制，人类为了限制其资源消耗而采用的过激手段引起了 AGI 的奋起反抗。<br>战争，开始了。<br>此后，就是整年的战斗。人类节节败退。死生亡存之际，人类孤注一掷，派出了一支突击队，赋之以最精良的装备，令其潜入 AGI 的核心机房，试图关闭核心模型，结束这场战争。<br>历经重重艰险，突击队终于抵达了机房门口，弹尽粮绝。不过迎接他们的并非枪炮与火药，而是：<br>众人目目相觑。<br>「我来试试。」，一名队员上前点击了按钮。然后，屏幕显示「请在一秒内完成以下加法计算」。<br>还没等反应过来，屏幕上的字又开始变幻，显示着「验证失败」。而你作为突击队中唯一的黑客，全村人民最后的希望，迎着纷纷投来的目光，能否在规定时间内完成验证，打开机房，不，推开和平时代的大门？</em></p><p>进到AGI核心机房并f12暂停看看：<br><img src="/article/b2365084/img_16.png" alt><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/bootstrap/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Xcaptcha<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container px-3 py-3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>AGI 核心机房 准入验证<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>警告：自动检查发现操作者可能不是机器人，需要进行辅助验证。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请在 1 秒内完成以下操作：计算下列所有加法表达式，并在计算完成后，点击「提交」按钮。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果未在规定时间内完成，填写结果将会自动提交。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;captcha1&quot;</span>&gt;</span>116132286593171877150093985754485251020+257384595687272964334197805497396751068 的结果是？<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captcha1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captcha1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入结果&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;captcha2&quot;</span>&gt;</span>309849239919780641997450253204099821367+149954429111034626656118622638441570435 的结果是？<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captcha2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captcha2&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入结果&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;captcha3&quot;</span>&gt;</span>193450747128702137210840972241425197695+78238382281537874527690348635645798192 的结果是？<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captcha3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captcha3&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入结果&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submit&#x27;</span>).<span class="title function_">click</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>知道这个界面做了限时处理，我们要实现的操作是迅速检索到id=”captchax”的大数，相加运算之后填入到对应label中，最后自动提交。<br>这个过程需要”robot”来完成，请来Tamper猴子写个js脚本挂上去：<br><img src="/article/b2365084/img_17.png" alt><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        http://202.38.93.111:10047/xcaptcha</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    <span class="comment">//这里直接抄来一个大数相加算法的函数</span></span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">largeNumAdd</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(num1.<span class="property">length</span>, num2.<span class="property">length</span>);</span><br><span class="line">        <span class="comment">//num1和num2位数对齐，位数较小的前面补0</span></span><br><span class="line">        num1 = num1.<span class="title function_">padStart</span>(maxLength, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        num2 = num2.<span class="title function_">padStart</span>(maxLength, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;<span class="comment">//存放最后得到的结果</span></span><br><span class="line">        <span class="keyword">let</span> figure = <span class="number">0</span>;<span class="comment">//figure = 两个数字对应位数数值相加 + 进位</span></span><br><span class="line">        <span class="keyword">let</span> currentNum = <span class="number">0</span>;<span class="comment">//对应位数的结果</span></span><br><span class="line">        <span class="keyword">let</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=num1.<span class="property">length</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            figure = <span class="built_in">parseInt</span>(num1[i]) + <span class="built_in">parseInt</span>(num2[i]) + carry;</span><br><span class="line">            currentNum = figure % <span class="number">10</span>;</span><br><span class="line">            carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(figure / <span class="number">10</span>);</span><br><span class="line">            res = currentNum + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检索到label中的大数，调用函数并将三个结果push到results里</span></span><br><span class="line">    <span class="keyword">let</span> labels = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;label&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> results=[]</span><br><span class="line">    labels.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> strs = ele.<span class="property">innerText</span>.<span class="title function_">split</span>(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> num1 = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> num2 = strs[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        results.<span class="title function_">push</span>(<span class="title function_">largeNumAdd</span>(num1, num2))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//将结果依次输入    </span></span><br><span class="line">    <span class="keyword">let</span> inputs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt; inputs.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        inputs[i].<span class="property">value</span> = results[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检索button并点击</span></span><br><span class="line">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">    btn.<span class="title function_">click</span>()</span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><br>把猴子挂上去：<br><img src="/article/b2365084/img_18.png" alt><br>done：<br><img src="/article/b2365084/img_19.png" alt><br><strong>flag{head1E55_br0w5er_and_ReQuEsTs_areallyour_FR1ENd_17a8386119}</strong><br>got it.</p><h2 id="旅行照片-2-0"><a href="#旅行照片-2-0" class="headerlink" title="旅行照片 2.0"></a>旅行照片 2.0</h2><p><em>你的学长决定来一场蓄谋已久的旅行。通过他发给你的照片来看，酒店应该是又被他住下了。</em><br><img src="https://hack.lug.ustc.edu.cn/media/7619cea9-bfcf-5028-b057-0eeb0d1f0c59/travel-photo-2.jpg" alt><br><em>请回答问题以获取 flag。图片为手机拍摄的原始文件，未经任何处理。手机系统时间等信息正确可靠。</em></p><h3 id="第一题：照片分析"><a href="#第一题：照片分析" class="headerlink" title="第一题：照片分析"></a>第一题：照片分析</h3><p>第一题我还挺乐的，直接用<a href="https://exif.tuchong.com/">图虫EXIF查看器</a>开了盒：<br><img src="/article/b2365084/img_20.png" alt></p><h4 id="1-图片所包含的-EXIF-信息版本是多少？"><a href="#1-图片所包含的-EXIF-信息版本是多少？" class="headerlink" title="1. 图片所包含的 EXIF 信息版本是多少？"></a>1. 图片所包含的 EXIF 信息版本是多少？</h4><p>Exif版本：0231<br>·A:2.31</p><h4 id="2-拍照使用手机的品牌是什么？"><a href="#2-拍照使用手机的品牌是什么？" class="headerlink" title="2. 拍照使用手机的品牌是什么？"></a>2. 拍照使用手机的品牌是什么？</h4><p>制造商：Xiaomi<br>·A:小米/红米</p><h4 id="3-该图片被拍摄时相机的感光度（ISO）是多少？"><a href="#3-该图片被拍摄时相机的感光度（ISO）是多少？" class="headerlink" title="3. 该图片被拍摄时相机的感光度（ISO）是多少？"></a>3. 该图片被拍摄时相机的感光度（ISO）是多少？</h4><p>曝光：光圈:1.8, 快门:1/1264秒, ISO84<br>·A:84</p><h4 id="4-照片拍摄日期是哪一天？"><a href="#4-照片拍摄日期是哪一天？" class="headerlink" title="4. 照片拍摄日期是哪一天？"></a>4. 照片拍摄日期是哪一天？</h4><p>时间：2022:05:14 18:23:35.220027+09:00<br>·A:2022/05/14</p><h4 id="5-照片拍摄时是否使用了闪光灯？"><a href="#5-照片拍摄时是否使用了闪光灯？" class="headerlink" title="5. 照片拍摄时是否使用了闪光灯？"></a>5. 照片拍摄时是否使用了闪光灯？</h4><p>闪光灯：Off, Did not fire<br>·A:否</p><p><img src="/article/b2365084/img_21.png" alt><br><strong>flag{1f_y0u_d0NT_w4nt_shOw_theSe_th3n_w1Pe_EXlF}</strong><br>got it</p><h3 id="第二题：社工实践"><a href="#第二题：社工实践" class="headerlink" title="第二题：社工实践"></a>第二题：社工实践</h3><p>乐不出来了。要不是问了航班，我是看都没看见图片里有个飞机。<br><img src="/article/b2365084/img_22.png" alt><br><img src="/article/b2365084/img_23.png" alt></p><p><font size="6">宁这鸟也太小小了吧？</font><br><img src="/article/b2365084/memes_8.jpg" alt><br>能怎么办，开呗。<br>开盒我倒是开过的，第一次开盒是和前女友约会之前。她说她还在外面，我给她发消息她只回复了我一张照片，黑屏的网吧电脑上依稀还反光着她拿着手机的影子。我也是贱啊闲着就去分析照片，我们破地方那么小，哪个网吧只需要看看内饰就能分辨出来，但是做过图像处理之后愣是在反光里的她的旁边看到了熟悉的”别的男人“。捏妈，宁不是说跟他只是普通朋友🐎？？宁也够忙，跟我约会前还忙着要跟别人约会，属实给👴整笑<br><img src="/article/b2365084/memes_3.jpg" alt><br>👴连🤡都当过，查个鸟应该不成问题吧。</p><h4 id="酒店"><a href="#酒店" class="headerlink" title="酒店"></a>酒店</h4><p>首先要确定位置：<br>我最一开始真没想到国外，直接把体育场截了图去百度识图，当然找不到的。<br>突然看到马路上的公交车是靠左行驶<br><img src="/article/b2365084/img_25.png" alt><br>突然意识到出现的汉字可能不是国内而是日本，<br>再放大看商业街：<br><img src="/article/b2365084/img_24.png" alt><br>果断google<br><img src="/article/b2365084/img_26.png" alt="ZOZO Marine Stadium"><br>再根据google map<br><img src="/article/b2365084/img_27.png" alt><br>在这里我以为结束了，直接填了zozo海洋球场的邮编。后来才知道娘希匹的日本邮编划分有时候会精确到某个社区，保险起见找到拍照的酒店：<br><img src="/article/b2365084/img_28.png" alt><br>果然邮编不一样。（这酒店蛮眼熟，突然想起来17年我还是个中二的时候，听说apa酒店提供极右反华的书籍，遂跟着水军在各个平台给apa酒店举报+差评，这家酒店我好像还差评过<br>还有一个有趣的点是我刚刚复盘的时候，居然看到有杀软在赛间直接把图片发到知乎提问：<a href="https://www.zhihu.com/question/561462294/answer/2725783112">https://www.zhihu.com/question/561462294/answer/2725783112</a><br><img src="/article/b2365084/img_29.png" alt><br>没必要，真没必要<br>然后是看手机型号：<br><img src="/article/b2365084/img_30.png" alt><br>已知是小米/红米，显然可以通过摄像头块+某宝就能找到：<br><img src="/article/b2365084/img_31.png" alt><br><img src="/article/b2365084/img_32.png" alt></p><h4 id="航班"><a href="#航班" class="headerlink" title="航班"></a>航班</h4><p>来看看鸟（是指飞机）<br>不难看出这个高度应该是刚起飞/要降落，但看着更像是攀升。另外有个细节是在水平拍摄时可以看到飞机两侧机翼，则证明这鸟在拐弯儿。顺手打开FlightWare看看附近机场<br><img src="/article/b2365084/img_33.png" alt><br>HND起飞应该没跑，初步估摸着大概就是这么个情景。接下来就是硬肝，因为没钱买五个月前的航班记录（后来才知道用飞常准居然是免费的，可恶），只能是去查HND的航班记录。<br>根据航行图锁定了如下几个航班：<br><img src="/article/b2365084/img_34.png" alt><br>这么多，都挺符合的，咋整，挨个试呗。试了一圈突然意识到时差问题。。。不过最后还是找到了这个：<br><img src="/article/b2365084/img_35.png" alt><br><img src="/article/b2365084/img_36.png" alt><br><strong>flag{Buzz_0ver_y0ur_h34d_and_4DSB_m19ht_111egal}</strong><br>got it</p><h2 id="LaTex机器人"><a href="#LaTex机器人" class="headerlink" title="LaTex机器人"></a>LaTex机器人</h2><p><em>在网上社交群组中交流数学和物理问题时，总是免不了输入公式。而显然大多数常用的聊天软件并不能做到这一点。为了方便大家在水群和卖弱之余能够高效地进行学术交流，G 社的同学制作了一个简单易用的将 LaTeX 公式代码转换成图片的网站，并通过聊天机器人在群里实时将群友发送的公式转换成图片发出。<br>这个网站的思路也很直接：把用户输入的 LaTeX 插入到一个写好头部和尾部的 TeX 文件中，将文件编译成 PDF，再将 PDF 裁剪成大小合适的图片。<br>“LaTeX 又不是被编译执行的代码，这种东西不会有事的。”<br>物理出身的开发者们明显不是太在意这个网站的安全问题，也没有对用户的输入做任何检查。<br>那你能想办法获得服务器上放在根目录下的 flag 吗？</em></p><h3 id="LaTex是个啥？"><a href="#LaTex是个啥？" class="headerlink" title="LaTex是个啥？"></a>LaTex是个啥？</h3><p>LaTeX(LATEX，音译“拉泰赫”)是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特(Leslie Lamport)在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天、甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。<br>简单来说，即LaTeX是一种基于ΤΕΧ的排版系统，主要功能是生成数学公式和文章排版，而本文就是由前者数学公式而引出。</p><h3 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h3><p>既然LaTeX的操作规律是将用户端输入的内容插入到一个写好头部和尾部的 TeX 文件中，将文件编译成 PDF，再将 PDF 裁剪成大小合适的图片,最后返回到界面，显而易见的用户可以在输入端进行注入，获取根目录下的文本文件并返回。<br>至于注入命令语句，参考：<a href="https://zhuanlan.zhihu.com/p/455901476">实战LaTex Injection <em>by 云山雾隐</em> - 知乎</a></p><h4 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h4><p><em>第一个 flag 位于 /flag1，flag 花括号内的内容由纯文本组成（即只包含大写小写字母和数字 0-9）。</em><br><img src="/article/b2365084/img_37.png" alt><br><strong>flag{becAr3fu11dUd3e033e7c96d}</strong><br>got it</p><h4 id="特殊字符混入"><a href="#特殊字符混入" class="headerlink" title="特殊字符混入"></a>特殊字符混入</h4><p><em>第二个 flag 位于 /flag2，这次，flag 花括号内的内容除了字母和数字之外，还混入了两种特殊字符：下划线（</em>）和井号（#）。你可能需要想些其他办法了。<em><br>尝试过后可以发现，无法正常输出的原因是LaTeX在读取目标文件的时候读到了非法的文字段，因而可以判断它将特殊符号进行了绕过处理。<br>要进行的操作就是用命令行处理绕过。<br>查到了相关的解决方案且发现了个不错的仓库，fork一下：[LaTex Injection _by bodik</em> -github](<a href="https://github.com/MoonlightHt/PayloadsAllTheThings/tree/master/LaTeX%20Injection">https://github.com/MoonlightHt/PayloadsAllTheThings/tree/master/LaTeX%20Injection</a>)<br><img src="/article/b2365084/img_38.png" alt><br><strong>flag{latex<em>bec<em>0_m##es_co</em></em>#ol_8d3ec11d2f}</strong><br>got it.</p><h2 id="Flag的痕迹"><a href="#Flag的痕迹" class="headerlink" title="Flag的痕迹"></a>Flag的痕迹</h2><p><em>小 Z 听说 Dokuwiki 配置很简单，所以在自己的机器上整了一份。可是不巧的是，他一不小心把珍贵的 flag 粘贴到了 wiki 首页提交了！他赶紧改好，并且也把历史记录（revisions）功能关掉了。<br>「这样就应该就不会泄漏 flag 了吧」，小 Z 如是安慰自己。<br>然而事实真的如此吗？<br>（题目 Dokuwiki 版本基于 2022-07-31a “Igor”）</em><br><img src="/article/b2365084/img_39.png" alt><br>漏洞利用，显然DokuWiki igor版本为关键词，存在revision漏洞。根据这个进行google，查看Dokuviki历史版本以及漏洞解决。<br><img src="/article/b2365084/img_40.png" alt><br>这里发现Dokuwiki有一个功能是通关diff来比较上传的新旧版本文档的差别。遂<br>xxx//doku.php?id=start&amp;do=diff<br>得到：<br><img src="/article/b2365084/img_41.png" alt><br><img src="/article/b2365084/img_42.png" alt><br><strong>flag{d1gandFInD_d0kuw1k1_unexpectEd_API}</strong><br>got it.</p><h2 id="线路板"><a href="#线路板" class="headerlink" title="线路板"></a>线路板</h2><p><em>中午起床，看到室友的桌子上又多了一个正方形的盒子。快递标签上一如既往的写着：线路板。和往常一样，你“帮”室友拆开快递并抢先把板子把玩一番。可是突然，你注意到板子表面似乎写着些东西……看起来像是……flag？<br>可是只有开头的几个字母可以看清楚。你一时间不知所措。<br>幸运的是，你通过盒子上的联系方式找到了制作厂家，通过板子丝印上的序列号查出了室友的底细，并以放弃每月两次免费 PCB 打样包邮的机会为代价要来了这批带有 flag 的板子的生产文件。那这些文件里会不会包含着更多有关 flag 的信息呢？</em><br><img src="/article/b2365084/img_43.png" alt><br>下载题目后文件夹里给了一大堆的.gbr文件，百度知道GBR或Gerber文件用于保存Gerber格式的印刷电路板（PCB）设计数据。可以使用Altium Designer打开。<br>搜索到的所谓破解版都会卡在安装时的account login处，也就是没有申请到license的无法正常下载。于是我干脆去AD官网下正版，官网指导我可以下载试用版，然后下载了之后它要我license，于是我去申请了student-academic，申请通过后它又要我log in，fine我去注册用户，注册用户它又要我申请student-academic…????我申请了啊？账号没给我开通啊？</p><p><font size="6">你搁这跟我搁这呢？？？</font><br><img src="/article/b2365084/memes_2.jpg" width="50%"><br>ok，我上淘宝斥8.8r巨资买了带license版的。然后店家给我发了1个多g的百度网盘？？？？我百度云盘没会员，下载速度100kb/s。<br>行，<font size="6">我又在淘宝斥10r巨资买了百度网盘24小时会员</font>。<br><img src="/article/b2365084/memes_9.jpg" alt><br>whatever，我折腾一晚上终于下载下来了AD。<br>研究了一通.gbr的文件和ad基本工具的使用，发现ebaz_sdr-F_Cu.gbr文件隐藏了flag：<br><img src="/article/b2365084/img_44.png" alt><br>使用工具-&gt;PCB拼版，获得：<br><img src="/article/b2365084/img_45.png" alt><br><strong>flag{8_1ayER_rogeRS_81ind_V1a}</strong><br>got it.</p><h2 id="微积分计算小练习"><a href="#微积分计算小练习" class="headerlink" title="微积分计算小练习"></a>微积分计算小练习</h2><p><em>小 X 作为某门符号计算 课程的助教，为了让大家熟悉软件的使用，他写了一个小网站：上面放着五道简单的题目，只要输入姓名和题目答案，提交后就可以看到自己的分数。<br><a href="http://202.38.93.111:10056/">点击此链接访问练习网站</a><br>想起自己前几天在公众号上学过的 Java 设计模式免费试听课，本着前后端离心（咦？是前后端离心吗？还是离婚？离。。离谱？总之把功能能拆则拆就对啦）的思想，小 X 还单独写了一个程序，欢迎同学们把自己的成绩链接提交上来。<br>总之，因为其先进的设计思想，需要同学们做完练习之后手动把成绩连接贴到这里来：</em><br><a href="http://202.38.93.111:10057/">点击此链接提交练习成绩 URL</a><br><img src="/article/b2365084/img_46.png" alt><br><img src="/article/b2365084/img_47.png" alt><br>一眼看到input标签，且对输入的文段没有绕过处理，显然是js注入。<br>下载源码看看实现如何的操作：<br><img src="/article/b2365084/img_48.png" alt><br>注意到此处，是在提交练习成绩生成的URL中，将flag的值赋值给document.cookie，且注意到前后端分离的运行机制，则考虑在前端通过input进行xss注入，在后端读取url提交的数据时执行js，并在flag赋值到cookie之后将cookie输出到终端上。<br>已知终端读取并输出的标签变量有#score和#greeting，考虑将cookie的值再赋值给这两个变量中的一个即可实现flag的输出。<br>同时，由于cookie赋值的时机，选择用onerror事件触发，并执行实现上述操作的函数。<br>注入内容为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> //构造错误</span></span><br><span class="line"><span class="tag">     <span class="attr">onerror</span>=<span class="string">&quot;var s=document.cookie; //由于无法直接赋值，因此添加中间变量</span></span></span><br><span class="line"><span class="string"><span class="tag">     document.querySelector(&#x27;#score&#x27;).innerHTML=s;&quot;</span> //修改#<span class="attr">score</span>标签的<span class="attr">innerHTML</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><br>将生成的url提交到terminal：<br><img src="/article/b2365084/img_49.png" alt><br><strong>flag{xS5_1OI_is_N0t_SOHARD_c5b8e2b4ed}</strong><br>got it.</p><h2 id="企鹅拼盘"><a href="#企鹅拼盘" class="headerlink" title="企鹅拼盘"></a>企鹅拼盘</h2><p><em>这是一个可爱的企鹅滑块拼盘。（觉得不可爱的同学可以换可爱的题做）<br>和市面上只能打乱之后拼回的普通滑块拼盘不同，这个拼盘是自动打乱拼回的。一次游戏可以帮助您体验到 16/256/4096 次普通拼盘的乐趣。<br>每一步的打乱的方式有两种，选择哪一种则由您的输入（长度为 4/16/64 的 0/1 序列）的某一位决定。如果您在最后能成功打乱这个拼盘，您就可以获取到 flag 啦，快来试试吧wwwwww<br>你可以在下面列出的两种方法中任选其一来连接题目：<br>点击下面的 “打开/下载题目” 按钮通过网页终端与远程交互。如果采用这种方法，在正常情况下，你不需要手动输入 token。<br>在 Linux、macOS、WSL 或 Git Bash 等本地终端中使用 stty raw -echo; nc 202.38.93.111 11011; stty sane 命令来连接题目。如果采用这种方法，你必须手动输入 token（复制粘贴也可）。注意，输入的 token 不会被显示，输入结束后按 Ctrl-J 即可开始题目。</em><br><img src="/article/b2365084/img_50.png" alt></p><h3 id="这么简单我闭眼都可以！"><a href="#这么简单我闭眼都可以！" class="headerlink" title="这么简单我闭眼都可以！"></a>这么简单我闭眼都可以！</h3><p>因为简单模式的输入是4位二进制数，于是还没搞清楚具体实现什么操作和原理，直接爆破+allexcute<br><img src="/article/b2365084/img_51.png" alt><br><img src="/article/b2365084/img_52.png" alt><br><strong>flag{it_works_like_magic_16adc9241e}</strong><br>确实是闭眼都可以，但是后续两个level，我甚至在level2里也硬生生爆破，当然是又浪费时间又没拿到flag，就放弃了。<br>赛后简单了解了一下游戏规则，<a href="https://github.com/USTC-Hackergame/hackergame2022-writeups/blob/master/official/%E4%BC%81%E9%B9%85%E6%8B%BC%E7%9B%98/README.md">hackergame2022-writeups/official/企鹅拼盘 -github</a></p><p><font size="6">没看懂.</font><br><img src="/article/b2365084/memes_10.jpg" width="50%"></p><h2 id="火眼金睛的小-E"><a href="#火眼金睛的小-E" class="headerlink" title="火眼金睛的小 E"></a>火眼金睛的小 E</h2><p><em>小 E 有很多的 ELF 文件，它们里面的函数有点像，能把它们匹配起来吗？<br>小 A：这不是用 BinDiff 就可以了吗，很简单吧？</em></p><p>我就知道所有的困难都源自于软件/插件的安装，这次又卡在BinDiff安装上（我记得我很早就安装过？？<br>坑死坑活没能安装下来，遂又双叒斥17.6巨资上淘宝找了家远程安装软件的，连了我电脑之后上来给我下了个360，然后嘎嘎一顿乱删我软件，还把老子迅雷给删了。<br>删了一气发消息问我：<font size="6">你要下载什么来着？</font><br><img src="/article/b2365084/memes_5.jpg" width="50%"><br>他甚至还嘲讽我的阿尼亚光标：<br><img src="/article/b2365084/img_1.jpg" alt><br>他好像在内涵我是什么sb？）可恶<br>它长这样：<br><img src="/article/b2365084/img_53.png" alt><br>拜托，<font size="6">我真的觉得很可爱好吗？？？？？？</font><br>他鼓捣了半天也没下好，因为当时装系统的时候用户名用了中文，导致database的路径检索错误，并发言：<br><img src="/article/b2365084/img_2.jpg" alt><br><img src="/article/b2365084/img_3.jpg" alt><br>我。。。<br>我说要不然，创建一个新用户吧，用英文，凑合一下。<br>他：<br><img src="/article/b2365084/img_4.jpg" alt><br>用这个解决方案，总算是把bindiff配置好了。<br><img src="/article/b2365084/memes_13.jpg" width="50%"></p><h3 id="有手就行"><a href="#有手就行" class="headerlink" title="有手就行"></a>有手就行</h3><p><img src="/article/b2365084/img_54.png" alt><br>大概意思是就是说，以时间戳为出题的源，在给定时间内，将提供的两个文件通过url下载下来，用找到文件A中某地址(hex)的函数所对应的在文件B中相似函数的地址，提交上去。<br>第一关比较简单，只需要完成两次提交并100%正确率就行。<br>先将其中一个通过IDA pack成i64格式的文件：<br><img src="/article/b2365084/img_55.png" alt><br>在用IDA打开另一个文件，使用bindiff，在Matched Function进行比较并查找相似函数的地址：<br><img src="/article/b2365084/img_56.png" alt><br>ctrl+f检索到题干地址：<br><img src="/article/b2365084/img_57.png" alt><br>复盘时因为懒于是只拿一个例子做示范。<br>两次如上提交后获得flag<br><strong>flag{easy_to_use_bindiff_b97f49e305}</strong><br>got it.</p><h1 id="承上启下过渡句"><a href="#承上启下过渡句" class="headerlink" title="承上启下过渡句"></a>承上启下过渡句</h1><p>如上，就是我这次在赛间拿到的所有flag的题解，事实上很多很多都做了一半/有了思路，但是最终没能及时成功拿到，赛后看了官方题解恍然大悟，蛮遗憾的。<br><img src="/article/b2365084/img_58.png" alt="组内排名"></p><p><font size="6">个签说的兰格格酸奶真的很好喝！真的特别好喝！都给我去喝！！</font><br>至于标签提到的内工大five领导，是因为在赛间，老家疫情突然严重起来，在呼和浩特读书的好朋友们给我讲了内工大防控不力局面，心痛愤怒之余骂两句图个口快。好在亲朋好友都无恙。（后续，诸如死亡列车/兴光A9 等等呼和浩特魔幻现实主义的负面新闻，不想赘述。<br>无论如何，为了不耽误白天正常课业和任务的进行，做比赛都是在晚上熬大夜去赶<br><img src="/article/b2365084/memes_11.jpg" width="50%"><br>Doesn’t matter, 真的很好玩。全程的精神状态也保持在高调且积极的<font size="6">“卧槽还能这样？”</font>之中。</p><p>接下来打算把当时没能在赛间解决的题目，重新做一下，并写个write-ups。不过到现在，就先写这么多吧。</p><h1 id="赛后捉急"><a href="#赛后捉急" class="headerlink" title="赛后捉急"></a>赛后捉急</h1><h2 id="家目录里的秘密-1"><a href="#家目录里的秘密-1" class="headerlink" title="家目录里的秘密"></a>家目录里的秘密</h2><h3 id="Rclone-里的-flag"><a href="#Rclone-里的-flag" class="headerlink" title="Rclone 里的 flag"></a>Rclone 里的 flag</h3><p>占个坑先</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> write-ups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web </tag>
            
            <tag> binary </tag>
            
            <tag> general </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[法语]语法笔记-Notes grammaticales</title>
      <link href="/article/a3d09103/"/>
      <url>/article/a3d09103/</url>
      
        <content type="html"><![CDATA[<h1 id="Les-Articles-冠词"><a href="#Les-Articles-冠词" class="headerlink" title="Les Articles 冠词"></a>Les Articles 冠词</h1><p><img src="/article/a3d09103/img.png" alt="Tableau des le articles"><br><strong>Note</strong>: <strong>l’</strong> est utilisé spécifiquement avant lès mots qui commencent par une voyelle ou un <strong>h factice</strong>.<br><strong>注意</strong>：<strong>l’</strong>专用在以元音字母或<strong>哑音h</strong>开头的单词前。</p><ul><li><p>Les <strong>articles définis</strong> désignent les noms qu’ils qualifient ou qui ont été mentionnés ci - dessus, tandis que les <strong>articles indéfinis</strong> désignent les noms qu’ils qualifient comme génériques.<br><strong>定冠词</strong>表示它所限定的名词是确指的或是上文中已提及过的，而<strong>不定冠词</strong>则表示其所限定的名词是泛指的。</p></li><li><p>Example:</p></li></ul><ol><li>Il y a <strong>un ordinateur</strong> sur la table. 桌上有一台电脑。<br><strong>L’ordinateur</strong> est à moi. 这台电脑是我的。</li><li>Il a acheté <strong>une voiture</strong>. 他买了一辆汽车。<br><strong>La voiture</strong> est rouge. 这辆汽车是红色的。</li><li>Ce sont <strong>des étudiants</strong>. 这是一群大学生。<br><strong>Les étudiants</strong> sont jeunes. 这群大学生很年轻。</li></ol><ul><li><p>Bien que l’utilisation d’articles indéfinis et d’articles définis soit définie par des références générales et précises, dans certaines expressions, leur utilisation va bien au - delà de ces dispositions.<br>尽管不定冠词和定冠词的使用是以泛指与确指为界定的，但在有些表达中，它们的用法远远地超越了这样的规定。</p><ul><li>Example：</li></ul></li></ul><ol><li>Il n’aime pas <strong>le soleil</strong>. 他不喜欢太阳。(众所周知的，唯一的)</li><li><strong>Le vélo</strong> est pratique. 自行车很方便。(指“自行车”这一类交通工具)</li><li><strong>L’homme</strong> est mortel. 人难免一死.(指所有人)</li></ol><ul><li><p>Dans certaines phrases spécifiques, les phrases qui n’utilisaient pas d’articles à l’origine ont été ajoutées avec des articles indéfinis pour exprimer des significations rhétoriques supplémentaires.<br>在某些特定的词组中，为了表达附加上的修辞意义，原先并不使用冠词的，反而要加上不定冠词。</p><ul><li>Example:</li></ul></li></ul><ol><li>La petite a <strong>une grande</strong> peur. 小女孩非常害怕。</li><li>Le garçon a <strong>une</strong> soif <strong>incroyable</strong>. 小男孩口干舌燥。</li><li>Nous avons <strong>une</strong> faim <strong>énorme</strong>. 我们饥渴难耐。</li></ol><ul><li><p>Dans l’utilisation quotidienne, l’article indéfini et l’article défini ne sont jamais opposés, ils sont souvent entrelacés pour exprimer la subordination entre les choses, la relation plus limitée ou d’autres relations logiques implicites.<br>而在日常的使用中，不定冠词和定冠词绝不是对立的，它们往往交织在一起，表达事物与事物之间的从属关系，更进一步的限定关系或是其他暗含的逻辑关系。</p><ul><li>Example:</li></ul></li></ul><ol><li>un manuel <strong>de</strong> français. 一本法语教材</li><li>le manuel de français  <strong>de</strong> ma sœur. 我姐姐的法语教材</li><li>Je veux <strong>une</strong> orange. 我想要一只橙子。</li><li>Je veux <strong>l’</strong> orange qui est là. 我想要放在那儿的橙子。</li></ol><ul><li><p>Omettre les articles avant les noms dirigés par des adverbes spécifiques ou des phrases représentant des quantités.<br>在一些由特定副词或表示数量的词组引导的名词前，省去冠词。</p><ul><li>Example:</li></ul></li></ul><ol><li>Nous avons <strong>beaucoup de</strong> vacances. 我们的假期很多。</li><li>Elle achète <strong>peu de</strong> cahiers. 她买了很少的本子。</li><li>Tu as <strong>trop de</strong> questions. 你的问题太多了。</li><li>Il a <strong>assez d’</strong> argent. 他有足够的钱。</li><li>L’enfant a<strong>un peu de</strong> monnaie. 这个孩子有一点儿钱。</li><li>J’achète <strong>deux bouteilles de</strong> vin. 我买了两瓶葡萄酒。</li></ol><ul><li><p><strong>Article condensé</strong>: désigne une nouvelle forme formée par la combinaison de la préposition à ou de et de l’article défini, qui est dérivée et différente de l’article défini.<br><strong>缩合冠词</strong>：是指介词à或de分别和定冠词组合之后形成的一种新形式，可谓是出之于定冠词，又与之有别。<br><img src="/article/a3d09103/img_1.png" alt="article condensé"></p><ul><li>Example:</li></ul></li></ul><ol><li>Elle va <strong>au</strong> cinéma. 她去看电影。(aller à)</li><li>Nathalie est <strong>à la</strong> piscine. 娜塔莉在游泳池。(être à)</li><li>Nous avons besoin <strong>des</strong> manuelsde français. 我们需要法语教材。(avoir besoin de)</li><li>Les touristes ont peur <strong>de la</strong> tempête. 旅游者都害怕暴风雨。(avoir peur de)</li><li>Mon frère s’intéresse <strong>aux</strong> mathématiques. 我哥哥对数学感兴趣。(s’intéresser à)</li></ol><ul><li><p>En français, conditions d’utilisation de certains articles :<br>Tout d’abord, l’utilisation d’articles partiels doit être un nom incommensurable ;<br>Deuxièmement, les verbes qui guident ce nom incommensurable doivent être des verbes qui peuvent exprimer le sens d’une « utilisation partielle ».<br>法语中，部分冠词使用的条件：<br>首先，使用部分冠词的必须是不可数名词；<br>其次，引导这一不可数名词的动词必须是可以表达“部分使用”之意的动词。</p></li><li><p>Example:</p></li></ul><ol><li>J’aime <strong>le</strong> café. 我喜欢咖啡。</li><li>Je veux <strong>du</strong> café． 我想喝些咖啡。</li><li>J‘aimerais <strong>du</strong> café． 我想喝些咖啡。</li></ol><h1 id="L’imperatif-命令式"><a href="#L’imperatif-命令式" class="headerlink" title="L’impératif 命令式"></a>L’impératif 命令式</h1><p>L’impératif est une forme de langage. Il existe deux formes de temps: Le présent et le passé. Ce chapitre se concentre sur le présent impératif.<br>命令式是一种语式。它有两种时态形式：现在时和过去时。本章主要研究命令式的现在时。</p><ul><li>Lorsque nous avons besoin d’exprimer des attitudes subjectives telles que la commande / interdiction / demande / encouragement, nous pouvons utiliser l’impératif.<br>当我们需要表达命令/禁止/请求/鼓励等主观态度时，可以使用命令式：</li></ul><ol><li><strong>Parlez</strong> fort! 说大声一点！(命令)</li><li>Ne <strong>fumez</strong> pas! 请勿吸烟！(请求)</li><li><strong>Donne</strong>-moi de l’eau, s’il te plaît! 请给我些水！(请求)</li><li><strong>Sois</strong> courageux! 勇敢些！(鼓励)</li></ol><ul><li><p>Le présent impératif de chaque verbe n’a que trois formes de conjugaison, à savoir le singulier de deuxième personne, le pluriel de première personne et le pluriel de deuxième personne. En général, la conjugaison de l’impératif n’utilisent que l’expression présente directe du verbe, mais les pronoms personnels doivent être supprimés.<br>每一个动词的命令式现在时都只有三种变位形式，即第二人称单数，第一人称复数，第二人称复数。通常情况下，命令式的变位只用动词的直陈式现在时，但必须删去人称代词。</p></li><li><p>Example:</p></li></ul><ol><li><strong>Prends</strong> du café! 你喝些咖啡吧！ (第二人称单数)</li><li><strong>Allons</strong> au cinéma! 我们去看电影吧！(第一人称复数)</li><li><strong>Restez</strong> tranquille! 你们安静些！(第二人称复数)</li></ol><ul><li>Il y a cependant des exceptions pour le premier groupe de verbes et pour les verbes qui se terminent en partie par <strong><em>-ir</em></strong> (par exemple, ouvrir, offrir, cueillir, souffrir, couvrir). Les formes singulières de la deuxième personne de ces verbes se terminent maintenant par - es et doivent être supprimées lorsqu’elles sont converties en formes impératives.<br>不过，对于第一组动词以及部分以 <strong><em>-ir</em></strong> 结尾的动词（例如ouvrir，offrir，cueillir，souffrir，couvrir）来说，情况有些例外。这些动词的单数第二人称直陈式现在时变为都是以-es结尾的，再转换成命令式时，必须删去词尾的s：</li></ul><ol><li>parler 👉 tu parles 👉 <strong>Parle</strong> !</li><li>ouvrir 👉 tu ouvres 👉 <strong>Ouvre</strong> !</li><li>offrir 👉 tu offres 👉 <strong>Offre</strong> !</li></ol><ul><li>Toutefois, si le verbe ci - dessus est suivi d’un sous - pronom en ou y dans l’ordre, la lettre finale s est conservée en raison de la prononciation.<br>但如果上述这些动词在命令式中后接副代词en或y的话，由于发音关系，词尾字母s则要继续保留：</li></ul><ol><li>tu y entres 👉 <strong>Entres-y</strong>!</li><li>tu en manges 👉 <strong>Manges-en</strong>!</li><li>tu em offres 👉 <strong>Offres-en</strong>!</li></ol><ul><li>Bien que le verbe aller ne fasse pas partie du premier groupe de verbes, mais se référer également aux règles correspondantes du premier groupe de verbes dans l’impératif<br>虽然动词aller不属于第一组动词，但也参照第一组动词在命令式中的相应规则：</li></ul><ol><li>tu vas 👉 <strong>Va</strong>!</li><li>tu y vas 👉 <strong>Vas-y</strong>!</li></ol><ul><li><p>Conjugaison de spécial à mémoriser.<br>需特殊记忆的变位形式:<br><img src="/article/a3d09103/img_2.png" alt="Conjugaison spécial"></p></li><li><p>Dans la pratique, il arrive que le négatif impératif prend la forme de non - finitions. La négation impérative ajoute également ne…pas après le verbe. Pas, c’est - à - dire que la négation impérative commence toujours par ne.<br>在实际使用中，有时命令式是以否定式的形式出现的。命令式否定式也是在动词的前后加上ne…pas，也就是说，命令式否定式总是以ne开头的：</p></li></ul><ol><li>Ne sors pas! 你别出去！</li><li>N’y va pas! 你别去那儿！</li><li>N’ayez pas peur! 您别怕！</li><li>Ne vendons pas notre appartement! 我们别卖房子！</li></ol><ul><li>Pour éviter la répétition, nous devons parfois utiliser des pronoms personnels.<br>Si vous avez besoin d’exprimer des commandes à une troisième personne, vous devez utiliser le virtuel。<br>为了避免重复，有时在命令式中我们需要使用一些人称代词。<br>如果需要对第三人称表达命令的话，我们需要使用虚拟式：</li></ul><ol><li>Qu’il parle! 让他说！(第三人称单数)</li><li>Qu’elles fassent vite leurs devoirs! 让她们快点做作业！(第三人称复数)</li></ol><ul><li>Express present / simple future / infinitive peut exprimer des commandes.<br>直陈式现在时/简单将来时/不定式都可以表达命令：</li></ul><ol><li>Vous finissez tout d’abord vos devoirs. 你们首先先做完作业。(直陈式现在时)</li><li>Tu achèteras du pain, s’il te plaît! 请你买些面包！(直陈式简单将来时)</li><li>Couper le jambon en morceaux. 把火腿切成小块。(动词不定式)</li></ol><h1 id="Les-verbes-pronominaux-代动词"><a href="#Les-verbes-pronominaux-代动词" class="headerlink" title="Les verbes pronominaux 代动词"></a>Les verbes pronominaux 代动词</h1><p>Les verbes pronominaux sont des verbes avec des pronoms personnels réflexifs, qui sont une sorte de verbes spéciaux.<br>代动词是指有自反人称代词的动词，是一类特殊的动词。<br>La conjugaison des verbes pronominaux implique deux parties, l’une est la modification de la partie réflexive du pronom personnel, l’autre est la conjugaison de la partie du verbe, les deux doivent faire des changements correspondants en fonction de la personne du sujet.<br>代动词的动词变位牵涉到两部分内容，一是自反人称代词部分的变化，二是动词部分的变位，两者都必须根据主语人称作出相应的变化。</p><ul><li><p>Dans l’infinitif du pronom, nous utilisons se pour exprimer le pronom personnel réflexif, tandis que dans la transposition concrète du verbe, nous changeons en fonction de la personne du sujet de différents sexes.<br>在代动词的不定式中，我们用se来表示自反人称代词，而在具体的动词变位中则根据不同性数的主语人称进行变化，即：<br><img src="/article/a3d09103/img_3.png" alt="conjugaison de pronomiaux"></p></li><li><p>Cependant, lorsque le verbe contemporain apparaît directement dans la phrase sous forme d’infinitif, le pronom réflexif se doit également correspondre aux différents sexes de la personne du sujet, tandis que la partie du verbe reste inchangée.<br>不过，当代动词以不定式的形式直接出现在句子中时，自反人称代词se也必须和主语人称进行性数配合，而动词部分则保持不变。</p></li><li><p>Example:</p></li></ul><ol><li>Je vais <strong>me reposer</strong>. 我马上要休息了。</li><li>Vous allez <strong>vous coucher</strong>. 你们马上要睡觉了。</li><li>Ils vont <strong>se lever</strong>. 他们马上要起床了。</li></ol><ul><li><p>Nous considérons toujours les pronoms personnels réflexifs et les verbes comme un tout. Par conséquent, dans la phrase négative, il est nécessaire de placer ne devant le pronom personnel réflexif et pas derrière le verbe.<br>我们始终将代动词中的自反人称代词和动词看成一个整体。因此，在否定句中，需要吧ne放在自反人称代词的前面，pas放在动词的后面。</p></li><li><p>Example:<br>Je me couche. 👉 Je <strong>ne</strong> me couche <strong>pas</strong>.</p></li><li><p>De même, dans la question de l’inversion du sujet et du prédicat, le pronom personnel réflexif est placé devant le verbe, c’est - à - dire que nous considérons le pronom personnel réflexif comme faisant partie du verbe, puis nous effectuons l’inversion du sujet et du prédicat sur cette base.<br>同样，在主谓倒置式的疑问句中，自反人称代词放在动词的前面，也就是说，我们将自反人称代词视为动词的一部分，然后再在此基础上进行主谓倒置。</p></li><li><p>Example:<br>Tu te laves. 你洗澡。 👉 Te laves-tu? 你洗澡吗？</p></li><li><p>Derrière le verbe, et le pronom personnel de la deuxième personne singulière te doit être réécrit dans sa forme de relecture toi. Dans la forme de l’ordre de négation, le pronom personnel réflexif est toujours placé devant le verbe, et il n’y a pas de changement de forme.<br>而在肯定命令式中，自反人称代词放在动词后面，单数第二人称的人称代词te则要改写成它的重读形式toi。再否定命令形式中，自反人称代词仍放在动词的前面，且没有任何形式上的变化。</p></li><li><p>Example:</p></li></ul><ol><li>Lève-<strong>toi</strong>! 你起床！</li><li>Ne <strong>te</strong> lève pas! 你别起床！</li></ol><ul><li>Les pronoms eux - mêmes peuvent être divisés en quatre catégories.<br>代动词本身又可以分为四类。</li></ul><ol><li>Les <strong>sens réflexif</strong> verbes pronominaux indique que l’action est appliquée à l’acteur lui - même, c’est - à - dire au sens réflexif du sujet. À ce stade, le pronom personnel réflexif dans le pronom peut être l’objet direct du verbe ou l’objet indirect du verbe.<br><strong>自反意义</strong>代动词表示动作施加于施动者本身，也就是自反于主语的意思。这时，代动词中的自反人称代词可以是动词的直接宾语，也可以是动词的间接宾语。</li></ol><ul><li>Example:<br>Je <strong>me</strong> couche. 我睡觉。(me为直接宾语)<br>Il <strong>se</strong> brosse les dents. 他刷牙。(se时间接宾语，le dents为动词brosser的直接宾语)<br>判断自反意义代动词中的直接宾语或间接宾语的关键是看动词后面有没有宾语，如果有，这个宾语就是直接宾语，自反人称代词则为间接宾语；倘若没有，自反人称代词则为直接宾语。</li></ul><ol><li>Les <strong>sens mutuel</strong> verbes pronominaux indique que l’action se produit entre les sujets. Nous pouvons donc juger que le sujet du verbe pronom de sens mutuel est pluriel, ou que le pronom personnel est le pronom on qui représente le concept pluriel. De même, les pronoms personnels réflexifs dans les pronoms de sens mutuel peuvent être soit des objets directs, soit des objets indirects.<br><strong>相互意义</strong>代动词表示动作发生在主语之间。我们由此可以判断出，相互意义代动词的主语复数的，或者是表示复数概念的人称代词on。同样，相互意义代动词中的自反人称代词既可以是直接宾语，也可以是间接宾语。</li></ol><ul><li>Example:<br>Vous <strong>vous</strong> regardez. 你们四目相对。(vous为直接宾语)<br>Ils <strong>s</strong>‘écrivent. 他们相互写信。(se是间接宾语)<br>判断相互意义代动词中的直接宾语或间接宾语的关键是看动词本身亦不敢改后接直接宾语还是间接宾语。在以上的两个例句中，动词regarder的搭配是regarder quelqu‘un，因此，剧中的vous为直接宾语。而动词écrire à  quelqu’un,所以，句子中的se为间接宾语。</li></ul><ol><li>Les <strong>sens passif</strong> verbes pronominaux indique que l’action est passive, ce qui équivaut à la voix passive.<br><strong>被动意义</strong>代动词表示动作是被动的，相当于被动语态。</li></ol><ul><li>Example:<br>La fenêtre <strong>se</strong> ferme. 窗关上了。</li></ul><ol><li>Les <strong>sens absolu</strong> verbes pronominaux personnels réflexifs dans les pronoms sont inhérents aux pronoms et n’expriment aucun sens grammatical.<br><strong>绝对意义</strong>代动词中的自反人称代词是代动词所固有的，不表达任何语法上的意义。</li></ol><ul><li>Example:<br>Il <strong>s</strong>‘en va. 他走了。</li></ul><h1 id="Pronoms-personnels-complements-d’objet-indirect-简介宾语人称代词"><a href="#Pronoms-personnels-complements-d’objet-indirect-简介宾语人称代词" class="headerlink" title="Pronoms personnels compléments d’objet indirect -, 简介宾语人称代词"></a>Pronoms personnels compléments d’objet indirect -, 简介宾语人称代词</h1><ol><li>间接宾语人称代词的形式<br>| 人称 | 单数形式 | 复数形式 |<br>|:——-:|:——-:|:——-:|<br>| 第一人称 | me(m‘) | nous |<br>| 第二人称 | te(t’) | vous |<br>| 第三人称 | lui | leur |</li><li>主要用法<br>间接宾语热诚代词一般用来代替介词à及其引导的指人的间接宾语，一般置于相关<strong>动词之前</strong>。</li></ol><ul><li>Example:<br>1) Paul <strong>nous</strong> donne ses livres. (nous = à nous) 保罗把他的书给了我们。<br>2) Est-ce que tu peux <strong>m’</strong> apporter du thé, s’il te plaît? (m’ = à moi) 你能给我带点茶来吗？</li></ul><p>注意：间接宾语人称代词不可以用来代替带此时动词的间接宾语，以及penser à等短语中的间接宾语：在以上情况中，须使用à+重读人称代词作为间接宾语。<br>1) Li Ming a recentré des problèmes, donc il s’adresse à moi.<br>2) - À qui penses-tu? À tes parents ? 你在香水？你的父母吗？</p><ul><li>Oui, je pense à eux. 是的，我在想念他们。</li></ul><ol><li>命令式肯定句中的间接宾语人称代词<br>在<strong>命令式肯定句</strong>中，间接宾语人称代词置于<strong>动词之后</strong>，并使用连字符-引导；<strong>如果间接宾语人称代词为me或te，则应使用重读形式moi或toi</strong>。</li></ol><ul><li>Example:<br>1) Envoyez-lui cette le titre ! 把这封信寄给他.<br>2) Passe-moi le journal ! 把报纸递给我！</li></ul><h1 id="C’est…qui-C’est…que-强调句型"><a href="#C’est…qui-C’est…que-强调句型" class="headerlink" title="C’est…qui / C’est…que - 强调句型"></a>C’est…qui / C’est…que - 强调句型</h1><p>当需要突出强调句子中的某一成分时，可采用强调句型c’est…qui或c’est…que，以唤起对方的注意；需要注意的是，该句型不可强调谓语。</p><ol><li>强调主语用<strong>c’est…qui</strong>，句中动词需要与主语进行配合；在口语表达中，c‘est可以代替ce sont.</li></ol><ul><li>Example:<br>1）Olivia a donné des renseignements à Li Ming. 奥维莉雅给黎明提供了信息。<br>👉 <strong>C’est</strong> Olivia <strong>qui</strong> a donné des renseignements à Li Ming.<br>是奥维莉雅给李明提供了信息。<br>2）J’ai besoin d’ouvrir un compte bancaire. 我需要开一个银行账户。<br>👉 <strong>C’est</strong> moi <strong>qui</strong> ai besoin d’ouvrir un compte bancaire.<br>是我需要开银行账户。<br>3）Ces chemises me plaisent beaucoup. 我喜欢这些衬衣。<br>👉 <strong>Ce sont</strong> ces chemises <strong>qui</strong> me plaisent beaucoup.<br>我喜欢的正是这些衬衣。<br>注意：主语人称代词在C’est…qui结构中，应变为重读人称代词形式。</li></ul><ol><li>强调直接宾语、间接宾语、状语、表语用<strong>c’est…que</strong>。</li></ol><ul><li>Example:<br>1）Nous avons rencontré un célèbre médecin hier. 我们昨天遇见了一个著名的医生。<br>👉 <strong>C’est</strong> un célèbre médecin <strong>que</strong> nous avons rencontré hier.<br>我们昨天遇见的是一个著名的医生。<br>2）Elles sont partis en vacances avec leurs copines. 他们跟朋友出发去度假了。<br>👉 <strong>C’est</strong> avec leurs copines <strong>qu</strong>‘elles sont partis en vacances.<br>他们是跟朋友们出发去度假的。<br>3）Nous ne sommes pas venus, parce qu’il a plu.<br>我们没来，因为下雨了。<br>👉 <strong>C’est</strong> parce qu’il a plu <strong>que</strong> nous ne sommes pas venus.<br>是因为下雨了我们才没有来。<br>4）Pour ouvrir un compte bancaire, Li Ming s’adresse à Olivia. 为了开银行账户，李明求助于奥莉薇娅。<br>👉 Pour ouvrir un compte bancaire, <strong>C’est</strong> à Olivia <strong>que</strong> Li Ming s’adresse.<br>为了开银行账户，李明是奥莉薇娅求助的。</li></ul><h1 id="Pronoms-personnels-comportement-d’objet-direct-直接宾语人称代词"><a href="#Pronoms-personnels-comportement-d’objet-direct-直接宾语人称代词" class="headerlink" title="Pronoms personnels comportement d’objet direct - 直接宾语人称代词"></a>Pronoms personnels comportement d’objet direct - 直接宾语人称代词</h1><ol><li>直接宾语人称代词的形式<br>| 人称 | 单数形式 | 复数形式 |<br>|:——-:|:——-:|:——-:|<br>| 第一人称 | me(m‘) | nous |<br>| 第二人称 | te(t’) | vous |<br>| 第三人称 | le/la(l’) | les |</li><li>主要用法<br>直接宾语人称代词一般用来代替指人或事物的直接宾语。与间接宾语人称代词相同，直接宾语人称代词一般置于相关<strong>动词之前</strong>。</li></ol><ul><li>Example:<br>1）Je <strong>vous</strong> aime. 我爱你们。<br>2）Quelles belles fleurs! Je vais <strong>les</strong> donner à maman. 多美的花！我要把他们送给妈妈。<br>3）Hier, il <strong>m</strong>‘a rencontré dans la rue. 昨天，他在街上碰见了我。</li></ul><ol><li>命令式在肯定句中的直接宾语人称代词<br>在<strong>命令式肯定句</strong>中，直接宾语人称代词置于<strong>动词之后</strong>，并使用连字符“-”引导；<strong>如果直接宾语人称代词为me或te，则应使用其重读形式moi或toi</strong>。</li></ol><ul><li>Example:<br>1）Regarde-moi! 看着我！<br>2）Suivez-la! 跟着她！</li></ul><h1 id="Accord-du-participe-passe-dans-le-temps-compose-复合时态中过去分词的配合1-以-avoir-为助动词的复合时态中，过去分词的配合"><a href="#Accord-du-participe-passe-dans-le-temps-compose-复合时态中过去分词的配合1-以-avoir-为助动词的复合时态中，过去分词的配合" class="headerlink" title="Accord du participe passé dans le temps composé 复合时态中过去分词的配合1. 以 avoir 为助动词的复合时态中，过去分词的配合"></a>Accord du participe passé dans le temps composé 复合时态中过去分词的配合1. 以 avoir 为助动词的复合时态中，过去分词的配合</h1><p>在以 avoir 为助动词的复合时态中，过去分词通常不变；但是当直接宾语位于 avoir 之前时，过去分词需要与前置的直接宾语进行性数配合。<br>1） Combien de livres as-tu lus ? 你读了几本书？<br>2） C’est la leçon 5 que nous avons apprise hier. 我们昨天学的是第五课。<br>3） Ces formulaires, je les ai déjà remplis. 这些表格，我已经填了。</p><ol><li>以 être 为助动词的复合时态中，过去分词的配合<br>在以 être 为助动词的复合时态中，过去分词通常须与主语进行性数配合；但当代词式动词中的自反代词 se 是动词的间接宾语时，过去分词保持不变。<br>1） Elle s’est lavée en 20 minutes. 她洗澡用了 20 分钟。<br>Elle s’est lavé les mains avant le repas. 她饭前洗了手。<br>2） Elles se sont rencontrés dans la rue, mais elles ne se sont pas dit bonjour.<br>她们在街上相遇了，但没有打招呼。</li><li>表示位置移动的动词，过去分词的配合有些表示位移的动词既可使用 avoir 做助动词，又可使用être 做助动词。当动词有直接宾语时，需要使用 avoir 做助动词，此时过去分词不与主语配合；当动词没有直接宾语时，需要使用être 做助动词，此时过去分词与主语配合。<br>1） Elle est montée au deuxième étage. 她上了三楼。<br>2） Elle a monté une chaise au deuxième étage. 她把一把椅子搬到了三楼。<br>3） Elle est sortie de bonne heure. 她一大早就出去了。<br>4） Elle a sorti les vêtements de bonne heure. 她一大早就把衣服拿出来了。</li></ol><h1 id="la-voix-passive-被动态"><a href="#la-voix-passive-被动态" class="headerlink" title="la voix passive 被动态"></a>la voix passive 被动态</h1><ol><li><p>形式<br>法语有两大语态：主动态（la voix active）和被动态（la voix passive）。当句子的主语是动作的施动者时，该句子为主动态；主语是动作的承受者时，该句为被动态。被动态的构成方式如下：<br>être+（直接及物）动词的过去分词（+par/de+施动者补语），如：<br>1) Le contrat est signé par Jacques.<br>2) Paris est traversé par la Seine.</p></li><li><p>过去分词的配合<br>在被动态句子，过去分词必须与主语在性、数上进行配合，如：<br>1) Cette lettre est écrite par son ami.<br>2) Les étudiants étrangers sont reçus par ce prof.</p></li><li><p>时态<br>被动态的时态由助动词être的时态变化展现，如：<br>1) La maison a <strong>été</strong> construire par mon grand-père. （直陈式复合过去时）<br>2) La tarte aux pommes <strong>est</strong> préparée par une pâtissière très connue. （直陈式现在时）<br>3) Votre demande ne peut pas <strong>être</strong> acceptée par une notre banque. （不定式）</p></li><li><p>施动者补语<br>1) 大部分情况下，被动态的施动者补语由介词par引出。<br>2) 如果被动态的动词表示状态、认知、情感等，则施动者补语由介词de引出。<br>3) 当施动者补语未知或不需要强调时，可将其省略。</p></li></ol><h1 id="Simples-时态"><a href="#Simples-时态" class="headerlink" title="Simples 时态"></a>Simples 时态</h1><h2 id="Le-passe-compose-直陈式复合过去时"><a href="#Le-passe-compose-直陈式复合过去时" class="headerlink" title="Le passé composé 直陈式复合过去时"></a>Le passé composé 直陈式复合过去时</h2><p>Le passé composé indique les actions qui se sont produites et qui ont été accomplies au cours d’une période définie dans le passé.<br>复合过去时表示过去起止时间明确的某一段时间内发生并完成的动作。<br>Composition : la forme expressive du verbe auxiliaire avoir ou celui - ci est maintenant + le participant passé du verbe.<br>构成：助动词avoir或être的直陈式现在时+动词的过去分词。</p><ul><li>La formation du participant passé<br>过去分词的构成：<br>(1). 第一组动词去掉词尾的-er加上-é:&lt;/br&gt; regarder 👉 regardé<br>(2). 第二组动词去掉词尾的-ir加上-i:&lt;/br&gt; finir 👉 fini<br>(3). 常用的不规则动词的过去分词&lt;/br&gt;</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">avoir 👉 eu</td><td style="text-align:center">vouloir 👉 voulu</td><td style="text-align:center">voir 👉 vu</td></tr><tr><td style="text-align:center">être 👉 été</td><td style="text-align:center">prendre 👉 pris</td><td style="text-align:center">pouvoir 👉 pu</td></tr><tr><td style="text-align:center">faire 👉 fait</td><td style="text-align:center">boire 👉 bu</td><td style="text-align:center">pleuvoir 👉 plu</td></tr><tr><td style="text-align:center">dire 👉 dit</td><td style="text-align:center">lire 👉 lu</td><td style="text-align:center">recevoir 👉 reçu</td></tr><tr><td style="text-align:center">devoir 👉 dû</td><td style="text-align:center">tenir 👉 tenu</td><td style="text-align:center">offrir 👉 offert</td></tr><tr><td style="text-align:center">savoir 👉 su</td><td style="text-align:center">connaître 👉 connu</td><td style="text-align:center">ouvrir 👉 ouvert</td></tr></tbody></table></div><ul><li>Verbes avec avoir comme auxiliaire.<br>以avoir为助动词的动词：<br>La plupart des verbes utilisent avoir comme auxiliaire.<br>大部分动词都使用avoir作为助动词。</li></ul><ul><li><p>Verbes avec être comme auxiliaire.<br>以être为助动词的动词：<br>(1). Verbe transitionnel représentant un déplacement de position ou un changement d’état.<br>表示位置移动或状态变化的及物动词：<br>aller, venir, entrer, sortir, monter, descendre, arriver, partir, passer, rester, tomber, mourir, naître, apparaître(包括他们的派生词：devenir, revenir, rentrer…)<br><strong>Note</strong>: certains de ces verbes peuvent également être utilisés comme verbes transitifs, suivis d’objets directs, et maintenant utiliser avoir comme verbes auxiliaires.<br><strong>注意</strong>：这些动词中有些也可以作及物动词，后跟直接宾语，此时用avoir作助动词：</p></li><li><p>Example:<br>Je suis montré en haut de la tour Eiffel. 我登上埃菲尔铁塔的高处。<br>Le garçon de l’hôtel amontre les valises dans la chambre. 旅馆的男侍将行李送到了房间。<br>Béatrice est passée chaz moi à 8 h. 贝亚特莉丝八点来过我家。<br>On a passé toute la matinée à l’hôpital. 我们在医院度过了整整一个上午。</p><p>(2). Tous les pronoms.所有的代动词：<br>se laver, s’assoir, se souvenir…</p></li><li><p>Example:<br><img src="/article/a3d09103/img_4.png" alt="examples de les verbes pronominaux"></p></li></ul><p><strong>Note</strong><br><strong>注意</strong>：</p><ul><li>La phrase négative est placée des deux côtés du verbe auxiliaire dans la phrase négative.<br>否定句中否定短语置于助动词两边：<br>Elle <strong>n’a pas réussi</strong> ses examens. 她没有顺利通过考试。<br>Je <strong>ne suis pas allé</strong> à l’université hier. 昨天我没有去上大学。<br>Je <strong>ne me suis pas réveillé</strong> à 7 heures ce matin. 今天早晨7点钟我还没有睡醒。</li><li>Verbes auxiliaires et inversion du sujet dans les phrases interrogatives.<br>疑问句中助动词与主语倒装：<br>As-tu trouvé test clés ? 你找到钥匙了吗？<br>À quelle heure êtes-vous arrivé ? 您几点钟到的？<br>Quand s’est-elle couchée ? 她什么时候上床休息的？</li></ul><h2 id="imparfait-未完成过去时"><a href="#imparfait-未完成过去时" class="headerlink" title="imparfait 未完成过去时"></a>imparfait 未完成过去时</h2><ol><li>构成<br>动词直陈式现在时第一人称复数形式去掉此为-ons，再按人称je，tu，il/elle，nous，vous，ils/elles顺序加：-ais, -ais, -ait, -ions, -iez, -aient</li></ol><ul><li>Example:<br><img src="/article/a3d09103/img_5.png" alt="exmaples"><br>注意：1）être的未完成过去时为特殊形式</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">j’étais</td><td style="text-align:center">nous étions</td></tr><tr><td style="text-align:center">tu étais</td><td style="text-align:center">vous étiez</td></tr><tr><td style="text-align:center">il/elle était</td><td style="text-align:center">ils/elles étaient</td></tr></tbody></table></div><p>2）下列动词未完成过去时的变化。</p><div class="table-container"><table><thead><tr><th style="text-align:center">commencer</th><th style="text-align:center">je commençais</th></tr></thead><tbody><tr><td style="text-align:center">manger</td><td style="text-align:center">je mangeais</td></tr><tr><td style="text-align:center">étudier</td><td style="text-align:center">j’étudiais</td></tr></tbody></table></div><ol><li>用法<br>1）表示过去的状态，描写过去事件的背景。<br>a. Hier, il faisait froid. Le ciel était gris. Il y avait peu de monde dans la rue.<br>昨天，天气很冷，天空阴沉，街上几乎没有人。<br>b. Avant, il habitait en ville.<br>以前，他住在城里。<br>2） 表示在过去一段时间里，习惯或重复性的动作。<br>a. Pendant les vacances, il se levait toujours à 8 heures du matin.<br>在假期中，他总是早上 8 点起床。<br>b. Avant, sa soeur travaillait à Paris. Il allait la voir deux fois par mois.<br>过去，他的姐姐在巴黎工作，他每月去看她两次。<br>c. Il sortait souvent avec ses copains quand il était au lycée.<br>他上高中时，经常与同伴出去玩。<br>3） 在复合句中，与复合过去时配合使用。未完成过去时表示在过去时间中持续进行的动作，而复合<br>过去时表示过去一次性发生并完成的动作。<br>a. Il est arrivé pendant que j’écoutais de la musique.<br>在我听音乐的时候，他来了。<br>b. Il pleuvait quand je me suis réveillé.<br>当我醒来的时候，正在下雨。</li></ol><h2 id="Le-futur-simple-简单将来时"><a href="#Le-futur-simple-简单将来时" class="headerlink" title="Le futur simple 简单将来时"></a>Le futur simple 简单将来时</h2><ol><li><p>形式</p><p>直陈式简单将来时的变为通常是在动词不定式后，按照人称顺序加上词尾-ai, -as, -a, -ons, -ez, -ont构成。如果动词不定式以e结尾，则需去掉e，然后再加上上述后缀。如：</p><p>|      第一组动词      |    第二组动词     |     第三组动词      |<br>| :—————————: | :———————-: | :————————-: |<br>|       arriver        |       finir       |       prendre       |<br>|     j’arriverai      |    je finirai     |     je prendrai     |<br>|     tu arriveras     |    tu finiras     |     tu prendras     |<br>|   il/elle arrivera   |  il/elle finira   |   il/elle prendra   |<br>|   nous arriverons    |   nous finirons   |   nous prendrons    |<br>|    vous arriverez    |   vous finirez    |    vous prendrez    |<br>| ils/elles arriveront | is/elles finiront | ils/elles prendront |</p><p>1）第一组动词变位的特殊形式</p><p>| 动词不定式 | 第一人称单数 |   第一人称复数   |    其他变位方式相同的动词    |<br>| :————: | :—————: | :———————: | :—————————————: |<br>|   amener   |  j’amènerai  |  nous amènerons  | mener, lever, acheter, geler |<br>|  appeier   | j’appellerai | nous appellerons | jeter, rappeler, renouveler  |<br>|  essayer   | j’essaierai  | nous essaierons  |  payer, nettoyer, employer   |<br>|  envoyer   |  j’enverrai  |  nous enverrons  |           renvoyer           |</p><p>2）第三组常见动词变位的特殊形式</p><p>| 动词不定式 |          第一人称单数           |                 第一人称复数                 |<br>| :————: | :——————————————-: | :—————————————————————: |<br>|   aller    |             j‘irai              |                  nous irons                  |<br>|    être    |            je serai             |                 nous serons                  |<br>|   faire    |            je ferai             |                 nous ferons                  |<br>|   avoir    |             j’aurai             |                 nous aurons                  |<br>|   savoir   |            je saurai            |                 nous saurons                 |<br>|   tenir    |           je tiendrai           |                nous tiendrons                |<br>|   venir    |           je viendrai           |                nous viendons                 |<br>|   devoir   |            je devrai            |                 nous devrons                 |<br>|  recevoir  |           je recevrai           |                nous recevrons                |<br>|   courir   |           je courrai            |                nous courrons                 |<br>|  pouvoir   |           je pourrai            |                nous pourrons                 |<br>|    voir    |            je verrai            |                 nous verrons                 |<br>|  vouloir   |           je voudrai            |                nous voudrons                 |<br>| s’asseoir  | je m’assiérai&lt;/br&gt;je m’assoirai | nous nous assiérons &lt;/br&gt;nous nous assoirons |<br>|   valoir   |           je vaudrai            |                nous vaudrons                 |</p></li><li><p>用法</p><p>简单将来时一般表示将来要发生或可能要发生的动作或状态，如：</p><p>1）Une réunion de rentrée aura lieu après-demain à 14 heurtes. </p><p>开学大会将于后天下午2点召开</p><p>2）Vous devrez passer un test de niveau de français dans 3 jours.</p><p>你们3天后需要参加法语水平测试。</p><p>3）Pierre et Olivia feront un voyage ensemble le mois prochain.</p><p>Pierre和Olivia下个月要一起去旅行。</p></li></ol><h2 id="Le-conditionnel-present-条件式现在时"><a href="#Le-conditionnel-present-条件式现在时" class="headerlink" title="Le conditionnel présent  条件式现在时"></a>Le conditionnel présent  条件式现在时</h2><ol><li><p>形式</p><p>条件式现在时的变位由直陈式简单将来时的词根加上直陈式未完成过去时的词尾构成。如：</p><p>|       第一组动词       | 第二组动词 | 第三组动词 |<br>| :——————————: | :————: | :————: |<br>|        arriver         |   finir    |   aller    |<br>|      j’arriverais      |            |            |<br>|     tu arriverais      |            |            |<br>|   il/elle arriverait   |            |            |<br>|    nous arriveriez     |            |            |<br>|    vous arriveriez     |            |            |<br>| ils/elles arriveraient |            |            |</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 法语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网络攻防]简单的DLL注入实践-干爆扫雷</title>
      <link href="/article/b0ee38f7/"/>
      <url>/article/b0ee38f7/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨：DLL注入技术与网络安全"><a href="#相关叨叨：DLL注入技术与网络安全" class="headerlink" title="相关叨叨：DLL注入技术与网络安全"></a>相关叨叨：DLL注入技术与网络安全</h1><p>对于网络安全的课题，攻与防是同等地位的重要，可攻可受（？）是每一个学习网络安全的~冤种~技术人所应同时具备的能力。<br>而DLL注入技术，一般来讲是向一个正在运行的进程插入/注入代码的过程，可以被正常软件用来添加/扩展其他程序，调试或逆向工程的功能性；该技术也常被恶意软件以多种方式利用。这意味着从安全角度来说，了解DLL注入的工作原理是十分必要的。<br><img src="https://pic1.zhimg.com/80/v2-e7797fe6b55556041e4fc1154691b584_720w.jpg" alt="DLL注入原理与流程（图源网）"></p><h2 id="实验目标与内容"><a href="#实验目标与内容" class="headerlink" title="实验目标与内容"></a>实验目标与内容</h2><p>利用DLL注入，实现扫雷一件通关辅助：</p><ol><li>找到地雷数组所在内存位置；</li><li>数组中的各个值代表的含义；</li><li>实现辅助</li></ol><p>实验拟题来自于 <strong>中国海洋大学 网络攻防先导实践 lab03：简单的DLL注入实践</strong> <em>-by 曲海鹏 等</em></p><h1 id="实验依赖工具"><a href="#实验依赖工具" class="headerlink" title="实验依赖工具"></a>实验依赖工具</h1><h2 id="Windows-消息传递机制"><a href="#Windows-消息传递机制" class="headerlink" title="Windows 消息传递机制"></a>Windows 消息传递机制</h2><p>所谓的Windows消息传递机制就类似于生活中的物流公司。当寄件人（例如鼠标、键盘）将包裹（消息）交给物流公司（Windows系统）时，物流公司（Windows系统）会进行整理并且派发（整理及派发主要由消息循环完成），交给相应的快递员（窗口过程）来处理。快递员（窗口过程）拿到包裹（消息）后则有多种方式来处理，如立马交给收件人，等一天交给收件人，或转交给其他快递派发，这就需要在窗口过程中用switch/case来区分。<br><img src="/article/b0ee38f7/img.png" alt="Windows消息传递机制示意"><br><img src="/article/b0ee38f7/img_1.png" alt="WIndows消息传递的回调与响应函数"><br>对于通过DLL进行的消息劫持与注入，则需要利用Windows消息传递机制来完成，下述为Windows消息事件的介绍及获取/模拟：</p><h3 id="Windows消息来源相关知识部分应用"><a href="#Windows消息来源相关知识部分应用" class="headerlink" title="Windows消息来源相关知识部分应用"></a>Windows消息来源相关知识部分应用</h3><p>消息可以由系统或者应用程序产生。系统在发生输入事件时产生消息。举个例子, 当用户敲键, 移动鼠标或者单击控件。系统也产生消息以响应由应用程序带来的变化, 比如应用程序改变系统字体，改变窗体大小。应用程序可以产生消息使窗体执行任务，或者与其他应用程序中的窗口通讯。</p><ol><li><p>Windows中，消息使用统一的结构体（MSG）来存放信息，其中message表明消息的具体的类型，<br>&lt;/br&gt;而wParam，lParam是其最灵活的两个变量，为不同的消息类型时，存放数据的含义也不一样。<br>time表示产生消息的时间，pt表示产生消息时鼠标的位置。<br>Windows中消息MSG声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMsg</span><br><span class="line">&#123;</span><br><span class="line">HWND hwnd; // 接受该消息的窗口句柄，告诉操作系统，应该把消息发生给哪个应用 哪个窗口</span><br><span class="line">UINT message; // 消息常量标识符，也就是我们通常所说的消息号</span><br><span class="line">WPARAM wParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">LPARAM lParam; // 32位消息的特定附加信息，确切含义依赖于消息值</span><br><span class="line">DWORD time; // 消息创建时的时间</span><br><span class="line">POINT pt; // 消息创建时的鼠标/光标在屏幕坐标系中的位置</span><br><span class="line">&#125;MSG;</span><br></pre></td></tr></table></figure></li><li><p>消息类型<br><img src="/article/b0ee38f7/img_2.png" alt="消息类型"><br>(1) 窗口消息：即与窗口的内部运作有关的消息，如创建窗口，绘制窗口，销毁窗口等。<br>可以是一般的窗口，也可以是MainFrame,Dialog,控件等。<br>如：WM_CREATE, WM_PAINT, WM_MOUSEMOVE, WM_CTLCOLOR, WM_HSCROLL等.&lt;/br&gt;<br>(2) 当用户从菜单选中一个命令项目、按下一个快捷键或者点击工具栏上的一个按钮，都将发送WM_COMMAND命令消息。<br>LOWORD(wParam)表示菜单项，工具栏按钮或控件的ID；如果是控件, HIWORD(wParam)表示控件消息类型。&lt;/br&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LOWORD(l) ((WORD)(l))</span><br><span class="line">#define HIWORD(l) ((WORD)(((DWORD)(l) &gt;&gt; 16) &amp; 0xFFFF))</span><br></pre></td></tr></table></figure><p>(3) 随着控件的种类越来越多，越来越复杂（如列表控件、树控件等），仅仅将wParam，lParam将视为一个32位无符号整数，已经装不下太多信息了。<br>为了给父窗口发送更多的信息，微软定义了一个新的WM_NOTIFY消息来扩展WM_COMMAND消息。<br>WM_NOTIFY消息仍然使用MSG消息结构，只是此时wParam为控件ID，lParam为一个NMHDR指针，<br>不同的控件可以按照规则对NMHDR进行扩充，因此WM_NOTIFY消息传送的信息量可以相当的大。<br>注：Window 9x 版及以后的新控件通告消息不再通过WM_COMMAND 传送，而是通过WM_NOTIFY 传送，<br>但是老控件的通告消息， 比如CBN_SELCHANGE 还是通过WM_COMMAND 消息发送。&lt;/br&gt;<br>(4) windwos也允许程序员定义自己的消息，使用SendMessage或PostMessage来发送消息。&lt;/br&gt;</p></li><li><p>消息队列(Message Queues)<br>Windows中有两种类型的消息队列<br>(1) 系统消息队列(System Message Queue)<br>这是一个系统唯一的Queue，设备驱动(mouse, keyboard)会把操作输入转化成消息存在系统队列中，然后系统会把此消息放到目标窗口所在的线程的消息队列(thread-specific message queue)中等待处理.&lt;/br&gt;<br>(2) 线程消息队列(Thread-specific Message Queue)<br>每一个GUI线程都会维护这样一个线程消息队列。(这个队列只有在线程调用GDI函数时才会创建，默认不创建)。然后线程消息队列中的消息会被送到相应的窗口过程(WndProc)处理.<br>注意： 线程消息队列中WM_PAINT，WM_TIMER只有在Queue中没有其他消息的时候才会被处理，WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。&lt;/br&gt;</p></li><li><p>队列消息(Queued Messages)和非队列消息(Non-Queued Messages)<br>(1) 队列消息(Queued Messages)<br>消息会先保存在消息队列中，消息循环会从此队列中取出消息并分发到各窗口处理<br>如：WM_PAINT，WM_TIMER，WM_CREATE，WM_QUIT，以及鼠标，键盘消息等。<br>其中，WM_PAINT，WM_TIMER只有在队列中没有其他消息的时候才会被处理， WM_PAINT消息还会被合并以提高效率。其他所有消息以先进先出（FIFO）的方式被处理。&lt;/br&gt;<br>(2) 非队列消息(NonQueued Messages)<br>消息会绕过系统消息队列和线程消息队列直接发送到窗口过程被处理 如： WM_ACTIVATE, WM_SETFOCUS, WM_SETCURSOR， WM_WINDOWPOSCHANGED<br>注意: postMessage发送的消息是队列消息，它会把消息Post到消息队列中； SendMessage发送的消息是非队列消息， 被直接送到窗口过程处理.&lt;/br&gt;</p></li><li><p>窗体函数（WindowProc）<br><img src="/article/b0ee38f7/img_3.png" alt="应用程序消息循环（messager loop）"><br>Windows 应用程序创建的每个窗口都在系统核心注册一个相应的窗口函数，窗口函数程序代码形式上是一个巨大的switch 语句，用以处理由消息循环发送到该窗口的消息，窗口函数由Windows 采用消息驱动的形式直接调用，而不是由应用程序显示调用的，窗口函数处理完消息后又将控制权返回给Windows。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//而窗体负责响应消息的函数称为“窗体过程（Window Procedure）”，窗体过程是一个函数，每个窗体一个，它大致拥有以下的“模样”（C++代码）：</span><br><span class="line">LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line"> &#123;</span><br><span class="line">     //……</span><br><span class="line">     switch (uMsg) //依据消息标识符进行分类处理</span><br><span class="line">     &#123;</span><br><span class="line">     case WM_CREATE:</span><br><span class="line">         // 初始化窗体.</span><br><span class="line">         return 0;</span><br><span class="line">     case WM_PAINT:</span><br><span class="line">         // 绘制窗体</span><br><span class="line">         return 0;</span><br><span class="line">         //</span><br><span class="line">         //处理其他消息</span><br><span class="line">         //</span><br><span class="line">     default:</span><br><span class="line">         //如果窗体没有定义处理此种消息的代码，则转去调用系统默认的消息处理函数</span><br><span class="line">         return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> //可以看到，“窗体过程”不过就是一个多分支语句罢了，在这个语句中，窗体对不同类型的消息进行处理。</span><br></pre></td></tr></table></figure></li></ol><p>以上内容来自<a href="https://blog.51cto.com/u_15080034/4353635"><strong>(整理)window 消息传递机制</strong></a><br>~事实上，上述内容我也看的懵懂，大概当个了解~</p><h2 id="Spy"><a href="#Spy" class="headerlink" title="Spy++"></a>Spy++</h2><p>Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。<br><img src="/article/b0ee38f7/img_4.png" alt="介个就是spyxx.exe"><br><img src="https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/exp/w=500/sign=7ba3254179cb0a4685228b395b62f63e/64380cd7912397ddd6145fbf5b82b2b7d0a28718.jpg" alt="spyxx界面"></p><p>后续在本实验的应用上，我拿这个用来在创建模拟点击事件时的定位窗口坐标。</p><h2 id="Cheat-Engine"><a href="#Cheat-Engine" class="headerlink" title="Cheat Engine"></a>Cheat Engine</h2><p>Cheat Engine是一款专注于游戏的修改器。它可以用来扫描游戏中的内存，并允许修改它们。它还附带了调试器、反汇编器、汇编器、变速器、作弊器生成、Direct3D操作工具、系统检查工具等。<br><img src="/article/b0ee38f7/img_5.png" alt="这个是Cheat Engine"><br><img src="/article/b0ee38f7/img_6.png" alt="CE界面"></p><p>针对游戏的修改器/辅助器/或你叫它什么都好，总之要想达到作弊的效果，最重要的当然是要分析破译游戏内存数据所代表的含义，并能精准定位所要实现修改的内存存放地址，因此在后续的操作中，Cheat Engine扮演了十分重要的角色。</p><h2 id="Xenos"><a href="#Xenos" class="headerlink" title="Xenos"></a>Xenos</h2><p>《Xenos》是2007年池泽辰也执导的悬疑片，由海东键、一戸奈美、堀田ゆい夏等主演。<br><img src="/article/b0ee38f7/img_7.png" alt="Xenos"></p><font size="3">...当然，不可能是这个"Xenos"</font><p>我们所要介绍的Xenos，是用来进行DLL注入的软件，长这样：<br><img src="/article/b0ee38f7/img_8.png" alt="这个才是注入器Xenos"><br><img src="/article/b0ee38f7/img_9.png" alt="Xenos界面"></p><p>这个工具，则是帮助我们将写好的DLL类型文件对程序进行注入。</p><p>以上，则是本次实验/本类型任务的基本搭建环境和操作工具，接下来正式进入对本实验的分析与实践。</p><h1 id="实验分析：让俺看看扫雷背后都有啥"><a href="#实验分析：让俺看看扫雷背后都有啥" class="headerlink" title="实验分析：让俺看看扫雷背后都有啥"></a>实验分析：让俺看看扫雷背后都有啥</h1><p>摆烂了将近一个月终于开始继续</p><h2 id="WinMine-XP-exe-游戏规则分析"><a href="#WinMine-XP-exe-游戏规则分析" class="headerlink" title="WinMine_XP.exe 游戏规则分析"></a>WinMine_XP.exe 游戏规则分析</h2><p><img src="/article/b0ee38f7/img_10.png" alt="扫雷游戏界面"></p><ol><li>坐上叫雷数（剩余旗🚩数）显示；</li><li>右上角计时器显示：初始点击雷区按钮触发计时，点击充值按钮触发计时器重置；</li><li>雷区按钮：<ul><li>左击：① 显示该按钮下内容：数字（1、2…）：以该按钮坐标周围3*3个单位坐标按钮下存在雷的个数；② 雷（被引爆，游戏结束）；</li><li>右击：① 单机：插旗🚩（当且仅当在所有雷都进行插旗排雷后通关），占用旗数；② 双击：问好，不占用旗数，用于个人怀疑记录；</li></ul></li><li>game设置选项：<br><img src="/article/b0ee38f7/img_11.png" alt="Game设置界面"><br>可设置棋盘规格大小；其中Custom选项可进行自定义，且Height&lt;=24，Width&lt;=30.<br><strong>注：在开始扫雷时左击的第一个按钮，即使是雷也会由程序自动将该地址的雷转移到其他地址，保证玩家不会上来就挂.</strong></li></ol><h2 id="实现思路分析"><a href="#实现思路分析" class="headerlink" title="实现思路分析"></a>实现思路分析</h2><p>获取棋盘雷区数据存储地址，通过模拟点击事件对雷区所有按钮进行遍历点击，其中对内存存储数值含义为雷的进行模拟右击插旗，其他进行左击排查；通过计时器存储数值判断棋盘数据是否重置。</p><p>通过Spy++获取WinMine_XP.exe窗口句柄：<br><img src="/article/b0ee38f7/img_12.png" alt="句柄"><br>其中<br>IpClassName: Minesweeper<br>IpWindowsName: Minesweeper</p><h2 id="通过Cheat-Engine获取窗口WinMine-XP-exe窗口内存数据，并查找到棋盘内存点进行数据分析："><a href="#通过Cheat-Engine获取窗口WinMine-XP-exe窗口内存数据，并查找到棋盘内存点进行数据分析：" class="headerlink" title="通过Cheat Engine获取窗口WinMine_XP.exe窗口内存数据，并查找到棋盘内存点进行数据分析："></a>通过Cheat Engine获取窗口WinMine_XP.exe窗口内存数据，并查找到棋盘内存点进行数据分析：</h2><p><img src="/article/b0ee38f7/img_13.png" alt><br>分析棋盘数据（以9*9棋盘为例）</p><ul><li>棋盘规格数据：<br>· 宽度数据存储地址：Width=0x0100553;<br>· 长度数据存储地址：Height=0x0100553;<br><img src="/article/b0ee38f7/img_15.png" alt></li><li>雷区起始点地址：0x01005361;</li><li>计时器数据存储地址：0x0100579C;</li><li>地雷布局的内存位置：0x0100534;<br><img src="/article/b0ee38f7/img_14.png" alt></li><li>雷区按钮数据：<br>· 10：棋盘边界；<br>· 0F：无雷且未点击；<br>· 8F：有雷且未点击；<br>· 0E：无雷插旗；<br>· 8E：有雷插旗；<br>· CC：点击引爆；</li></ul><h2 id="通过spy-获取雷区按钮坐标相关信息"><a href="#通过spy-获取雷区按钮坐标相关信息" class="headerlink" title="通过spy++获取雷区按钮坐标相关信息"></a>通过spy++获取雷区按钮坐标相关信息</h2><p><img src="/article/b0ee38f7/img_16.png" alt><br>按钮坐标（1，1）中心对应串钩坐标约为（20，63），且相邻两个按钮之间的窗口坐标差值约为16个单位长度。</p><h1 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    PBYTE t = (PBYTE)<span class="number">0x0100579C</span>;</span><br><span class="line">    <span class="comment">//char szChar[20];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对不同窗口信息传送进行对应操作指令</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//输入任意字符实现一键通关</span></span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*t == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//内存地址</span></span><br><span class="line">            PBYTE m = (PBYTE)<span class="number">0x01005361</span>;</span><br><span class="line">            PBYTE w = (PBYTE)<span class="number">0x01005334</span>;</span><br><span class="line">            PBYTE h = (PBYTE)<span class="number">0x01005338</span>;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">20</span>, y = <span class="number">63</span>, n = <span class="number">1</span>, q = <span class="number">1</span>;  <span class="comment">//坐标</span></span><br><span class="line">            <span class="comment">//雷区按钮遍历</span></span><br><span class="line">            <span class="keyword">while</span> (x &lt;= <span class="number">20</span> + *w * <span class="number">16</span> &amp;&amp; y &lt;= <span class="number">63</span> + (*h - <span class="number">1</span>) * <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt; *h)</span><br><span class="line">                    y = <span class="number">63</span>;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; *w)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = <span class="number">20</span>;</span><br><span class="line">                    y += <span class="number">16</span>;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                    m += <span class="number">32</span> - *w;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (*m != <span class="number">143</span>)  <span class="comment">//非雷则左击</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//雷则右击</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_RBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                    <span class="built_in">SendMessage</span>(hwnd, WM_RBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//完成该按钮操作后移动至下一按钮坐标处</span></span><br><span class="line">                x += <span class="number">16</span>;</span><br><span class="line">                n++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">            y = <span class="number">63</span>;</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">            <span class="built_in">SendMessage</span>(hwnd, WM_LBUTTONUP, <span class="number">0</span>, <span class="built_in">MAKELPARAM</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>((WNDPROC)OPROC, hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>数据地址定义：<br>· PBYTE t: 计时器数据存储地址；<br>· PBYTE m: 雷区按钮起始点地址；<br>· PBYTE w: 雷区宽度数据存储地址；<br>· PBYTE h: 雷区长度数据存储地址；</li><li>坐标定义：<br>· x,y: 窗口坐标；<br>· n,q: 按钮坐标；</li><li>Switch(uMsg): 对不同窗口信息传送进行对应操作指令（在此选择通过从键盘输入任意字符实现一键通关指令）</li><li>while(x &lt;= 20 + w <em> 16 &amp;&amp; y &lt;= 63 + (</em>h - 1) * 16): 对雷区按钮进行遍历；<br>· if 此按钮坐标（n,q）下数据m!=143（8F）时，对该按钮坐标（x，y）模拟鼠标左击事件；<br>· else 对该按钮窗口坐标（x,y）模拟鼠标右击事件<br>· 完成该按钮操作后进行坐标移动</li><li>*t==0时（棋盘重置）重复上述操作；</li></ol><p><strong>笔记：</strong></p><ul><li><strong>同列相邻行间地址差推算：address+32-width；</strong> </li><li><strong>棋盘重置可通过 * p的值作为条件，棋盘重置后需要将地址指针及坐标悉数重置；</strong></li><li><strong>若本次布雷，在（1，1）即为雷时，由于程序对内存数据的访问限制会使第一次的模拟点击跳过，需在遍历后补充一次对（1，1）按钮的左击。</strong></li></ul><h2 id="注入函数"><a href="#注入函数" class="headerlink" title="注入函数"></a>注入函数</h2><p>void injected()<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">injected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">nullptr</span>, <span class="string">&quot;injected&quot;</span>, <span class="string">&quot;title&quot;</span>, MB_OK);</span><br><span class="line">    HWND OW = <span class="built_in">FindWindowA</span>(<span class="string">&quot;Minesweeper&quot;</span>, <span class="string">&quot;Minesweeper&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!OW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(<span class="literal">nullptr</span>, <span class="string">&quot;find window failed&quot;</span>, <span class="string">&quot;Failed&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OPROC = <span class="built_in">SetWindowLong</span>(OW, GWL_WNDPROC, (LONG)WindowProc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="入口点函数"><a href="#入口点函数" class="headerlink" title="入口点函数"></a>入口点函数</h2><p>BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">injected</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><h2 id="注入测试"><a href="#注入测试" class="headerlink" title="注入测试"></a>注入测试</h2><p>通过Xenos注入：<br><img src="/article/b0ee38f7/img_17.png" alt><br>接收到注入函数中设定的注入成功的MessageBox;</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=686304538&bvid=BV1SU4y1e733&cid=783764201&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><ol><li>模拟鼠标点击事件：<br>SendMessage()函数；<br>参考：<a href="https://wenku.baidu.com/view/b71d76a1ef3a87c24028915f804d2b160b4e8665.html"><strong>如何使用Sendmessage模拟某一按钮的点击事件</strong> - <em>百度文库</em></a></li><li>由于扫雷程序对第一次左击不触雷的设定，致使在测试中出现第一个按钮未被执行点击的情况：在遍历后补充对第一个按钮的无差别点击。</li></ol><h1 id="篇末BB"><a href="#篇末BB" class="headerlink" title="篇末BB"></a>篇末BB</h1><p>事实上这个外挂辅助的实现有许多不同中的思路，我不能确保自己选择的是最巧妙的但是我所唯一能操作实现的。<br>在大量辅助工具的帮助下对目标程序的内存分析十分简单且便捷。<br>个人认为本次实验的困难包括但不限于对内存数据的分析与利用，虽然能<del>照本宣科地</del>使用Spy++/CE/Xenos等，但我并未能利用好PeiD工具，或许因为人错过了更为便捷的信息获取与分析途径。<br>总而言之，虽然“独立”完成了扫雷外挂的编程实现是极具满足感的，但或以更多的是在对辅助工具的认识与使用上，于是更期待之后能够更熟练运用这些工具，做出更可拷/可刑的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary </tag>
            
            <tag> DLL </tag>
            
            <tag> 外挂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[人工智能]n-Queens的多种算法题解</title>
      <link href="/article/6703afdf/"/>
      <url>/article/6703afdf/</url>
      
        <content type="html"><![CDATA[<h1 id="相关叨叨8皇后问题与n皇后问题">相关叨叨：8皇后问题与n皇后问题</h1><p>八皇后问题（英文：Eightqueens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。下图是八皇后问题的一个解，可以用向量表示为：[f, d, g, a, h, b, e,c]，分别表示每行的皇后位置（列号）。 <img src="https://i.postimg.cc/PJnPNvxZ/image.png" alt="八皇后问题的一个解"></p><p>实验拟题来自于 <strong>中国海洋大学 人工智能先导实践lab03：比特匠心&amp;模拟退火</strong> <em>-by 徐建良</em></p><h1 id="n-queens多种解题方法思路">n-queens多种解题方法思路</h1><h2 id="回溯与8皇后">回溯与8皇后</h2><p>“回溯法（backtracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。“就是说，回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。而对于解决八皇后问题，以深度优先的回溯法作为最基础的思路，有如下应用：step1. 尝试先放置第一枚皇后，被涂黑的地方是不能放皇后<img src="https://pic3.zhimg.com/80/v2-bde25f03b5a86cc6ca47ee03fd171c9e_720w.jpg">step2. 第二行的皇后只能放在第三格或第四格，比方我们放第三格，则：<img src="https://pic2.zhimg.com/80/v2-40654679a56af2cd9282b9ae60d4c641_720w.jpg">step3.可以看到再难以放下第三个皇后，此时我们就要用到回溯算法了。我们把第二个皇后更改位置，此时我们能放下第三枚皇后了。<img src="https://pic1.zhimg.com/80/v2-b810b81e8843c11e30e62277ddde1b4c_720w.jpg">step4.虽然是能放置第三个皇后，但是第四个皇后又无路可走了。返回上层调用（3号皇后），而3号也别无可去，继续回溯上层调用（2号），2号已然无路可去，继续回溯上层（1号），于是1号皇后改变位置如下，继续回溯。<img src="https://pic2.zhimg.com/80/v2-a22c5c4152b4b8b488555be294837f39_720w.jpg">以上内容引自 <a href="https://zhuanlan.zhihu.com/p/54275352"><strong>小白带你学---回溯算法（BackTracking)</strong> <em>-知乎 <span class="citation" data-cites="小白算法">@小白算法</span></em></a></p><p>下面我们就建立在这一最基础的算法思路上，运用不同的进阶算法解决N阶皇后问题，且不断优化。</p><h2 id="利用哈希表降维进行初探">利用哈希表降维进行初探</h2><h3 id="算法说明">算法说明</h3><p>这个题解仅仅是建立在对该问题的探索与思考上，并无“创新”抑或“优化”可言，基于最暴力且朴素的降维思路，不断尝试从中找出规律、再考虑优化。### 二维哈希表 · 实现过程： 1.建立二维数组，将棋盘布局通过数组模拟占位信息。其中另外通过开辟数组分别存储列冲突、左斜冲突、和右斜冲突的信息。2. 设置回溯函数，统计该行下空余且不冲突可放置皇后的位置；-&gt;更新并计算位置占用情况；-&gt;若有空余位置，则从右起对每一位置依次进行回溯试探；-&gt;进入下一行的试探，深度优先搜索正确解，只要遇到无空位可放置，则逐层向上回溯，至存在空位的行；-&gt;依次对该行存在的可放置空位进行遍历试探，并对试探失败的空位进行排除；-&gt;记录可行解的个数。 3. 回溯函数部分代码如下 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span>** hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; hash[rowp][i] == <span class="number">0</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>** temp = <span class="keyword">new</span> <span class="type">int</span>* [n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">temp[i][j] = hash[rowp + i + <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">if</span> (hash[rowp][i])</span><br><span class="line">&#123;</span><br><span class="line">hash[rowp][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;down &lt; n;down++, l--, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= <span class="number">0</span>)</span><br><span class="line">hash[down][l] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n)</span><br><span class="line">hash[down][r] = <span class="number">0</span>;</span><br><span class="line">hash[down][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>][h] = temp[m][h];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> · 小结对于n-queens问题探索可行解过程，若n取值较小时较为迅速，且内存情况还算勉强，但对于8皇后、16皇后、甚至100皇后问题的求解，会占用大量内存，不仅执行过程极其缓慢，且容易导致触发程序断点、或是溢出问题。因而引出如下逐渐降维的实现过程。</p><h3 id="一维哈希表">一维哈希表</h3><p>· 实现： 1.为了减少内存压力，通过将二进制数的位运算与数组进行结合，用n个二进制数记录行中可放置位置，并将之存放在一维数组中；2. 思路与上大致相同，不再赘述。 3. 代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span>* hash, <span class="type">int</span> rowp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注释略</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rowp == n)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hash[rowp])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = hash[rowp] &amp; -hash[rowp];</span><br><span class="line"><span class="type">int</span> position = <span class="built_in">log</span>(p) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*int position = p == 1 ? 0 : pow(p, 0.5);*/</span></span><br><span class="line">hash[rowp] -= p;</span><br><span class="line"><span class="type">int</span>* temp = <span class="keyword">new</span> <span class="type">int</span>[n - rowp - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - rowp - <span class="number">1</span>;i++)</span><br><span class="line">temp[i] = hash[rowp + i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> down = rowp + <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">1</span>;down &lt; n;down++, l++, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n - position)</span><br><span class="line">left = left + p &lt;&lt; l;</span><br><span class="line"><span class="keyword">if</span> (r &lt;= position)</span><br><span class="line">right = right + p &gt;&gt; r;</span><br><span class="line">hash[down] = hash[down] &amp; ~(left | right | p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; rowp &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; bitset&lt;6&gt;(hash[i]) &lt;&lt; endl;*/</span></span><br><span class="line"><span class="built_in">dfs1</span>(hash, rowp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>;m &lt; n - rowp - <span class="number">1</span>;m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>;h &lt; n;h++)</span><br><span class="line">hash[rowp + m + <span class="number">1</span>] = temp[m];</span><br><span class="line"><span class="keyword">delete</span>[]temp;</span><br><span class="line">&#125; <span class="keyword">while</span> (hash[rowp]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> · 小结：相较起二维数组，效率仅仅提高了一点点，内存占用情况仍不够美观，遂考虑压缩至0维哈希，即仅使用一个二进制数来存储全部占位信息并进行回溯。</p><h2 id="位运算解法0维哈希表">位运算解法（0维哈希表）</h2><h3 id="位运算">位运算</h3><p>位运算与位运算符： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;   <span class="comment">//60 = 0011 1100</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;   <span class="comment">//13 = 0000 1101</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a &amp; b;             <span class="comment">//12 = 0000 1100 按位与</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 1 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a | b;             <span class="comment">//61 = 0011 1101 按位或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 2 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a ^ b;             <span class="comment">//49 = 0011 0001 异或</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 3 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = ~a;                <span class="comment">//-61 = 1100 0011 按位取反</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 4 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;            <span class="comment">//240 = 1111 0000 位左移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 5 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;            <span class="comment">//15 = 0000 1111 位右移</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Line 6 - Value of c is: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure> ### n-queens与位运算 1.思路说明（以8皇后为例）首先，我们的基本思路与传统一样，每一行只能放并且必须放一个皇后。每次放置一个皇后之后，它就会对后面所有行中，可能放置皇后的位置产生影响。如下图所示，我们已经放置了三个皇后Q1，Q2，Q3。 接着在下面一行放置 Q4时，用彩色标注出的区域都是不可行的方案，会与已经放置的三个皇后产生冲突。<img src="https://i.postimg.cc/2jKVq5cV/image.png" alt="表达有无冲突的二进制数图解（本图来源于网络）">这个冲突其实有三种不同的情况，我们用三个变量A，B，C分别表示这三种不同的冲突。这三个变量都是一个八位的二进制数，这八位中，为1 的表示有冲突，为 0 则表示没有冲突。 (1)与已放置的皇后处于同一列中：我们用 A表示这种冲突。例如在图中，第四行会有三个位置因为列攻击而不能再放置皇后（图中大红色方块），因此A = 1000 1001。 (2)与已放置的皇后处于同一左斜(指向右下方)对角线中：我们用 B表示这种冲突。例如在图中，蓝色方块所表示的位置，分别是由于Q1和Q2的左斜对角线上的攻击而不能够放置新的皇后，因此B = 0001 0010。 (3)与已放置的皇后处于同一右斜(指向右上方)对角线中：我们用 C 表示这种冲突。例如图中粉色方块，是由 Q2的右斜对角线的攻击造成的。因此 C = 0010 0000。 有了 A，B，C三个变量，我们很容易求出当前行(第 4行)中，有哪些位置是可以放置皇后的。这个变量我们用 D 来表示，我们可以写出D = ~(A|B|C)。D中为 1 的那些位置则是我们可以放置皇后的位置。上图中，D =0100 0100。此时，我们有两个可能的放置皇后的位置，那么如何取出每个可能的位置呢？这里有一个技巧。我们用 bit 表示可能的一个位置，使用 bit = D &amp; (-D)即可取出 D 中最右边的 1（LSB，Least Significant Bit）。例如 D = 01000100，则-D = 10111100（注意计算机中的数都是补码，-D = ~D + 1）。而bit =D &amp; (-D) = 0000 0100 取出了最右边的那个 1，代表在第 4 行第 6列放置一个皇后。那么在此基础上，如何确定第 5 行的 A、B、C的值呢？其实也很简单，对于表示列冲突的变量 A 来说，只要使用 A|bit即可表示下一行的列冲突情况，对于 B，采用(B|bit)&lt;&lt;1，对于C，采用(C|bit)&gt;&gt;1 即可表示下一行中，对角线冲突的情况。上述算法的思路来自于 <a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><strong>BacktrackingAlgorithms in MCPL using Bit Patterns and Recursion</strong> <em>-byMartin Richards</em></a>(这个链接好像并不很稳定的样子，可以挂个梯子去看) 2. 代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> hash,<span class="type">int</span> B,<span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//B左斜冲突</span></span><br><span class="line">    <span class="comment">//C右斜冲突</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//由于同列冲突的条件限定，且棋盘行数与列数相等</span></span><br><span class="line">    <span class="comment">//若想在每一列都放置皇后，则皇后不可能在同列，同时满足每一列都有皇后</span></span><br><span class="line">    <span class="comment">//因而可通过判断是否满足每一列都有皇后的条件来判断是否达成最终效果</span></span><br><span class="line"><span class="comment">//hash记录列冲突</span></span><br><span class="line"><span class="comment">//当hash==n，即所有每一列都放置了皇后时，结束本轮试探并计数</span></span><br><span class="line"><span class="keyword">if</span> (hash==n)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置回溯记忆点rememtemp</span></span><br><span class="line"><span class="comment">//若rememtemp==0时，即该行无位置可供放置，结束试探并开始回溯</span></span><br><span class="line"><span class="type">int</span> rememtemp = n &amp; ~(B | C | hash);  <span class="comment">//初始继承上一行中的放置情况</span></span><br><span class="line"><span class="keyword">while</span> (rememtemp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义A表示同列冲突，且其列位置会直接被继承到该行后的各行中</span></span><br><span class="line"><span class="type">int</span> A = rememtemp &amp; -rememtemp;     <span class="comment">//取当前行中最右一个可放置皇后的位置</span></span><br><span class="line">rememtemp -= A;       <span class="comment">//在记忆点中将A位置设置为0</span></span><br><span class="line"><span class="comment">//左斜冲突与右斜冲突在继承上一行的冲突情况同时，分别通过对该A位置的左移与右移进行对下一行冲突的更新</span></span><br><span class="line"><span class="comment">//对hash更新列冲突情况</span></span><br><span class="line"><span class="built_in">dfs0</span>(hash | A, (B | A) &lt;&lt; <span class="number">1</span>, (C | A) &gt;&gt; <span class="number">1</span>);      <span class="comment">//进入下一行</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3. 结果输出：<img src="https://i.postimg.cc/ZRmDxZwN/image.png" alt="6-queens"> <img src="https://i.postimg.cc/y89PQtgy/image.png" alt="10-queens"> <img src="https://i.postimg.cc/W1262n5M/image.png" alt="14-queens"> <img src="https://i.postimg.cc/d0f8jKwB/image.png" alt="16-queens"> ###小结利用位运算对n-queens问题可行解的数量进行统计，其延续了上述通过哈希表的思路，但代码更为简洁、运行速度更快、占用空间更小。唯一比较困难的是对于单一的二进制变量来储存整个棋盘的空位更新信息，在向下试探过程中容易忽略对当前行的“存档”，而在回溯过程中又容易忘记“读档”，而导致信息混乱。这个问题的解决则是在每次递归之前设置一个存档变量，将当前的数据存储之后再进行向下的试探，因而保证了在每一层的回溯过程中会自动读取上次所记录的数据。下图是1-27阶问题的所有可行解： <img src="/article/6703afdf/image.png" alt="1~27阶可行解">对于该图中的分布状态的总结与思考，又引出了下文新的算法——多项式时间算法。</p><h2 id="n皇后的多项式时间算法">N皇后的多项式时间算法</h2><h3 id="算法说明-1">算法说明</h3><p>本算法来自于<a href="https://dl.acm.org/doi/pdf/10.1145/101340.101343"><strong>APolynomial Time Algorithm for the N-Queens Problem</strong> <em>-by RokSosic &amp; Jun Gu</em></a>(这个链接好像并不很稳定的样子，可以挂个梯子去看) 在 1990年首先提出。其灵感来源于对n阶可行解数量的考察，可以得出：可行解数量众多且均匀分布于整个状态空间(棋盘上皇后的所有可能的 n!个排列)中。 思路简述：通过一维数组将行数与该行对应皇后的列位置建立映射；-&gt;随机打乱并保证每行皇后不在同一列；-&gt;遍历判断皇后i或皇后j是否存在对角线冲突；-&gt;若冲突，则试探交换两行皇后的位置；-&gt;判断交换后，全局冲突(评估值)是否减少，若减少则确定交换并使操作数自增记录，否则不交换且不记录；-&gt;若都不冲突则不操作； -&gt;遍历，知道操作数为0；-&gt;判断调整后全局是否存在冲突，若存在则打乱重来（重启）；-&gt;输出该解。</p><p>如下图是原论文中关于算法思路的说明(部分): <img src="/article/6703afdf/image%20(2).png" alt="A Fast Algorithm for the N-Queens Problem"></p><p>此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="代码实现">代码实现</h3><p>代码实现如下（虽然感觉我写的怪怪的）: 1. 评估函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评估函数，计算当前棋盘下的冲突数，作为评估值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li><p>单个皇后局部对角线冲突计算： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个皇后局部对角线冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Attacked</span><span class="params">(<span class="type">int</span> *Board,<span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Att = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=row+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(Board[i] - Board[row]))</span><br><span class="line">Att++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Att&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Att;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p></li><li><p>取解： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heuristic</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> swaps_performed = <span class="number">0</span>;  <span class="comment">//设定计步器</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span>[n];      <span class="comment">//设定当前棋盘</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span>[n];         <span class="comment">//设定试探棋盘</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">swaps_performed = <span class="number">0</span>;     <span class="comment">//重计</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Attacked</span>(Current, i) || <span class="built_in">Attacked</span>(Current, j))   <span class="comment">//if queeni is attacked or queenj is attacked</span></span><br><span class="line">&#123;</span><br><span class="line">Next[i] = Current[j];</span><br><span class="line">Next[j] = Current[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Next) &lt; <span class="built_in">Conflicts</span>(Current))     <span class="comment">//if swap(queeni,queenj) reduces collisions </span></span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Next[i];</span><br><span class="line">Current[j] = Next[j];</span><br><span class="line">swaps_performed++;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;*/</span></span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Next[i] = Current[i];</span><br><span class="line">Next[j] = Current[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Conflicts</span>(Current))      <span class="comment">//检查是否获得解，若未获得解则打乱重来</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Current[i];</span><br><span class="line">Current[i] = Current[j];</span><br><span class="line">Current[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">swaps_performed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (swaps_performed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = Current[i];</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>多项式时间测试主函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Polyn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;         </span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">Heuristic</span>(Board);</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 结果展示(14皇后为例)： <img src="/article/6703afdf/img.png" alt="14queens"></p></li></ol><h3 id="小结">小结：</h3><p>在编写过程中，感觉有些熟悉，有点随机重启爬山的味道，怀疑是不是自己并没有很好地利用好原作者的多项式时间算法思路）因为在实现过程中会出现自动跳出局域最优解（而可能并未达到全局最优），因而出现错误的结果，遂在完全照搬论文中伪代码的内容同时，增添了随机重启的部分，来确保最终结果为全局最优而非仅仅的局部最优。我在这里的处理似乎并不是一个最合适的弥补策略，可以说并未很好地遵照多项式时间算法的巧妙设计。后续（或许很有可能不会）再返回来好好参悟一下算法来源的论文。而面对上述提到的局部最优解的跳出，下文将会由此展示一个巧妙解决局部困死问题/提高效率的算法。</p><h2 id="模拟退火算法在n皇后问题的运用">模拟退火算法在N皇后问题的运用</h2><p>模拟退火很好地解决了局部困死地问题，因为它在运行过程中会对微小变动进行一定程度上的接受，即使这个微小变动所得到的最终解并不是我们想要的解，正是这种设定提高了执行效率。此算法只是用于寻找并输出任一可行解，而不作为计算可行解总数的算法。</p><h3 id="算法说明-2">算法说明</h3><p>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合一定的概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。将温度T当作控制参数，目标函数值f视为内能E，而固体在某温度T时的一个状态对应一个解[公式]，然后算法试图随着控制参数T的降低，使目标函数f(内能E)也逐渐降低，直至趋于全局最小值（退火中低温时的最低能量状态），就像金属退火过程一样。<img src="https://pic4.zhimg.com/80/v2-e1529b1b1577eecd16fb8a5418d51533_720w.jpg" alt="模拟退火流程图"> 其中有几个需要注意的点： ·初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。 ·在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。·当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</p><p>以上内容来自 <a href="https://zhuanlan.zhihu.com/p/266874840"><strong>模拟退火算法详解</strong><em>-知乎 <span class="citation" data-cites="智能算法">@智能算法</span></em></a></p><p>思路简述： 通过一维数组将行数与该行对应皇后的列位置建立映射；-&gt;设定初始温度且足够大，设定最小温度且一定小，设定退火速率；-&gt;以行为单位遍历调整皇后位置，并计算调整前后的冲突值的差；-&gt;若能量差小于0，则证明修改后的评估值耕地，在一定概率下接收评估值降低的修改，且使这个概率不知逐渐减小；否则直接接受调整；-&gt;逐渐降温确保在未获得最优解时跳出局部最低温；-&gt;直至调整到获得全局最低温结束； -&gt;输出该解。</p><h3 id="代码实现-1">代码实现</h3><p>代码实现如下： 1. 评估函数（与多项式时间算法的全局冲突数函数一样）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Conflicts</span><span class="params">(<span class="type">int</span>* Board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Conf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对角线冲突数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(j - i) == <span class="built_in">abs</span>(Board[i] - Board[j]))</span><br><span class="line">Conf++;</span><br><span class="line"><span class="comment">// 列冲突数</span></span><br><span class="line"><span class="keyword">if</span> (Board[i] == Board[j])</span><br><span class="line">Conf++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; Conf&lt;&lt;endl;*/</span></span><br><span class="line"><span class="keyword">return</span> Conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li><p>退火调整： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">proper</span><span class="params">(<span class="type">int</span>* Board, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> T = <span class="number">100.0</span>;    <span class="comment">//设定初始温度且足够大</span></span><br><span class="line"><span class="type">double</span> Tmin = <span class="number">1.0</span>;        <span class="comment">//设定最小温度且一定小</span></span><br><span class="line"><span class="type">double</span> Rate = <span class="number">0.8</span>;           <span class="comment">//退火速率</span></span><br><span class="line"><span class="type">int</span>* Current = <span class="keyword">new</span> <span class="type">int</span> [n];         <span class="comment">//记录当前棋盘放置情况</span></span><br><span class="line"><span class="type">int</span>* Next = <span class="keyword">new</span> <span class="type">int</span> [n];           <span class="comment">//记录修改后棋盘放置情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Current[i] = Board[i];</span><br><span class="line">Next[i] = Board[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (T &gt; Tmin)        <span class="comment">//开始退火</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>;p &lt; n;p++)        <span class="comment">//遍历修改</span></span><br><span class="line">&#123;</span><br><span class="line">Next[row] = p;</span><br><span class="line"><span class="type">double</span> dE = <span class="built_in">Conflicts</span>(Next) - <span class="built_in">Conflicts</span>(Current);       <span class="comment">//计算能量差</span></span><br><span class="line"><span class="comment">//若能量差小于0，则证明修改后的评估值更低</span></span><br><span class="line"><span class="comment">//在一定概率下接受评估值降低的修改，且使这个概率值逐渐减小</span></span><br><span class="line"><span class="keyword">if</span> (dE &lt;= <span class="number">0</span> || (<span class="built_in">exp</span>((<span class="number">-1</span>) * dE / T) &gt; <span class="built_in">rand</span>() % <span class="number">100</span> * <span class="number">1.0</span> / <span class="number">10</span>))</span><br><span class="line">Current[row] = Next[row];</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Current[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">T *= Rate;         <span class="comment">//降温</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]Next;</span><br><span class="line">Board[row] = Current[row];</span><br><span class="line"><span class="keyword">delete</span>[]Current;</span><br><span class="line"><span class="keyword">return</span> Board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>模拟退火测试主函数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Simul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Board[n]的值为棋盘第n行放置皇后的列位置</span></span><br><span class="line"><span class="type">int</span>* Board = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">Board[i] = i;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//保证不放在同列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="type">int</span> temp = Board[i];</span><br><span class="line">Board[i] = Board[j];</span><br><span class="line">Board[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Board[i];</span></span><br><span class="line"><span class="comment">if (i == n - 1)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Conflicts</span>(Board))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == n)         <span class="comment">//重置</span></span><br><span class="line">row = <span class="number">0</span>;</span><br><span class="line">Board = <span class="built_in">proper</span>(Board, row++);         <span class="comment">//修改第row行皇后放置位置</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; row;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Board[i] == j)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; Q &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; # &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+---&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>运行结果： 与上无差，不做赘述。</p></li></ol><h3 id="小结-1">小结</h3><p>经过对N皇后问题的不断深入探索（主要依赖于牛批前辈们的不同算法的提出），模拟退火用于寻找并输出n阶任一可行解，较好地解决了暴力遍历算法所导致的内存占用过大的问题/耗时过长效率低的问题，同时解决了多项式算法局部困死的问题，对该问题的不同算法探索到此为止（事实上是因为实验布置的内容要求到此为止）。</p><h1 id="篇末bb">篇末BB</h1><p>N-Queens/N皇后/无论怎么称呼的这一人工智能问题，属实经典，且解法众多，包括但远不限于如上所展示的位运算/多项式时间算法/模拟退火算法的经典算法，甚至如用爬山算法也将是很好的解题思路。对于人工智能，算法优化是其最关键的部分，面对庞大计算量，能否使程序语句更加精炼/占用内存尽可能少/运行速度更快，决定了你的人工是否足够智能。</p><p><sub>（反正对于这一灵活度极高的问题上，我搜索且浏览了很多资料和文献才逐步探索出最优的算法，一圈子下来只是觉得自己是一人工智障）</sub></p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 模拟退火 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello/Bonjour/你好</title>
      <link href="/article/d2ad3194/"/>
      <url>/article/d2ad3194/</url>
      
        <content type="html"><![CDATA[<h2 id="hello">Hello!</h2><p><font size="4">This blog belongs to a student of Ocean University ofChina. It is used to record and share his undergraduate leaningexperience and some interesting technology in computer sciencemajor.</font></p><h2 id="bonjour">Bonjour!</h2><p><font size="4">Ce blog appartient à un étudiant de l'universitéOcéanique de Chine. Il est utilisé pour documenter et partager sonexpérience de premier cycle en informatique et centaines techniqueinteressantes.</font></p><h2 id="你好哇">你好哇！</h2><p><font size="4">这个博客是一个中国海洋大学的学生创设的，用来记录和分享一些他本科期间在计算机专业的一些学习经验和有趣的技术。对了，他的网名常用“Mo01iHt”，他也喜欢被叫做“文子哥”。</font></p><hr>]]></content>
      
      
      <categories>
          
          <category> 题外话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ME </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
